\chapter{Technical preliminaries}\label{technical}

In this chapter we recall technical definitions and results used in the following chapters.
In Section~\ref{ml} we introduce modal logic, along with logical notation and terminology applicable to the other logics we will be working with.
All of the logics that we will be considering are modal logics or extensions of modal logics, and the definitions and results of this section will be used throughout the following sections and chapters. 
In Section~\ref{pal} we introduce public announcement logic, a logic for reasoning about the effects of specific epistemic updates, then in Section~\ref{apal} we introduce arbitrary public announcement logic, a logic for reasoning additionally about the effects of arbitrary epistemic updates.
As a simple form of epistemic update we often use public announcements in examples and motivation throughout the dissertation, and we consider public announcements more closely in Chapter~\ref{papal} on arbitrary positive announcement logic.
In Section~\ref{aml} we introduce action model logic, a logic for reasoning about the effects of specific epistemic updates of a more general kind than just public announcements.
As a very general form of epistemic update we use action models in motivating the investigation of refinement modal logic in Chapter~\ref{rml}, and we consider action models more closely in Chapter~\ref{aafl} on arbitrary action formula logic.
Finally in Section~\ref{mu} we introduce the modal $\mu$-calculus, a very expressive extension of modal logic that we use as a point of comparison for the expressivity of refinement modal logics in Chapter~\ref{rml}.

\section{Modal logic}\label{ml}

We recall standard definitions and results from modal logic.  

Let $\atoms$ be a non-empty, countable set of propositional atoms, and
let $\agents$ be a non-empty, finite set of agents.

\begin{definition}[Language of modal logic]
The {\em language of modal logic}, \langMl{}, is inductively defined as:
$$
\phi ::= 
    \atomP \mid
    \lnot \phi \mid
    (\phi \land \phi) \mid
    \necessaryA \phi
$$
where $\atomP \in \atoms$ and $\agentA \in \agents$.
\end{definition}

We use all of the standard abbreviations from propositional logic, in addition to the abbreviation $\possibleA \phi ::= \lnot \necessaryA \lnot \phi$.

The formula $\necessaryA \phi$ may be read as ``agent $\agentA$ {\em knows} that $\phi$ is true'', or ``agent $\agentA$ {\em believes} that $\phi$ is true'', depending on which terminology is appropriate for the setting we are working in.
The formula $\possibleA \phi$ may be read as ``agent $\agentA$ considers it possible that $\phi$ is true'', i.e. agent $\agentA$ doesn't know (or believe) that $\phi$ is false.

\begin{definition}[Kripke frames]
A {\em Kripke frame}, $\kFrameAndTuple$ consists of:
a {\em domain} $\kStates$, which is a non-empty set of states (or {\em possible worlds}); and
an indexed set of {\em accessibility relations} $\kAccessibilityRel$, indexed on $\agents$, where for every $\agentA \in \agents$, $\kAccessibilityA \subseteq \kStates \times \kStates$ is a binary relation on states.
\end{definition}

We write $\kStateS \kAccessibilityA \kStateT$ to denote that $(\kStateS, \kStateT) \in \kAccessibilityA$.
We write $\kSuccessorsA{\kStateS}$ to denote the set of successor states $\kSuccessorsA{\kStateS} = \{\kStateT \in \kStates \mid \kStateS \kAccessibilityA \kStateT\}$ and
we write $\kPredecessorsA{\kStateT}$ to denote the set of predecessor states $\kPredecessorsA{\kStateT} = \{\kStateS \in \kStates \mid \kStateS \kAccessibilityA \kStateT\}$.

We will be working with a variety of modal logics that are defined by relational properties on Kripke frames.
We define those relational properties here.

\begin{definition}[Relational properties]
Let $\kStates$ be a set and let $\kAccessibilityRel \subseteq \kStates \times \kStates$ be a binary relation on $\kStates$. 
Then we say that $\kAccessibilityRel$ is \ldots
\begin{itemize}
    \item \ldots {\em serial} if and only if for every $\kStateS \in \kStates$ there exists $\kStateT \in \kStates$ such that $\kStateS \kAccessibility{} \kStateT$.
    \item \ldots {\em reflexive} if and only if for every $\kStateS \in \kStates$: $\kStateS \kAccessibility{} \kStateS$.
    \item \ldots {\em transitive} if and only if for every $\kStateS, \kStateT, \kStateU \in \kStates$: if $\kStateS \kAccessibility{} \kStateT$ and $\kStateT \kAccessibility{} \kStateU$ then $\kStateS \kAccessibility{} \kStateU$.
    \item \ldots {\em symmetric} if and only if for every $\kStateS, \kStateT \in \kStates$: if $\kStateS \kAccessibility{} \kStateT$ then $\kStateT \kAccessibility{} \kStateS$.
    \item \ldots {\em Euclidean} if and only if for every $\kStateS, \kStateT, \kStateU \in \kStates$: if $\kStateS \kAccessibility{} \kStateT$ and $\kStateS \kAccessibility{} \kStateU$ then $\kStateT \kAccessibility{} \kStateU$.
\end{itemize}
\end{definition}

When we ascribe relational properties to Kripke frames we actually ascribe those properties to each of the accessibility relations of the Kripke frame.
So we say that a Kripke frame $\kFrameAndTuple$ is \{serial, reflexive, etc.\} if and only if for every $\agentA \in \agents$ the binary relation $\kAccessibilityA$ is \{serial, reflexive, etc.\}.

We use these relational properties to define the classes of Kripke frames that we will be working with.

\begin{definition}[Classes of Kripke frames]
We define the following classes of Kripke frames:
\begin{itemize}
    \item The class \classK{} of all Kripke frames.
    \item The class \classKF{} of all transitive Kripke frames.
    \item The class \classKFF{} of all transitive and Euclidean Kripke frames.
    \item The class \classKD{} of all serial, transitive and Euclidean Kripke frames.
    \item The class \classSF{} of all reflexive and transitive Kripke frames.
    \item The class \classS{} of all reflexive, transitive and Euclidean Kripke frames.
\end{itemize}
\end{definition}

\begin{definition}[Kripke models]
A {\em Kripke model}, $\kModelAndTuple$ consists of an underlying Kripke frame $\kFrameAndTuple$ along with a {\em valuation function} $\kValuation : \atoms \to \powerset(\kStates)$, which is a function from propositional atoms to sets of states.

A {\em pointed Kripke model} $\kPModelAndTuple{\kStateS}$ consists of a Kripke model $\kModelAndTuple$ along with a designated state (the {\em real world}), $\kStateS \in \kStates$.
A {\em multi-pointed Kripke model} $\kPModelAndTuple{\kStatesT}$ consists of a Kripke model $\kModelAndTuple$ along with a non-empty set of designated states, $\kStatesT \subseteq \kStates$.
\end{definition}

As we will often work with Kripke models rather than frames we overload the notation for classes of Kripke frames to also refer to classes of Kripke models.
When we ascribe relational properties or frame properties to a Kripke model we actually ascribe those properties to its underlying Kripke frame.
We will sometimes treat a (single-)pointed Kripke model as though it were a multi-pointed Kripke model and we assume in this case that $\kPModel{\kStateS}$ is an abbreviation for $\kPModel{\{\kStateS\}}$.

We now define the semantics of modal logic.

We define the semantics in terms of a parameterised class of Kripke frames, \classC{}, which could stand for \classK{}, \classKF{}, \classKFF{}, etc. or for any other class of Kripke frames so defined.

\begin{definition}[Semantics of modal logic]\label{ml-semantics}
Let $\classC$ be a class of Kripke frames, let $\phi \in \langMl$, and let $\kPModelAndTuple{\kStateS} \in \classC$ be a pointed Kripke model.
The interpretation of the formula $\phi$ in the logic \logicC{} on the pointed Kripke model $\kPModel{\kStateS}$ is defined inductively as:
$$
\begin{array}{lcl}
\kPModel{\kStateS} \entails \atomP & \text{ iff } & \kStateS \in \kValuation(\atomP)\\
\kPModel{\kStateS} \entails \lnot \phi & \text{ iff } & \kPModel{\kStateS} \nentails \phi\\
\kPModel{\kStateS} \entails \phi \land \psi & \text{ iff } & \kPModel{\kStateS} \entails \phi \text{ and } \kPModel{\kStateS} \entails \psi\\
\kPModel{\kStateS} \entails \necessaryA \phi & \text{ iff } & \text{for every } \kStateT \in \kSuccessorsA{\kStateS} : \kPModel{\kStateT} \entails \phi
\end{array}
$$
\end{definition}

In particular we define the semantics of the modal logics \logicK{}, \logicKF{}, \logicKFF{}, etc. for the respective classes of Kripke frames \classK{}, \classKF{}, \classKFF{}, etc.

Let $\kPModel{\kStateS} \in \classC$ be a pointed Kripke model,
let $\kFrame \in \classC$ be a Kripke frame.
If $\kPModel{\kStateS} \entails \phi$ then we say that $\phi$ is {\em valid} on $\kPModel{\kStateS}$.
Let $\Phi \subseteq \langMl$ be a (possibly infinite) set of formulas.
If $\kPModel{\kStateS} \entails \phi$ for every $\phi \in \Phi$ then we say that $\Phi$ is {\em valid} on $\kPModel{\kStateS}$ and we write $\kPModel{\kStateS} \entails \Phi$.
If $\kPModel{\kStateS} \entails \Phi$ for every $\kStateS \in \kStates$ then we say that $\Phi$ is valid on $\kModel$ and we denote this by $\kModel \entails \Phi$.
If $\kModel \entails \Phi$ for every $\kModel$ with the underlying Kripke frame $\kFrame$ then we say that $\Phi$ is valid on $\kFrame$ and we denote this by $\kFrame \entails \Phi$.
If $\kFrame \entails \Phi$ for every $\kFrame \in \classC$ then we say that $\Phi$ is valid on \classC{} and we denote this by $\classC \entails \Phi$.
When \classC{} is clear from context we may simply write $\entails \Phi$ instead of $\classC \entails \Phi$.
If $\kStatesT \subseteq \kStates$ and there exists $\kStateS \in \kStatesT$ such that $\kPModel{\kStateS} \entails \Phi$ then we say that $\Phi$ is {\em satisfiable} in $\kPModel{\kStatesT}$.
If $\Phi$ is satisfiable in $\kPModel{\kStates}$ then we say that $\Phi$ is satisfiable in $\kModel$.
If $\Phi$ is satisfiable in $\kModel$ with the underlying Kripke frame $\kFrame$ then we say that $\Phi$ is satisfiable in $\kFrame$.
If there exists $\kFrame \in \classC$ such that $\Phi$ is satisfiable in $\kFrame$ then we say that $\Phi$ is satisfiable in \classC{}.
If every finite subset of $\Phi$ is satisfiable in \{$\kPModel{\kStatesT}$, $\kModel$, $\kFrame$, \classC{}\} then we say that $\Phi$ is {\em finitely satisfiable} in \{$\kPModel{\kStatesT}$, $\kModel$, $\kFrame$, \classC{}\}.

We write $\interpretation[\kModel]{\phi}$ to denote the set of states where $\phi$ is valid, $\interpretation[\kModel]{\phi} = \{\kStateS \in \kStates \mid \kPModel{\kStateS} \entails \phi\}$.

Next we recall definitions and results related to bisimilarity of Kripke models.
Bisimilarity is an important concept in modal logics.
Notably the modal logic \logicK{} corresponds to the bisimulation-invariant fragment of first-order logic, and there is a partial correspondence between bisimilarity and equivalence under modal validity.

\begin{definition}[Bisimulation]
Let $\kModelAndTuple$ and $\kModelAndTupleP$ be Kripke models.
A non-empty relation $\bisimulation \subseteq \kStates \times \kStatesP$ is a {\em bisimulation} if and only if for every $\atomP \in \atoms$, $\agentA \in \agents$ and $(\kStateS, \kStateSP) \in \bisimulation$ the following conditions, {\bf atoms-$\atomP$}, {\bf forth-$\agentA$} and {\bf back-$\agentB$} holds:

\paragraph{atoms-$\atomP$}
$\kStateS \in \kValuation(\atomP)$ if and only if $\kStateSP \in \kValuationP(\atomP)$.

\paragraph{forth-$\agentA$}
For every $\kStateT \in \kSuccessorsA{\kStateS}$ there exists $\kStateTP \in \kSuccessorsPA{\kStateSP}$ such that $\kStateS \bisimulation \kStateT$.

\paragraph{back-$\agentA$}
For every $\kStateTP \in \kSuccessorsPA{\kStateSP}$ there exists $\kStateT \in \kSuccessorsA{\kStateS}$ such that $\kStateS \bisimulation \kStateT$.

If there exists a bisimulation $\bisimulation$ such that $\kStateS \bisimulation \kStateSP$ then we say that $\kPModel{\kStateS}$ and $\kPModelP{\kStateSP}$ are {\em bisimilar} and we denote this by $\kPModel{\kStateS} \bisimilar \kPModelP{\kStateSP}$.
\end{definition}

We first note that the bisimilarity relation forms an equivalence relation.

\begin{proposition}
The relation $\bisimilar$ is an equivalence relation (reflexive, transitive and symmetric) on Kripke models.
\end{proposition}

Bisimilar Kripke models are equivalent under modal validity.

\begin{proposition}\label{modal-bisimulation-invariance}
Let $\kPModel{\kStateS}, \kPModelP{\kStateSP}$ be pointed Kripke models such that $\kPModel{\kStateS} \bisimilar \kPModelP{\kStateSP}$.
Then for every $\phi \in \langMl$:
$\kPModel{\kStateS} \entails \phi$ if and only if $\kPModelP{\kStateSP} \entails \phi$.
\end{proposition}

Not all modally equivalent Kripke models are bisimilar.
However we can define a property of Kripke models that guarantees that modal equivalence implies bisimilarity.

\begin{definition}
Let $\kModelAndTuple$ be a Kripke model.
We say that $\kModel$ is {\em modally saturated} if and only if for every $\agentA \in \agents$, $\kStateS \in \kStates$ and $\Phi \subseteq \langMl$: if $\Phi$ is finitely satisfiable in $\kPModel{\kSuccessorsA{\kStateS}}$ then $\Phi$ is satisfiable in $\kPModel{\kSuccessorsA{\kStateS}}$.
\end{definition}

For modally saturated Kripke models, modal equivalence implies bisimilarity.

\begin{proposition}
Let $\kModel, \kModelP$ be modally saturated Kripke models such that for every $\phi \in \langMl$: $\kPModel{\kStateS} \entails \phi$ if and only if $\kPModelP{\kStateSP} \entails \phi$.
Then $\kPModel{\kStateS} \bisimilar \kPModelP{\kStateSP}$.
\end{proposition}

A notable class of modally saturated Kripke models are the finite and image-finite Kripke models.

\begin{definition}[Finite Kripke models]
Let $\kModelAndTuple$ be a Kripke model.
We say that $\kModel$ is {\em finite} if and only if $\kStates$ is finite.
\end{definition}

\begin{definition}[Image-finiteness]
Let $\kModelAndTuple$ be a Kripke model.
We say that $\kModel$ is {\em image-finite} if and only if for every $\agentA \in \agents$ and $\kStateS \in \kStates$: $\kSuccessorsA{\kStateS}$ is finite.
\end{definition}

\begin{proposition}
Every finite Kripke model is image-finite.
\end{proposition}

\begin{proposition}
Every image-finite Kripke model is modally saturated.
\end{proposition}

Thus for image-finite Kripke models it is also the case that modal equivalence implies bisimilarity.

Bisimulations can be computed in polynomial time for finite Kripke models.

\begin{proposition}
Let $\kModelAndTuple$ and $\kModelAndTupleP$ be finite Kripke models.
There is a unique, maximal bisimulation bisimulation between $\kModel$ and $\kModelP$ and it can be computed in polynomial time.
\end{proposition}

We also consider a depth-limited notion of bisimulation.

\begin{definition}[$n$-bisimulation]
Let $\kModelAndTuple$ and $\kModelAndTupleP$ be Kripke models and let $n \in \naturals$.
A list of non-empty relations $\bisimulation_0, \dots, \bisimulation_n$, where for $i = 0, \dots, n$ $\bisimulation_i \subseteq \kStates \times \kStatesP$, is an {\em $n$-bisimulation} if and only if for every $i = 0, \dots, n$, $\atomP \in \atoms$, $\agentA \in \agents$ and $(\kStateS, \kStateSP) \in \bisimulation_i$ the following conditions, {\bf atoms-$i$-$\atomP$}, {\bf forth-$i$-$\agentA$} and {\bf back-$i$-$\agentB$} holds:

\paragraph{atoms-$i$-$\atomP$}
If $i = 0$ then $\kStateS \in \kValuation(\atomP)$ if and only if $\kStateSP \in \kValuationP(\atomP)$.
If $i > 0$ then $\kPModel{\kStateS} \bisimulation_{i-1} \kPModelP{\kStateSP}$.

\paragraph{forth-$i$-$\agentA$}
For every $\kStateT \in \kSuccessorsA{\kStateS}$ there exists $\kStateTP \in \kSuccessorsPA{\kStateSP}$ such that $\kStateS \bisimulation_i \kStateT$.

\paragraph{back-$i$-$\agentA$}
For every $\kStateTP \in \kSuccessorsPA{\kStateSP}$ there exists $\kStateT \in \kSuccessorsA{\kStateS}$ such that $\kStateS \bisimulation_i \kStateT$.

If there exists an $n$-bisimulation $\bisimulation_0, \dots, \bisimulation_n$ such that $\kStateS \bisimulation_n \kStateSP$ then we say that $\kPModel{\kStateS}$ and $\kPModelP{\kStateSP}$ are {\em $n$-bisimilar} and we denote this by $\kPModel{\kStateS} \bisimilar[n] \kPModelP{\kStateSP}$.
\end{definition}

Similar to bisimilarity, there is a partial correspondence between $n$-bisimilarity and equivalence under depth-limited modal equivalence.

\begin{proposition}
The relation $\bisimilar[n]$ is an equivalence relation on Kripke models.
\end{proposition}

\begin{definition}[Modal depth]
Let $\phi \in \langMl$.
We denote the {\em modal depth of $\phi$} by $d(\phi)$ and define it inductively as:
\begin{eqnarray*}
    d(\atomP) &=& 0\\
    d(\lnot \phi) &=& d(\phi)\\
    d(\phi \land \psi) &=& max(d(\phi), d(\psi))\\
    d(\necessaryA \phi) &=& d(\phi) + 1
\end{eqnarray*}
\end{definition}

\begin{proposition}
Let $n \in \naturals$ and let $\kPModel{\kStateS}, \kPModelP{\kStateSP}$ be pointed Kripke models such that $\kPModel{\kStateS} \bisimilar[n] \kPModelP{\kStateSP}$.
Then for every $\phi \in \langMl$ such that $d(\phi) \leq n$:
$\kPModel{\kStateS} \entails \phi$ if and only if $\kPModelP{\kStateSP} \entails \phi$.
\end{proposition}

\begin{proposition}
Let $n \in \naturals$ and let $\kModel, \kModelP$ be modally saturated Kripke models such that for every $\phi \in \langMl$ such that $d(\phi) \leq n$: $\kPModel{\kStateS} \entails \phi$ if and only if $\kPModelP{\kStateSP} \entails \phi$.
Then $\kPModel{\kStateS} \bisimilar[n] \kPModelP{\kStateSP}$.
\end{proposition}

We now introduce the proof theory for modal logics, first providing an axiomatisations for the logic \logicK{}.

\begin{definition}[Axiomatisation \axiomK{}]
The axiomatisation \axiomK{} is a substitution schema consisting of the following axioms and rules:
$$
\begin{array}{rl}
    {\bf P}     & \text{All propositional tautologies}\\
    {\bf K}     & \proves \necessaryA (\phi \implies \psi) \implies (\necessaryA \phi \implies \necessaryA \psi)\\
    {\bf MP}    & \text{From } \proves \phi \implies \psi \text{ and } \proves \phi \text{ infer } \proves \psi\\
    {\bf NecK}  & \text{From } \proves \phi \text{ infer } \proves \necessaryA \phi
\end{array}
$$
\end{definition}

If $\proves \phi$ is in the least set containing the axioms and closed under the rules of an axiomatisation then we say that $\phi$ is {\em provable} using the axiomatisation.
Let $\Phi \subseteq \langMl$ be a (possibly infinite) set of formulas.
If there exists $\phi_1, \dots, \phi_n \in \Phi$ such that $\proves (\phi_1 \land \cdots \land \phi_n) \implies \phi$ then we say that $\phi$ is {\em deducible} from $\Phi$ and we write $\Phi \proves \phi$.
If $\Phi \proves \bot$ then we say that $\Phi$ is {\em inconsistent}, and if $\Phi \nproves \bot$ then we say that $\Phi$ is {\em consistent}.

We also provide axiomatisations for the logics \logicKF{}, \logicKFF{}, \logicKD{}, \logicSF{}, and \logicS{}, by extending the axiomatisation \axiomK{} with additional axioms.

\begin{definition}[Axiomatisations \axiomKF{}, \axiomKFF{}, \axiomKD{}, \axiomSF{}, and \axiomS{}]
We define the following axioms:
$$
\begin{array}{rl}
    {\bf D}     & \proves \necessaryA \phi \implies \possibleA \phi\\
    {\bf T}     & \proves \necessaryA \phi \implies \phi\\
    {\bf 4}     & \proves \necessaryA \phi \implies \necessaryA \necessaryA \phi\\
    {\bf 5}     & \proves \possibleA \phi \implies \necessaryA \possibleA \phi
\end{array}
$$

Then the axiomatisations \axiomKF{}, \axiomKFF{}, \axiomKD{}, \axiomSF{}, and \axiomS{} consist of the axioms and rules of \axiomK{} along with the following respective additional axioms:
\begin{itemize}
    \item \axiomKF{}: {\bf 4}
    \item \axiomKFF{}: {\bf 4} and {\bf 5}
    \item \axiomKD{}: {\bf D}, {\bf 4} and {\bf 5}
    \item \axiomSF{}: {\bf T} and {\bf 4}
    \item \axiomS{}: {\bf T} and {\bf 5}
\end{itemize}
\end{definition}

We are interested in properties of the proof theories of the logics we consider.

\begin{definition}[Soundness and completeness]
If every formula provable using an axiomatisation is valid in the corresponding semantics then we say that the axiomatisation is {\em sound} with respect to the logic.
If every formula valid in a semantics is provable using the corresponding axiomatisation then we say that the axiomatisation is {\em (weakly) complete} with respect to the semantics.
If every set of formulas that is consistent according to an axiomatisation is satisfiable in the corresponding semantics then we say that the axiomatisation is {\em strongly complete} with respect to the semantics.
\end{definition}

\begin{proposition}
The axiomatisations \axiomK{}, \axiomKF{}, \axiomKFF{}, \axiomKD{}, \axiomSF{}, and \axiomS{} are sound and strongly complete with respect to the semantics of the respective logics \logicK{}, \logicKF{}, \logicKFF{}, \logicKD{}, \logicSF{}, and \logicS{}.
\end{proposition}

We are also interested in properties of the logics themselves.

\begin{definition}[Compactness]
If every (possibly infinite) set of formulas that is finitely satisfiable according to the semantics of a logic is satisfiable then we say that the logic is {\em compact}.
\end{definition}

\begin{proposition}
The logics \logicK{}, \logicKF{}, \logicKFF{}, \logicKD{}, \logicSF{}, and \logicS{} are compact.
\end{proposition}

\begin{definition}[Model-checking problem]
The {\em model-checking problem} for a logic is to determine for a given formula and a given finite pointed Kripke model whether the formula is valid on the pointed Kripke model.
\end{definition}

\begin{proposition}
The model-checking problems for the logics \logicK{}, \logicKF{}, \logicKFF{}, \logicKD{} and \logicS{} are decidable in polynomial time.
\end{proposition}

\begin{definition}[Satisfiability and provability problems]
The {\em satisfiability problem} for a logic is to determine for a given formula whether the formula is satisfiable according to the semantics of the logic.
The {\em provability problem} for a proof system such as an axiomatisation is to determine for a given formula whether the formula is provable according to the proof system.
\end{definition}

We note that for sound and complete proof systems the satisfiability and provability problems are dual problems (a formula is satisfiable if and only if its negation is not provable).

\begin{proposition}
The satisfiability problems for the logics \logicK{}, \logicKF{}, \logicKFF{}, \logicKD{} and \logicS{} are decidable.
For the logics \logicK{}, \logicKFF{}, \logicKD{} and \logicS{} the problem is PSPACE-complete.\todo{Double-check complexity} 
\end{proposition}

In the following sections and chapters we will compare the expressive power of the logics that we consider to other logics, often to an underlying modal logic.

\begin{definition}[Expressivity]
If a logic can express all of the semantic properties that another logic can then we say that the logic is {\em at least as expressive} as the other logic.
If two logics are at least as expressive as each other then we say that the two logics are {\em expressively equivalent}.
If a logic is at least as expressive as but not expressively equivalent to another logic then we say that the logic is {\em strictly less expressive} than the other logic.
If two logics are neither at least as expressive as the other logic then we say that the two logics are {\em incomparable} in expressivity.
\end{definition}

\section{Public announcement logic}\label{pal}

We recall definitions and results from the public announcement logic of Plaza~\cite{plaza:1989}.

\begin{definition}[Language of public announcement logic]
The {\em language of public announcement logic}, \langPal{}, is inductively defined as:
$$
\phi ::= 
    \atomP \mid
    \lnot \phi \mid
    (\phi \land \phi) \mid
    \necessaryA \phi \mid
    \announceA{\phi} \phi
$$
where $\atomP \in \atoms$ and $\agentA \in \agents$.
\end{definition}

We use all of the standard abbreviations from modal logic, in addition to the abbreviation $\announceE{\phi} \psi ::= \lnot \announceA{\phi} \lnot \psi$.

The formula $\announceA{\phi} \psi$ may be read as ``if $\phi$ is true then after publicly announcing that it is true, $\psi$ is true''.
The formula $\announceE{\phi} \psi$ may be read as ``$\phi$ is true and after publicly announcing that it is true, $\psi$ is true''.

\begin{definition}[Model restriction]
Let $\kModelAndTuple$ be a Kripke model and let $\kStatesT \subseteq \kStates$.
We denote the {\em restriction of $\kModel$ to $\kStatesT$} by $\restrict{\kModel}{\kStatesT}$ and
define it as $\restrict{\kModel}{\kStatesT} = (\kStatesT, \restrict{\kAccessibilityRel}{\kStatesT}, \restrict{\kValuation}{\kStatesT})$ where:
\begin{eqnarray*}
    \restrict{\kAccessibilityA}{\kStatesT} &=& \kAccessibilityA \cap (\kStatesT \times \kStatesT)\\
    \restrict{\kValuation}{\kStatesT}(\atomP) &=& \kValuation(\atomP) \cap \kStatesT
\end{eqnarray*}

Let \lang{} be a logical language with an interpretation on $\kModel$, and let $\phi \in \lang$.
We denote the {\em restriction of $\kModel$ to $\phi$} by $\restrict{\kModel}{\phi}$ and define it as $\restrict{\kModel}{\phi} = \restrict{\kModel}{\interpretation[\kModel]{\phi}}$.
\end{definition}

\begin{definition}[Semantics of public announcement logic]\label{pal-semantics}
Let $\phi \in \langPal$ and let $\kPModelAndTuple{\kStateS} \in \classS$ be a pointed Kripke model.
The interpretation of the formula $\phi$ in the logic \logicPalS{} on the pointed Kripke model $\kPModel{\kStateS}$ is the same as its interpretation in modal logic, defined in Definition~\ref{ml-semantics}, with the additional inductive case:
$$
\begin{array}{lcl}
\kPModel{\kStateS} \entails \announceA{\phi} \psi & \text{ iff } & \kPModel{\kStateS} \entails \phi \text{ implies } \restrict{\kPModel{\kStateS}}{\phi} \entails \psi
\end{array}
$$
\end{definition}

\begin{definition}[Axiomatisation \axiomPalS{}]
The axiomatisation \axiomPalS{} is a substitution schema consisting of the axioms and rules of \axiomS{} along with the following additional axioms and rules:
$$
\begin{array}{rl}
    {\bf AP} & \proves \announceA{\phi} \atomP \iff (\phi \implies \atomP)\\
    {\bf AN} & \proves \announceA{\phi} \lnot \psi \iff (\phi \implies \lnot \announceA{\phi} \psi)\\
    {\bf AC} & \proves \announceA{\phi} (\psi \land \chi) \iff (\announceA{\phi} \psi \land \announceA{\phi} \chi)\\
    {\bf AK} & \proves \announceA{\phi} \necessaryA \psi \iff (\phi \implies \necessaryA \announceA{\phi} \psi)\\
    {\bf AA} & \proves \announceA{\phi} \announceA{\psi} \chi \iff \announceA{\phi \land \announceA{\phi} \psi} \chi\\
    {\bf NecA} & \text{From } \proves \phi \text{ infer } \proves \announceA{\psi} \phi
\end{array}
$$
\end{definition}

\begin{proposition}
The axiomatisation \axiomPalS{} is sound and strongly complete with respect to the semantics of the logic \logicPalS{}.
\end{proposition}

\begin{proposition}
The logic \logicPalS{} is expressively equivalent to the logic \logicS{}.
\end{proposition}

\begin{proposition}
The logic \logicPalS{} is compact.
\end{proposition}

\begin{proposition}
The satisfiability problem for the logic \logicPalS{} is decidable.
\end{proposition}

\section{Arbitrary public announcement logic}\label{apal}

We recall definitions and results from the public announcement logic of Balbiani, et al~\cite{balbianietal:2008}.

\begin{definition}[Language of arbitrary public announcement logic]
The {\em language of arbitrary public announcement logic}, \langApal{}, is inductively defined as:
$$
\phi ::= 
    \atomP \mid
    \lnot \phi \mid
    (\phi \land \phi) \mid
    \necessaryA \phi \mid
    \announceA{\phi} \phi \mid
    \allpas \phi
$$
where $\atomP \in \atoms$ and $\agentA \in \agents$.
\end{definition}

We use all of the standard abbreviations from public announcement logic, in addition to the abbreviation $\somepas \phi ::= \lnot \allpas \lnot \phi$.

The formula $\allpas \phi$ may be read as ``after any public announcement $\phi$ is true''.
The formula $\somepas \phi$ may be read as ``after some public announcement $\phi$ is true''.

\begin{definition}[Semantics of arbitrary public announcement logic]
Let $\phi \in \langApal$ and let $\kPModelAndTuple{\kStateS} \in \classS$ be a pointed Kripke model.
The interpretation of the formula $\phi$ in the logic \logicApalS{} on the pointed Kripke model $\kPModel{\kStateS}$ is the same as its interpretation in public announcement logic, defined in Definition~\ref{pal-semantics}, with the additional inductive case:
$$
\begin{array}{lcl}
    \kPModel{\kStateS} \entails \allpas \psi & \text{ iff } & \text{for every } \psi \in \langMl : \kPModel{\kStateS} \entails \announceA{\psi} \phi
\end{array}
$$
\end{definition}

\begin{definition}[Necessity and possibility forms]
Consider a new symbol $\sharp$. The {\em necessity forms} are defined inductively as:
$$\psi(\sharp) ::= \sharp \mid (\phi \implies \psi(\sharp)) \mid \announceA{\phi} \psi(\sharp) \mid \knows[\agentA] \psi(\sharp)$$
where $\phi \in \langPapal$ and $\agentA \in \agents$.

The {\em possibility forms} are defined inductively as:
$$\psi(\sharp) ::= \sharp \mid (\phi \land \psi(\sharp)) \mid \announceE{\phi} \psi(\sharp) \mid \suspects[\agentA] \psi(\sharp)$$
where $\phi \in \langPapal$ and $\agentA \in \agents$.
\end{definition}

A possibility form is the dual of a necessity form.
Necessity and possibility forms contain a unique occurrence of the symbol $\sharp$.
If $\psi(\sharp)$ is a necessity or possibility form and $\phi \in \langApal$ then $\psi(\phi) ::= \psi(\sharp)[\phi/\sharp]$, where $\psi(\sharp)[\phi/\sharp]$ is $\psi(\sharp)$ with the symbol $\sharp$ replaced with the formula $\phi$, and $\psi(\phi) \in \langApal$.

\begin{definition}[Axiomatisation \axiomApalS{}]
The axiomatisation \axiomApalS{} is a substitution schema consisting of the axioms and rules of \axiomPalS{} along with the following additional axioms and rules:
$$
\begin{array}{rl}
    {\bf A+} & \proves \allpas \phi \implies \announceA{\psi} \phi \text{ where } \psi  \in \langMl\\
    {\bf R+^\omega} & \text{From } \proves \nu(\announceA{\psi} \phi) \text{ for every } \psi \in \langMl \text{ infer } \nu(\allpas \phi)
\end{array}
$$
where $\nu(\sharp)$ is a necessity form.
\end{definition}

\begin{proposition}
The axiomatisation \axiomApalS{} is sound and strongly complete with respect to the semantics of the logic \logicApalS{}.
\end{proposition}

We note that the axiomatisation \axiomApalS{} is an infinitary axiomatisation, as the rule ${\bf R+^\omega}$ requires an infinite number of premises.
As a consequence the axiomatisation is not recursively enumerable.
The rule ${\bf R+^\omega}$ can be replaced with a finitary rule of the form:
$$
\begin{array}{rl}
    {\bf R+^1} & \text{From } \proves \nu(\announceA{\atomP} \phi) \text{ infer } \nu(\allpas \phi)
\end{array}
$$
where $\nu(\sharp)$ is a necessity form and $\atomP$ is a fresh atom.

\begin{proposition}
The axiomatisation \axiomApalS{} substituting the rule ${\bf R+^\omega}$ with the rule ${\bf R+^1}$ is sound and {\em weakly} complete with respect to the semantics of the logic \logicApalS{}.
\end{proposition}

\begin{proposition}
The logic \logicApalS{} is strictly more expressive than the logic \logicPalS{}.
\end{proposition}

\begin{proposition}
The logic \logicApalS{} is not compact.
\end{proposition}

\section{Action model logic}\label{aml}

We recall definitions and results from the action model logic of Baltag, Moss and Solecki~\cite{baltagetal:1998,baltagetal:2004}.

\begin{definition}[Action models]
Let \lang{} be a logical language.
An {\em action model with preconditions defined on \lang{}}, $\aModelAndTuple$ consists of an underlying Kripke frame $\aFrameAndTuple$ along with a {\em precondition function} $\aPrecondition : \aStates \to \lang$, which is a function from actions to formulas.

A {\em pointed action model} $\aPModelAndTuple{\aStateS}$ consists of an action model $\aModelAndTuple$ along with a designated action $\aStateS \in \aStates$.
A {\em multi-pointed action model} $\aPModelAndTuple{\aStatesT}$ consists of an action model $\aModelAndTuple$ along with a non-empty set of designated action $\aStatesT \subseteq \aStates$.
\end{definition}

We use similar notation and terminology to Kripke models when discussing action models.
Similar to Kripke models, when we ascribe relational properties or frame properties to an action model we actually ascribe those properties to its underlying Kripke frame.
When the language that an action model is defined on is clear from context we will simply refer to an {\em action model}, without explicit reference to the language.

\begin{definition}[Action signature]
An {\em action signature}, $\aSignatureAndTuple$ consists of an underlying Kripke frame $\aFrameAndTuple$ along with a non-repeating list of {\em non-trivial actions}, $\aStateS_1, \dots, \aStateS_n \in \aStates$.
Let $\lang$ be a logical language and let $\phi_1, \dots, \phi_n \in \lang$ be a list of formulas.
Then we obtain an action model $\aSignature(\phi_1, \dots, \phi_n) = \aModelTuple$ where $\aPrecondition(\aStateS_i) = \phi_i$ for $i = 1, \dots, n$ and $\aPrecondition(\aStateS) = \top$ otherwise.
The {\em trivial actions} are so named because their preconditions are always set to $\top$.
\end{definition}

When we ascribe relational or frame properties to an action model or signature we actually ascribe those properties to its underlying Kripke frame.
As we will often work with action models and signatures rather than Kripke frames we overload the notation for classes of Kripke frames to also refer to classes of action models or signatures.

\begin{definition}[Language of action model logic]
Let \aSignatureFamily{} be a non-empty, countable set of action signatures.
The {\em language of action model logic} with action signatures \aSignatureFamily{}, $\langAml(\aSignatureFamily)$, is inductively defined as:
$$
\phi ::=
    \atomP \mid
    \lnot \phi \mid
    (\phi \land \phi) \mid
    \necessaryA \phi \mid
    \actionA{\aSignature \aStatesT, \phi, \dots, \phi} \phi\\
$$
where $\atomP \in \atoms$, $\agentA \in \agents$, $\aSignatureAndTuple \in \aSignatureFamily$, $\aStatesT \subseteq \aStates$, and the number of parameters to a given action signature $\aSignature$ is determined by the number of designated actions in the action signature.
\end{definition}

We use all of the standard abbreviations from modal logic, in addition to the abbreviations 
$\actionA{\aPModel{\aStatesT}} \phi ::= \actionA{\aSignature \aStatesT, \phi_1, \dots, \phi_n} \phi$ where $\aModel = \aSignature(\phi_1, \dots, \phi_n)$ and 
$\actionE{\aPModel{\aStatesT}} \phi ::= \lnot \actionA{\aPModel{\aStatesT}} \lnot \phi$.

\begin{definition}[Semantics of action model logic]
Let \classC{} be a class of Kripke models and let \aSignatureFamily{} be a non-empty, countable set of action signatures.
We define the semantics of action model logic and the notion of action model execution simultaneously.

Let $\kModelAndTuple \in \classC$ be a Kripke model and $\aModelAndTuple \in \classK$ be an action model with preconditions defined on $\langAml(\aSignatureFamily)$.
We denote the result of executing the action model $\aModel$ on the Kripke model $\kModel$ as $\kModel \exec \aModel$ and define it as $\kModel \exec \aModel = \kModelTupleP$ where:
\begin{eqnarray*}
    \kStatesP &=& \{(\kStateS, \aStateS) \in \kStates \times \aStates \mid \kPModel{\kStateS} \entails \aPrecondition(\aStateS)\}\\
    (\kStateS, \aStateS) \kAccessibilityPA (\kStateT, \aStateT) &\text{ iff }& \kStateS \kAccessibilityA \kStateT \text{ and } \aStateS \aAccessibilityA \aStateT\\
    \kValuationP(\atomP) &=& \{(\kStateS, \aStateS) \in \kStatesP \mid \kStateS \in \kValuation(\atomP)\}
\end{eqnarray*}
We denote the result of executing the pointed action model $\aPModel{\aStateS}$ on the pointed Kripke model $\kPModel{\kStateS}$ as $\kPModel{\kStateS} \exec \aPModel{\aStateS}$ and define it as $\kPModel{\kStateS} \exec \aPModel{\aStateS} = (\kModel \exec \aModel, (\kStateS, \aStateS))$. Note that $\kPModel{\kStateS} \exec \aPModel{\aStateS}$ is undefined if $\kPModel{\kStateS} \nentails \aPrecondition(\aStateS)$ as then $(\kStateS, \aStateS) \notin \kStatesP$.

Let $\phi \in \langAml(\aSignatureFamily)$ and let $\kPModelAndTuple{\kStateS} \in \classC$ be a pointed Kripke model.
The interpretation of the formula $\phi$ in the logic \logicAmlC{} on the pointed Kripke model $\kPModel{\kStateS}$ is the same as its interpretation in modal logic, defined in Definition~\ref{ml-semantics}, with the additional inductive cases:
$$
\begin{array}{lcl}
    \kPModel{\kStateS} \entails \actionA{\aPModel{\aStateS}} \phi & \text { iff } & \kPModel{\kStateS} \entails \aPrecondition(\aStateS) \text{ implies } \kPModel{\kStateS} \exec \aPModel{\aStateS} \entails \phi\\
    \kPModel{\kStateS} \entails \actionA{\aPModel{\aStatesT}} \phi & \text { iff } & \text{for every } \aStateS \in \aStatesT: \kPModel{\kStateS} \entails \actionA{\aPModel{\aStateS}}
\end{array}
$$
\end{definition}

We are interested in the following variants of action model:
\begin{itemize}
    \item \logicAmlK{} interpreted over the class of \classK{} Kripke frames and the language of action model logic $\langAml(\classK)$ with action signatures defined on the class of finite \classK{} Kripke frames.
    \item \logicAmlKFF{} interpreted over the class of \classKFF{} Kripke frames and the language of action model logic $\langAml(\classKFF)$ with action signatures defined on the class of finite \classKFF{} Kripke frames.
    \item \logicAmlS{} interpreted over the class of \classS{} Kripke frames and the language of action model logic $\langAml(\classS)$ with action signatures defined on the class of finite \classS{} Kripke frames.
\end{itemize}

\begin{definition}[Skip and crash]
    We define the action models \aSkip{} and \aCrash{} as follows:
    \begin{eqnarray*}
        \aSkip &=& ((\{\aStateS\}, \{(\aStateS, \aStateS)\}, \{(\aStateS, \top)\}), \aStateS)\\
        \aCrash &=& ((\{\aStateS\}, \{(\aStateS, \aStateS)\}, \{(\aStateS, \bot)\}), \aStateS)
    \end{eqnarray*}
\end{definition}

The action model \aSkip{} is intended to represent an epistemic update that always succeeds and has no effect,
whereas the action model \aCrash{} is intended to represent an epistemic update that never succeeds.
Indeed we note that $\entails \actionE{\aSkip} \top$, $\entails \actionA{\aSkip} \phi \iff \phi$ and $\entails \lnot \actionE{\aCrash} \top$.

We note that as $\top$ and $\bot$ are in the language $\langAml(\aSignatureFamily)$ for any set of action signatures $\aSignatureFamily$, and so \aSkip{} and \aCrash{} are action models with preconditions defined on $\langAml(\aSignatureFamily)$.
However a given $\aSignatureFamily$ may not contain any action signature that would allow one to construct \aSkip{} or \aCrash{}, so statements about \aSkip{} and \aCrash{} may not be allowed by the language $\langAml(\aSignatureFamily)$.

\begin{definition}[Disjoint union]
    Let $\aPModelAndTuple{\aStatesT}$ and $\aPModelAndTupleP{\aStatesTP}$ be action models.
    We denote the {\em disjoint union of $\aPModel{\aStatesT}$ and $\aPModelP{\aStatesTP}$} as $\aPModel{\aStatesT} \choice \aPModelP{\aStatesTP}$ and define it as $\aPModel{\aStatesT} \choice \aPModelP{\aStatesTP} = \aPModelAndTuplePP{\aStatesTPP}$ where:
    \begin{eqnarray*}
        \aStatesPP &=& \aStates \cup \aStatesP\\
        \aAccessibilityPPA &=& \aAccessibilityA \cup \aAccessibilityPA\\
        \aPreconditionPP &=& \aPrecondition \cup \aPreconditionP\\
        \aStatesTPP &=& \aStatesT \cup \aStatesTP
    \end{eqnarray*}
\end{definition}

The operation of disjoint union of action models is intended to represent the epistemic update that is formed by the non-deterministic choice between two epistemic updates.
Indeed we note that $\entails \actionA{\aPModel{\aStatesT} \choice \aPModelP{\aStatesTP}} \phi \iff (\actionA{\aPModel{\aStatesT}} \phi \land \actionA{\aPModelP{\aStatesTP}} \phi)$.

We will sometimes take the `disjoint' union of two action models that are not actually disjoint and we assume in this case that we implicitly rename the actions in each action model so that the domains become disjoint before taking the disjoint union.

\begin{definition}[Sequential composition]
    Let $\aPModelAndTuple{\aStatesT}$ and $\aPModelAndTupleP{\aStatesTP}$ be action models.
    We denote the {\em sequential composition of $\aPModel{\aStatesT}$ and $\aPModelP{\aStatesTP}$} as $\aPModel{\aStatesT} \compose \aPModelP{\aStatesTP}$ and define it as $\aPModel{\aStatesT} \compose \aPModelP{\aStatesTP} = \aPModelAndTuplePP{\aStatesTPP}$ where:
    \begin{eqnarray*}
        \aStatesPP &=& \aStates \times \aStatesP\\
        (\aStateS, \aStateSP) \aAccessibilityPPA (\aStateT, \aStateTP) &\text{ iff }& \aStateS \aAccessibilityA \aStateT \text{ and } \aStateSP \aAccessibilityPA \aStateTP\\
        \aPreconditionPP((\aStateS, \aStateSP)) &=& \aPrecondition(\aStateS) \land \actionA{\aPModel{\aStateS}} \aPreconditionP(\aStateSP)\\
        \aStatesTPP &=& \aStatesT \times \aStatesTP
    \end{eqnarray*}
\end{definition}

The operation of sequential composition of action models is intended to represent the epistemic update that is formed by sequentially performing two epistemic updates.
Indeed we note that $\entails \actionA{\aPModel{\aStatesT} \compose \aPModelP{\aStatesTP}} \phi \iff \actionA{\aPModel{\aStatesT}} \actionA{\aPModelP{\aStatesTP}} \phi$.

Using the \aSkip{} and \aCrash{} action models, along with the operations of disjoint union and sequential composition we may define an extended language of action model logic.

\begin{definition}[Language of action model logic (extended)]
Let \aSignatureFamily{} be a non-empty, countable set of action signatures.
The {\em language of action model logic} with action signatures \aSignatureFamily{}, $\langAml(\aSignatureFamily)$, is inductively defined as:
$$
\phi ::=
    \atomP \mid
    \lnot \phi \mid
    (\phi \land \phi) \mid
    \necessaryA \phi \mid
    \actionA{\alpha} \phi
$$
where $\atomP \in \atoms$, $\agentA \in \agents$, and the {\em language of action model logic actions} with action signatures \aSignatureFamily{}, $\langAmlAct(\aSignatureFamily)$, is inductively defined as:
$$
\alpha ::=
    \aSkip \mid
    \aCrash \mid
    \aSignature \aStatesT, \phi, \dots, \phi \mid
    \alpha \choice \alpha \mid
    \alpha \compose \alpha
$$
where , $\aSignatureAndTuple \in \aSignatureFamily$, $\aStatesT \subseteq \aStates$, and the number of parameters to a given action signature $\aSignature$ is determined by the number of designated actions in the action signature.
\end{definition}

We use all of the standard abbreviations from action model logic.
The semantics of formulas of this extended language should be obvious.
We note that formulas of the extended language can be translated back into the basic language using the equivalences listed above.

We note the following algebraic properties of action model logic actions:

\begin{proposition}
Let $\alpha, \beta, \gamma \in \langAmlAct$ and let $\phi \in \langAml$. Then:
$$
\begin{array}{l}
    \entails \actionA{\alpha \choice \aCrash} \phi \iff \actionA{\alpha} \phi\\
    \entails \actionA{\alpha \choice \beta} \phi \iff \actionA{\beta \choice \alpha} \phi\\
    \entails \actionA{(\alpha \choice \beta) \choice \gamma} \phi \iff \actionA{\alpha \choice (\beta \choice \gamma)} \phi\\
    \entails \actionA{\alpha \compose \aSkip} \phi \iff \actionA{\alpha} \phi\\
    \entails \actionA{\aSkip \compose \alpha} \phi \iff \actionA{\alpha} \phi\\
    \entails \actionA{(\alpha \compose \beta) \compose \gamma} \phi \iff \actionA{\alpha \compose (\beta \compose \gamma)} \phi\\
    \entails \actionA{(\alpha \choice \beta) \compose \gamma} \phi \iff \actionA{(\alpha \compose \gamma) \choice (\beta \compose \gamma)} \phi
\end{array}
$$
\end{proposition}

Similar to Kripke models there is a notion of bisimilarity of action models.

\begin{definition}[Bisimulation of action models]
Let $\aModelAndTuple$ and $\aModelAndTupleP$ be action models.
A non-empty relation $\bisimulation \subseteq \aStates \times \aStatesP$ is a {\em bisimulation} if and only if for every $\agentA \in \agents$ and $(\aStateS, \aStateSP) \in \bisimulation$ the following conditions, {\bf preconditions}, {\bf forth-$\agentA$} and {\bf back-$\agentB$} holds:

\paragraph{preconditions}
$\entails \aPrecondition(\aStateS) \iff \aPrecondition(\aStateSP)$.

\paragraph{forth-$\agentA$}
For every $\aStateT \in \aSuccessorsA{\aStateS}$ there exists $\aStateTP \in \aSuccessorsPA{\aStateSP}$ such that $\aStateS \bisimulation \aStateT$.

\paragraph{back-$\agentA$}
For every $\aStateTP \in \aSuccessorsPA{\aStateSP}$ there exists $\aStateT \in \aSuccessorsA{\aStateS}$ such that $\aStateS \bisimulation \aStateT$.

If there exists a bisimulation $\bisimulation$ such that $\aStateS \bisimulation \aStateSP$ then we say that $\aPModel{\aStateS}$ and $\aPModelP{\aStateSP}$ are {\em bisimilar} and we denote this by $\aPModel{\aStateS} \bisimilar \aPModelP{\aStateSP}$.
\end{definition}

\begin{proposition}
The relation $\bisimilar$ is an equivalence relation on action models.
\end{proposition}

Bisimilar action models have bisimilar results on bisimilar Kripke models.

\begin{proposition}\label{action-bisimulation-results}
Let $\kPModel{\kStateS}, \kPModelP{\kStateSP}$ be pointed Kripke models such that $\kPModel{\kStateS} \bisimilar \kPModelP{\kStateSP}$ and
let $\aPModel{\aStateS}, \aPModelP{\aStateSP}$ be pointed action models such that $\aPModel{\aStateS} \bisimilar \aPModelP{\aStateSP}$.
Then $\kPModel{\kStateS} \exec \aPModel{\aStateS} \bisimilar \kPModelP{\kStateSP} \exec \aPModelP{\aStateSP}$.
\end{proposition}

In particular, due to Proposition~\ref{modal-bisimulation-invariance} and Proposition~\ref{action-bisimulation-results} we have:

\begin{proposition}
Let $\kPModel{\kStateS}, \kPModelP{\kStateSP}$ be pointed Kripke models such that $\kPModel{\kStateS} \bisimilar \kPModelP{\kStateSP}$ and
let $\aPModel{\aStateS}$ be a pointed action model.
Then for every $\phi \in \langAml$: $\kPModel{\kStateS} \entails \phi$ if and only if $\kPModelP{\kStateSP} \entails \phi$.
\end{proposition}

\begin{proposition}
Let $\kPModel{\kStateS}$ be a pointed Kripke model and
let $\aPModel{\aStateS}, \aPModelP{\aStateSP}$ be pointed action models such that $\aPModel{\aStateS} \bisimilar \aPModelP{\aStateSP}$.
Then for every $\phi \in \langAml$: $\kPModel{\kStateS} \entails \actionA{\aPModel{\aStateS}} \phi$ if and only if $\kPModel{\kStateS} \entails \actionA{\aPModelP{\aStateSP}} \phi$.
\end{proposition}

We also have a notion of depth-limited bisimilarity of action models.

\begin{definition}[$n$-bisimulation]
Let $\aModelAndTuple$ and $\aModelAndTupleP$ be Kripke models and let $n \in \naturals$.
A list of non-empty relations $\bisimulation_0, \dots, \bisimulation_n$, where for $i = 0, \dots, n$ $\bisimulation_i \subseteq \aStates \times \aStatesP$, is an {\em $n$-bisimulation} if and only if for every $i = 0, \dots, n$, $\atomP \in \atoms$, $\agentA \in \agents$ and $(\aStateS, \aStateSP) \in \bisimulation_i$ the following conditions, {\bf atoms-$i$-$\atomP$}, {\bf forth-$i$-$\agentA$} and {\bf back-$i$-$\agentB$} holds:

\paragraph{preconditions-$i$}
If $i = 0$ then $\entails \aPrecondition(\aStateS) \iff \aPreconditionP(\aStateSP)$.
If $i > 0$ then $\aPModel{\aStateS} \bisimulation_{i-1} \aPModelP{\aStateSP}$.

\paragraph{forth-$i$-$\agentA$}
For every $\aStateT \in \aSuccessorsA{\aStateS}$ there exists $\aStateTP \in \aSuccessorsPA{\aStateSP}$ such that $\aStateS \bisimulation_i \aStateT$.

\paragraph{back-$i$-$\agentA$}
For every $\aStateTP \in \aSuccessorsPA{\aStateSP}$ there exists $\aStateT \in \aSuccessorsA{\aStateS}$ such that $\aStateS \bisimulation_i \aStateT$.

If there exists an $n$-bisimulation $\bisimulation_0, \dots, \bisimulation_n$ such that $\aStateS \bisimulation_n \aStateSP$ then we say that $\aPModel{\aStateS}$ and $\aPModelP{\aStateSP}$ are {\em $n$-bisimilar} and we denote this by $\aPModel{\aStateS} \bisimilar[n] \aPModelP{\aStateSP}$.
\end{definition}

\begin{definition}[Modal depth]
Let $\phi \in \langAml$.
We denote the {\em modal depth of $\phi$} by $d(\phi)$ and define it inductively as:
\begin{eqnarray*}
    d(\atomP) &=& 0\\
    d(\lnot \phi) &=& d(\phi)\\
    d(\phi \land \psi) &=& max(d(\phi), d(\psi))\\
    d(\necessaryA \phi) &=& d(\phi) + 1\\
    d(\actionA{\aPModel{\aStateS}} \phi) &=& d(\phi)
\end{eqnarray*}
\end{definition}

\begin{proposition}
Let $n \in \naturals$,
let $\kPModel{\kStateS}, \kPModelP{\kStateSP}$ be pointed Kripke models such that $\kPModel{\kStateS} \bisimilar[n] \kPModelP{\kStateSP}$ and
let $\aPModel{\aStateS}, \aPModelP{\aStateSP}$ be pointed action models such that $\aPModel{\aStateS} \bisimilar[n] \aPModelP{\aStateSP}$.
Then $\kPModel{\kStateS} \exec \aPModel{\aStateS} \bisimilar[n] \kPModelP{\kStateSP} \exec \aPModelP{\aStateSP}$.
\end{proposition}

\begin{proposition}
Let $n \in \naturals$,
let $\kPModel{\kStateS}, \kPModelP{\kStateSP}$ be pointed Kripke models such that $\kPModel{\kStateS} \bisimilar[n] \kPModelP{\kStateSP}$ and
let $\aPModel{\aStateS}$ be a pointed action model.
Then for every $\phi \in \langAml$ such that $d(\phi) \leq n$: $\kPModel{\kStateS} \entails \phi$ if and only if $\kPModelP{\kStateSP} \entails \phi$.
\end{proposition}

\begin{proposition}
Let $n \in \naturals$,
let $\kPModel{\kStateS}$ be a pointed Kripke model and
let $\aPModel{\aStateS}, \aPModelP{\aStateSP}$ be pointed action models such that $\aPModel{\aStateS} \bisimilar[n] \aPModelP{\aStateSP}$.
Then for every $\phi \in \langAml$ such that $d(\phi) \leq n$: $\kPModel{\kStateS} \entails \actionA{\aPModel{\aStateS}} \phi$ if and only if $\kPModel{\kStateS} \entails \actionA{\aPModelP{\aStateSP}} \phi$.
\end{proposition}

\begin{definition}[Axiomatisations \axiomAmlK{}, \axiomAmlKFF{}, and \axiomAmlS{}]
The axiomatisations \axiomAmlK{}, \axiomAmlKFF{}, and \axiomAmlS{} are substitution schemas consisting of the respective axioms and rules of \axiomK{}, \axiomKFF{}, and \axiomS{} along with the following additional axioms and rules:
$$
\begin{array}{rl}
    {\bf AP} & \proves \actionA{\aPModel{\aStateS}} \atomP \iff (\aPrecondition(\aStateS) \implies \atomP)\\
    {\bf AN} & \proves \actionA{\aPModel{\aStateS}} \lnot \phi \iff (\aPrecondition(\aStateS) \implies \lnot \actionA{\aPModel{\aStateS}} \phi)\\
    {\bf AC} & \proves \actionA{\aPModel{\aStateS}} (\phi \land \psi) \iff (\actionA{\aPModel{\aStateS}} \phi \land \actionA{\aPModel{\aStateS}} \psi)\\
    {\bf AK} & \proves \actionA{\aPModel{\aStateS}} \necessaryA \phi \iff (\aPrecondition(\aStateS) \implies \necessaryA \bigwedge_{\aStateT \in \aSuccessorsA{\aStateS}} \actionA{\aPModel{\aStateT}} \phi)\\
    {\bf AU} & \proves \actionA{\aPModel{\aStatesT}} \phi \iff \bigwedge_{\aStateT \in \aStatesT} \actionA{\aPModel{\aStateT}} \phi\\
    {\bf NecA} & \text{From } \proves \phi \text{ infer } \proves \actionA{\aPModel{\aStatesT}} \phi
\end{array}
$$
\end{definition}

\begin{proposition}
The axiomatisations \axiomAmlK{}, \axiomAmlKFF{}, and \axiomAmlS{} are sound and strongly complete with respect to the semantics of the respective logics \logicAmlK{}, \logicAmlKFF{}, and \logicAmlS{}.
\end{proposition}

\begin{proposition}
The logics \logicAmlK{}, \logicAmlKFF{}, and \logicAmlS{} are expressively equivalent to the respective logics \logicK{}, \logicKFF{}, and \logicS{}.
\end{proposition}

\begin{proposition}
The logics \logicAmlK{}, \logicAmlKFF{}, and \logicAmlS{} are compact.
\end{proposition}

\begin{proposition}
The satisfiability problems for the logics \logicAmlK{}, \logicAmlKFF{}, and \logicAmlS{} are decidable.
\end{proposition}

\section{Modal $\mu$-calculus}\label{mu}

Let $\variables$ be a non-empty, countable set of variables.

\begin{definition}[Language of modal $\mu$-calculus]
The {\em language of modal $\mu$-calculus}, \langMu{}, is inductively defined as:
$$
\phi ::= 
    \atomP \mid
    \varX \mid
    \lnot \phi \mid
    (\phi \land \phi) \mid
    \necessaryA \phi \mid
    \lfpX \phi
$$
where $\atomP \in \atoms$, $\agentA \in \agents$ and $\varX \in \variables$, and in $\lfpX \phi$ every free occurrence of $\varX$ in $\phi$ occurs positively (i.e. within the scope of an even number of negations).
\end{definition}

We use all of the standard abbreviations from modal logic, in addition to the abbreviation $\gfpX \phi ::= \lnot \lfpX \lnot \phi$.

\begin{definition}[Semantics of modal $\mu$-calculus]\label{mu-semantics}
Let $\classC$ be a class of Kripke frames, let $\phi \in \langMu$, let $\kPModelAndTuple{\kStateS} \in \classC$ be a pointed Kripke model and let $\kAssignment : \varX \to \powerset(\kStates)$ be a function from variables to sets of states.
The set of states $\interpretation[\kAssignment]{\phi} \subseteq \kStates$ where $\phi$ is satisfied with respect to an assignment $\kAssignment$ is defined inductively as follows:
\begin{eqnarray*}
    \interpretation[\kAssignment]{\atomP} &=& \kValuation(\atomP)\\
    \interpretation[\kAssignment]{\varX} &=& \kAssignment(\varX)\\
    \interpretation[\kAssignment]{\phi \land \psi} &=& \interpretation[\kAssignment]{\phi} \cap \interpretation[\kAssignment]{\psi}\\
    \interpretation[\kAssignment]{\necessaryA \phi} &=& \{ \kStateS \in \kStates \mid \kStateS \kAccessibility{\agentA} \subseteq \interpretation[\kAssignment]{\phi} \}\\
    \interpretation[\kAssignment]{\lfp{\varX} \phi} &=& \bigcap \{ \kStatesT \subseteq \kStates \mid \interpretation[\kAssignmentSubstitute{\kStatesT}{\varX}]{\phi} \subseteq \kStatesT \}
\end{eqnarray*}
where $\kAssignmentSubstitute{\kStatesT}{\varX}$ is the assignment such that $\kAssignmentSubstitute{\kStatesT}{\varX}(\varX) = \kStatesT$ and $\kAssignmentSubstitute{\kStatesT}{\varX}(\varY) = \kAssignment(\varY)$ for $\varY \neq \varX$. 
\end{definition}

\begin{proposition}
The logics \logicMuK{}, \logicMuKF{}, \logicMuKFF{}, \logicMuKD{}, \logicMuSF{} and \logicMuS{} are strictly more expressive than the respective logics \logicK{}, \logicKF{}, \logicKFF{}, \logicKD{}, \logicSF{} and \logicS{}.
\end{proposition}
