\section{\classK{}}\label{aaml-k}

In this section we consider in greater detail the logic \logicAamlK{} in the setting of \classK{}.
The main result of this section is that the action model quantifiers of \logicAamlK{} are equivalent to the refinement quantifiers of \logicRmlK{}.
We show this equivalence by showing that if there exists a refinement where a given formula is satisfied then we can construct a finite action model that results in that formula being satisfied.

We rely heavily on results from the action model logic \logicAmlK{} and the refinement modal logic \logicRmlK{}, particularly the axiomatisations from both.
In the previous section we defined the refinement action model logic, \logicRamlK{}, that extends action model logic with refinement quantifiers, so that we can use results from \logicAmlK{} and \logicRmlK{} with a combined syntax, semantics and proof theory.

We first note that as the syntax and semantics of \logicRamlK{} are formed by combining the semantics of \logicAmlK{} and \logicRmlK{}, then \logicAmlK{} and \logicRmlK{} agree with \logicRamlK{} on formulas from their respective sublanguages.

\begin{lemma}\label{raml-k-aml}
The logics \logicRamlK{} and \logicAmlK{} agree on all formulas of \langAml{}.
That is, for every $\phi \in \langAml$, $\kPModel{\kStateS} \in \classK$: $\kPModel{\kStateS} \entails_\logicRamlK \phi$ if and only if $\kPModel{\kStateS} \entails_\logicAmlK \phi$.
\end{lemma}

\begin{lemma}\label{raml-k-rml}
The logics \logicRamlK{} and \logicRmlK{} agree on all formulas of \langRml{}.
That is, for every $\phi \in \langRml$, $\kPModel{\kStateS} \in \classK$: $\kPModel{\kStateS} \entails_\logicRamlK \phi$ if and only if $\kPModel{\kStateS} \entails_\logicRmlK \phi$.
\end{lemma}

These results follow directly from the definitions.

Given these results we can give a sound and complete axiomatisation for \logicRamlK{} by combining the axiomatisations for \logicAmlK{} and \logicRmlK{}.

\begin{definition}[Axiomatisation \axiomRamlK{}]\label{raml-k-axiomatisation}
The axiomatisation \axiomRamlK{} is a substitution schema consisting of the axioms and rules of \axiomAmlK{} and the axioms and rules of \axiomRmlK{}:
$$
\begin{array}{rl}
    {\bf P}     & \text{All propositional tautologies}\\
    {\bf K}     & \proves \necessaryA (\phi \implies \psi) \implies (\necessaryA \phi \implies \necessaryA \psi)\\
    {\bf AP} & \proves \actionA{\aPModel{\aStateS}} \atomP \iff (\aPrecondition(\aStateS) \implies \atomP)\\
    {\bf AN} & \proves \actionA{\aPModel{\aStateS}} \lnot \phi \iff (\aPrecondition(\aStateS) \implies \lnot \actionA{\aPModel{\aStateS}} \phi)\\
    {\bf AC} & \proves \actionA{\aPModel{\aStateS}} (\phi \land \psi) \iff (\actionA{\aPModel{\aStateS}} \phi \land \actionA{\aPModel{\aStateS}} \psi)\\
    {\bf AK} & \proves \actionA{\aPModel{\aStateS}} \necessaryA \phi \iff (\aPrecondition(\aStateS) \implies \necessaryA \bigwedge_{\aStateT \in \aSuccessorsA{\aStateS}} \actionA{\aPModel{\aStateT}} \phi)\\
    {\bf AU} & \proves \actionA{\aPModel{\aStatesT}} \phi \iff \bigwedge_{\aStateT \in \aStatesT} \actionA{\aPModel{\aStateT}} \phi\\
    {\bf R} & \proves \allrefsBs (\phi \implies \psi) \implies (\allrefsBs \phi \implies \allrefsBs \psi)\\
    {\bf RP} & \proves \allrefsBs \pi \iff \pi\\
    {\bf RK} & \proves \somerefsBs \coversA \Gamma_\agentA \iff \bigwedge_{\gamma \in \Gamma_\agentA} \possibleA \somerefsBs \gamma \text{ where } \agentA \in \agentsB\\
    {\bf RComm} & \proves \somerefsBs \coversA \Gamma_\agentA \iff \coversA \{\somerefsBs \gamma \mid \gamma \in \Gamma_\agentA\} \text{ where } \agentA \notin \agentsB\\
    {\bf RDist} & \proves \somerefsBs \bigwedge_{\agentC \in \agentsC} \coversC \Gamma_\agentC \iff \bigwedge_{\agentC \in \agentsC} \somerefsBs \coversC \Gamma_\agentC\\
    {\bf MP}    & \text{From } \proves \phi \implies \psi \text{ and } \proves \phi \text{ infer } \proves \psi\\
    {\bf NecK}  & \text{From } \proves \phi \text{ infer } \proves \necessaryA \phi\\
    {\bf NecA} & \text{From } \proves \phi \text{ infer } \proves \actionA{\aPModel{\aStatesT}} \phi\\
    {\bf NecR} & \text{From } \proves \phi \text{ infer } \proves \allrefsBs \phi
\end{array}
$$
where $\phi, \psi \in \langAaml$, $\agentA \in \agents$, $\aPModel{\aStateS} \in \classAmK$, $\atomP \in \atoms$, $\pi \in \langPl$, $\agentsB, \agentsC \subseteq \agents$, and for every $\agentA \in \agents$: $\Gamma_\agentA \subseteq \langRml$ is a finite set of formulas.
\end{definition}

\begin{theorem}\label{raml-k-sound-complete}
The axiomatisation \axiomRamlK{} is sound and strongly complete with respect to the semantics of the logic \logicRamlK{}.
\end{theorem}

\begin{proof}[Proof]
Soundness of the axioms and rules of \axiomAmlK{} and \axiomRmlK{} follow from the same reasoning used to show that they are sound in \logicAmlK{} and \logicRmlK{} respectively.
Alternatively we can show that the axioms and rules of \axiomAmlK{} and \axiomRmlK{} are sound in \logicRamlK{} for formulas from the languages \langAml{} and \langRml{} respectively, as the logics \logicAmlK{} and \logicRmlK{} agree with \logicRamlK{} on all formulas of \langAml{} and \langRml{} respectively.
These restricted axioms are all that is required for the following completeness proof via provably correct translation to work.
After we have shown expressive equivalence between \logicRamlK{} and \logicK{} we can easily show soundness of versions of the axioms and rules of \axiomAmlK{} and \axiomRmlK{} that apply for formulas from the full language \langAaml{}. 

Strong completeness follows from essentially the same reasoning used to show the strong completeness of \axiomRmlK{} in Lemma~\ref{rml-k-sound-complete}, using a provably correct translation from \langAaml{} to \langMl{}.
As the action model logic \logicAmlK{} is expressively equivalent to the underlying modal logic \logicK{} using the reduction axioms of \axiomAmlK{} there is a provably correct translation from \langAml{} to \langMl{}.
Likewise, as the refinement model logic \logicRmlK{} is expressively equivalent to the underlying modal logic \logicK{} using the reduction axioms of \axiomRmlK{} there is a provably correct translation from \langRml{} to \langMl{}.
These provably correct translations can be combined into a provably correct translation from \langAaml{} to \langMl{}, by inductively applying the provably correct translation for \logicAmlK{} to subformulas containing action model operators but not refinement quantifiers, and applying the provably correct translation for \logicRmlK{} to subformulas containing refinement quantifiers but not action model operators.
\end{proof}

The provably correct translation also implies that \logicRamlK{} is expressively equivalent to \logicK{}.

\begin{corollary}\label{raml-k-expressive-equivalence}
The logic \logicRamlK{} is expressively equivalent to the logic \logicK{}.
\end{corollary}

From expressive equivalence we have that \logicRmlK{} is compact and decidable.

\begin{corollary}
The logic \logicRamlK{} is compact.
\end{corollary}

\begin{corollary}
The satisfiability problem for the logic \logicRamlK{} is decidable.
\end{corollary}

We note that most results from \logicAmlK{} and \logicRmlK{} generalise to \logicRamlK{} trivially thanks to a combination of \logicRamlK{} agreeing with \logicAmlK{} and \logicRmlK{} on their respective sublanguages, and the expressive equivalence of \logicRamlK{} and \logicK{}.
For example, in Chapter~\ref{rml} we showed that \logicRmlK{} has the Church-Rosser property; that is, $\entails_\logicRmlK \allrefsBs \somerefsBs \phi \implies \somerefsBs \allrefsBs \phi$ for every $\phi \in \langRml$.
By Lemma~\ref{raml-k-rml} we have $\entails_\logicRamlK \allrefsBs \somerefsBs \phi \implies \somerefsBs \allrefsBs \phi$ for every $\phi \in \langRml$.
By Corollary~\ref{raml-k-expressive-equivalence} every $\phi \in \langAaml$ has an equivalent $\phi' \in \langMl \subseteq \langRml$.
Therefore we have $\entails_\logicRamlK \allrefsBs \somerefsBs \phi \implies \somerefsBs \allrefsBs \phi$ for every $\phi \in \langAaml$.

We now move on to our main result, that the action model quantifiers of \logicAamlK{} are equivalent to the refinement quantifiers of \logicRmlK{}.
We show this equivalence by showing that if there exists a refinement where a given formula is satisfied then we can construct a finite action model that results in that formula being satisfied.
The converse we have already shown; if there exists an action model that results in a given formula being satisfied then by Proposition~\ref{action-models-refinements} the result of executing the action model is itself a refinement, so there exists a refinement where the formula is satisfied.

One way of stating our eventual result is as follows: for every $\phi \in \langAaml$, $\kPModel{\kStateS} \in \classK$ if there exists $\kPModelP{\kStateSP} \in \classK$ such that $\kPModel{\kStateS} \simulates \kPModelP{\kStateSP}$ and $\kPModelP{\kStateSP} \entails \phi$ then there exists $\aPModel{\aStateS} \in \classAmK$ such that $\kPModel{\kStateS} \entails \aPrecondition(\aStateS)$ and $\kPModel{\kStateS} \exec \aPModel{\aStateS} \entails \phi$. 
As we have our combined logic \logicRamlK{} for reasoning about refinements and action models, we can restate much of this using refinement action model logic syntax: for every $\phi \in \langAaml$, $\kPModel{\kStateS} \in \classK$ there exists $\aPModel{\aStateS} \in \classAmK$ such that $\kPModel{\kStateS} \entails \somerefs \phi \implies \actionE{\aPModel{\aStateS}} \phi$.
We actually show a stronger result.
This statement allows a different action model for each Kripke model in order to result in the given formula.
However we can show that there is a single action model that will result in the given formula, regardless of the Kripke model that we start with.
We show that: for every $\phi \in \langAaml$ there exists $\aPModel{\aStateS} \in \classAmK$ such that $\entails \actionA{\aPModel{\aStateS}} \phi$ and $\entails \actionE{\aPModel{\aStateS}} \phi \iff \somerefs \phi$.
This statement requires that there be a single action model that will result in the given formula for every Kripke model.
This allows us to use such action models in settings such as the proof theory where formulas are not interpreted with respect to just a single Kripke model.

We show our result using an inductive construction for a given formula.
Our construction is very similar to the constructions used to show the soundness of the axioms {\bf RK}, {\bf RComm}, and {\bf RDist} in \logicRmlK{}.
We reuse the disjunctive normal form we used for \logicRmlK{}, and we separate our inductive steps into two lemmas for each syntactic case from the disjunctive normal form.

We first show the case where the given formula is a disjunction.

\begin{lemma}\label{aaml-k-choice}
Let $\agentsB \subseteq \agents$, 
let $\phi = \alpha \lor \beta \in \langAaml$, and 
let $\aPModel[\alpha]{\aStatesT[\alpha]} \in \classAmK$ and $\aPModel[\beta]{\aStatesT[\beta]} \in \classAmK$ be action models such that 
$\entails \actionA{\aPModel[\alpha]{\aStatesT[\alpha]}} \alpha$, 
$\entails \actionE{\aPModel[\alpha]{\aStatesT[\alpha]}} \alpha \iff \someactsBs \alpha$, 
$\entails \actionA{\aPModel[\beta]{\aStatesT[\beta]}} \beta$,
$\entails \actionE{\aPModel[\beta]{\aStatesT[\beta]}} \beta \iff \someactsBs \beta$,
for every $\aStateT[\alpha] \in \aStatesT[\alpha]$, $\kPModel{\kStateS} \in \classK$ if $\kPModel{\kStateS} \entails \aPrecondition[\alpha](\aStateT[\alpha])$ then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel[\alpha]{\aStateT[\alpha]}$, and
for every $\aStateT[\beta] \in \aStatesT[\beta]$, $\kPModel{\kStateS} \in \classK$ if $\kPModel{\kStateS} \entails \aPrecondition[\beta](\aStateT[\beta])$ then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel[\beta]{\aStateT[\beta]}$.
Then there exists an action model $\aPModel{\aStatesT} \in \classAmK$ such that 
$\entails \actionA{\aPModel{\aStatesT}} \phi$,
$\entails \actionE{\aPModel{\aStatesT}} \phi \iff \someactsBs \phi$, and
for every $\aStateT \in \aStatesT$, $\kPModel{\kStateS} \in \classK$ if $\kPModel{\kStateS} \entails \aPrecondition(\aStateT)$ then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel{\aStateT}$.
\end{lemma}

\begin{proof}
Without loss of generality we assume that $\aModel[\alpha]$ and $\aModel[\beta]$ are disjoint.
We construct the action model $\aPModel{\aStatesT} = \aPModel[\alpha]{\aStatesT[\alpha]} \choice \aPModel[\beta]{\aStatesT[\beta]} = \aPModelTuple{\aStatesT}$ where the disjoint union of action models is defined in Definition~\ref{aml-choice}.  
As $\aModel$ is formed by the disjoint union of $\aModel[\alpha]$ and $\aModel[\beta]$ we note that each state of $\aModel[\alpha]$ and $\aModel[\beta]$ is bisimilar to the corresponding state in $\aModel$.

We first show that for every $\aStateT \in \aStatesT$, $\kPModel{\kStateS} \in \classK$ if $\kPModel{\kStateS} \entails \aPrecondition(\aStateT)$ then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel{\aStateT}$.
Let $\gamma \in \{\alpha, \beta\}$, $\aStateT[\gamma] \in \aStatesT[\gamma] \subseteq \aStatesT$, and $\kPModel{\kStateS} \in \classK$ such that $\kPModel{\kStateS} \entails \aPrecondition(\aStateT[\gamma])$.
By construction $\aPrecondition(\aStateT[\gamma]) = \aPrecondition[\gamma](\aStateT[\gamma])$ and so $\kPModel{\kStateS} \entails \aPrecondition[\gamma](\aStateT[\gamma])$. 
By hypothesis then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel[\gamma]{\aStateT[\gamma]}$.
From above $\aPModel{\aStateT[\gamma]} \bisimilar \aPModel[\gamma]{\aStateT[\gamma]}$ and so from Proposition~\ref{action-bisimulation-results} we have that $\kPModel{\kStateS} \exec \aPModel{\aStateT[\gamma]} \bisimilar \kPModel{\kStateS} \exec \aPModel[\gamma]{\aStateT[\gamma]}$.
From Corollary~\ref{bisimilar-refinement} and Proposition~\ref{refinements-preorder} we have that $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel{\aStateT[\gamma]}$.

We next show that $\entails \actionA{\aPModel{\aStatesT}} \phi$.
\begin{eqnarray}
    &&\entails \actionA{\aPModel[\alpha]{\aStatesT[\alpha]}} \alpha \land \actionA{\aPModel[\beta]{\aStatesT[\beta]}} \beta \label{aaml-k-choice-1}\\
    &&\entails \actionA{\aPModel{\aStatesT[\alpha]}} \alpha \land \actionA{\aPModel{\aStatesT[\beta]}} \beta \label{aaml-k-choice-2}\\
    &&\entails \actionA{\aPModel{\aStatesT[\alpha]}} (\alpha \lor \beta) \land \actionA{\aPModel{\aStatesT[\beta]}} (\alpha \lor \beta) \label{aaml-k-choice-3}\\
    &&\entails \actionA{\aPModel{\aStatesT}} (\alpha \lor \beta) \label{aaml-k-choice-4}
\end{eqnarray}
(\ref{aaml-k-choice-1}) follows from hypothesis;
(\ref{aaml-k-choice-2}) follows from the above note that $\aPModel[\alpha]{\aStatesT[\alpha]} \bisimilar \aPModel{\aStatesT[\alpha]}$ and $\aPModel[\beta]{\aStatesT[\beta]} \bisimilar \aPModel{\aStatesT[\beta]}$ and Proposition~\ref{aml-bisimilar-actions};
(\ref{aaml-k-choice-3}) follows from propositional disjunction introduction; and
(\ref{aaml-k-choice-4}) follows from \axiomRamlK{} axiom {\bf AU}, as $\aStatesT = \aStatesT[\alpha] \cup \aStatesT[\beta]$.

Finally we show that $\entails \actionE{\aPModel{\aStatesT}} \phi \iff \someactsBs \phi$.
\begin{eqnarray}
    &&\entails \someactsBs (\alpha \lor \beta) \implies (\someactsBs \alpha \lor \someactsBs \beta) \label{aaml-k-choice-5}\\
    &&\entails \someactsBs (\alpha \lor \beta) \implies (\actionE{\aPModel[\alpha]{\aStatesT[\alpha]}} \alpha \land \actionE{\aPModel[\beta]{\aStatesT[\beta]}} \beta) \label{aaml-k-choice-6}\\
    &&\entails \someactsBs (\alpha \lor \beta) \implies (\actionE{\aPModel{\aStatesT[\alpha]}} \alpha \land \actionE{\aPModel{\aStatesT[\beta]}} \beta) \label{aaml-k-choice-7}\\
    &&\entails \someactsBs (\alpha \lor \beta) \implies (\actionE{\aPModel{\aStatesT[\alpha]}} (\alpha \lor \beta) \land \actionE{\aPModel{\aStatesT[\beta]}} (\alpha \lor \beta)) \label{aaml-k-choice-8}\\
    &&\entails \someactsBs (\alpha \lor \beta) \implies \actionE{\aPModel{\aStatesT}} (\alpha \lor \beta) \label{aaml-k-choice-9}
\end{eqnarray}
(\ref{aaml-k-choice-5}) follows from \axiomRamlK{} axiom {\bf R};
(\ref{aaml-k-choice-6}) follows from hypothesis;
(\ref{aaml-k-choice-7}) follows from the above note that $\aPModel[\alpha]{\aStatesT[\alpha]} \bisimilar \aPModel{\aStatesT[\alpha]}$ and $\aPModel[\beta]{\aStatesT[\beta]} \bisimilar \aPModel{\aStatesT[\beta]}$ and Proposition~\ref{aml-bisimilar-actions};
(\ref{aaml-k-choice-8}) follows from propositional disjunction introduction; and
(\ref{aaml-k-choice-9}) follows from \axiomRamlK{} axiom {\bf AU}, as $\aStatesT = \aStatesT[\alpha] \cup \aStatesT[\beta]$.

The converse, that $\entails \actionE{\aPModel{\aStatesT}} \phi \implies \someactsBs \phi$ follows from a simple semantic argument.
Let $\kPModel{\kStateS} \in \classK$ and suppose that $\kPModel{\kStateS} \entails \actionE{\aPModel{\aStatesT}} \phi$.
Then there exists $\aStateS \in \aStatesT$ such that $\kPModel{\kStateS} \entails \aPrecondition(\aStateS)$ and $\kPModel{\kStateS} \exec \aPModel{\aStateS} \entails \phi$.
From above, $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel{\aStateS}$, so $\kPModel{\kStateS} \entails \someactsBs \phi$.
Therefore $\entails \actionE{\aPModel{\aStatesT}} \phi \implies \someactsBs \phi$.
\end{proof}

We next show the case where the given formula is a conjunction of a propositional formula and cover operators.

\begin{lemma}\label{aaml-k-covers}
Let $\agentsB, \agentsC \subseteq \agents$, 
let $\phi = \pi \land \bigwedge_{\agentC \in \agentsC} \coverC \Gamma_\agentC \in \langAaml$ where $\pi \in \langPl$, and 
for every $\agentC \in \agentsC$, $\gamma \in \agentsC$
let $\aPModelAndTuple[\gamma]{\aStatesT[\gamma]} \in \classAmK$ be a $\agentsB$-action model such that 
$\entails \actionA{\aPModel[\gamma]{\aStatesT[\gamma]}} \gamma$,
$\entails \actionE{\aPModel[\gamma]{\aStatesT[\gamma]}} \gamma \iff \someactsBs \gamma$, and
for every $\aStateT[\gamma] \in \aStatesT[\gamma]$, $\kPModel{\kStateS} \in \classK$ if $\kPModel{\kStateS} \entails \aPrecondition[\gamma](\aStateT[\gamma])$ then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel[\gamma]{\aStateT[\gamma]}$.
Then there exists a $\agentsB$-action model $\aPModel{\aStatesT} \in \classAmK$ such that 
$\entails \actionA{\aPModel{\aStatesT}} \phi$, and 
$\entails \actionE{\aPModel{\aStatesT}} \phi \iff \someactsBs \phi$.
for every $\aStateT \in \aStatesT$, $\kPModel{\kStateS} \in \classK$ if $\kPModel{\kStateS} \entails \aPrecondition(\aStateT)$ then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel{\aStateT}$.
\end{lemma}

\begin{proof}
Without loss of generality we assume that each $\aModel[\gamma]$ for every $\agentC \in \agentsC$, $\gamma \in \Gamma_\agentC$ is disjoint.

We construct the action model $\aPModelAndTuple{\aStateTest}$ where:
\begin{eqnarray*}
    \aStates &=& \{\aStateTest, \aStateSkip\} \cup \bigcup_{\agentC \in \agentsC, \gamma \in \Gamma_\agentC} \aStates[\gamma]\\
    \aAccessibilityC &=& \{(\aStateTest, \aStateT[\gamma]) \mid \gamma \in \Gamma_\agentC, \aStateT[\gamma] \in \aStatesT[\gamma]\} \cup \{(\aStateSkip, \aStateSkip)\} \cup \bigcup_{\agentD \in \agentsC, \gamma \in \Gamma_\agentD} \aAccessibilityC[\gamma]\\
    \aAccessibilityB &=& \{(\aStateTest, \aStateSkip), (\aStateSkip, \aStateSkip)\} \cup \bigcup_{\agentC \in \agentsC, \gamma \in \Gamma_\agentC} \aAccessibilityB[\gamma]\\
    \aPrecondition &=& \{(\aStateTest, \someactsBs \phi), (\aStateSkip, \top)\} \cup \bigcup_{\agentC \in \agentsC, \gamma \in \Gamma_\agentC} \aPrecondition[\gamma]
\end{eqnarray*}
where $\agentC \in \agentsC$ and $\agentB \in \agents \setminus \agentsC$.

\begin{figure}
    \caption{A schematic of the constructed action model.}\label{aaml-k-construction}
    \centering
    \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=7em,thick]

    \node (test) {$\someactsBs \phi$};
    \node (mTd) [below=7em of test] {$\cdots$};
    \node (mTc1gn) [left=2.5em of mTd] {$\aPModel[\gamma^{\agentC_1}]{\aStatesT[\gamma^{\agentC_1}_1]}$};
    \node (mTc1d) [left=2.5em of mTc1gn] {$\cdots$};
    \node (mTc1g1) [left=2.5em of mTc1d] {$\aPModel[\gamma^{\agentC_1}]{\aStatesT[\gamma^{\agentC_1}_{n_1}]}$};
    \node (mTcmg1) [right=2.5em of mTd] {$\aPModel[\gamma^{\agentC_m}]{\aStatesT[\gamma^{\agentC_m}_1]}$};
    \node (mTcmd) [right=2.5em of mTcmg1] {$\cdots$};
    \node (mTcmgn) [right=2.5em of mTcmd] {$\aPModel[\gamma^{\agentC_m}]{\aStatesT[\gamma^{\agentC_m}_{n_m}]}$};
    \node (skip) [above=7em of test] {$\top$};

      \path[every node/.style={font=\sffamily\small},->]
        (skip) edge [loop right] node {$\agents$} (skip)
        (test) edge node {$\agentC_1$} (mTc1g1)
               edge node {$\agentC_1$} (mTc1gn)
               edge [swap] node {$\agentC_m$} (mTcmg1)
               edge [swap] node {$\agentC_m$} (mTcmgn)
               edge node {$\agents \setminus \{\agentC_1, \dots, \agentC_m\}$} (skip);
    \end{tikzpicture}
\end{figure}

A schematic of the action model $\aPModel{\aStateTest}$ and an overview of our construction is shown in Figure~\ref{aaml-k-construction}.
Here we can see that $\aPModel{\aStateTest}$ is formed by taking each action model $\aPModel[\gamma]{\aStatesT[\gamma]}$ for $\agentC \in \agentsC$, $\gamma \in \Gamma_\agentC$ and combining them into a single model with a new state with the precondition $\someactsBs \phi$.
This is similar to the construction used to show the soundness of the axiom {\bf RK} in \logicRmlK{}, but it deals with all agents in $\agentsC$ at once, rather than a single agent at a time.

We note for every $\agentC \in \agentsC$, $\gamma \in \Gamma_\agentC$, $\aStateS[\gamma] \in \aStates[\gamma]$ that $\aPModel{\aStateS[\gamma]} \bisimilar \aPModel[\gamma]{\aStateS[\gamma]}$, as by construction $\aModel$ contains the disjoint union of each $\aModel[\gamma]$ and no outward-facing edges are added to any state from $\aStates[\gamma]$ in $\aModel$.

We first show that $\entails \actionA{\aPModel{\aStateTest}} \phi$, in several parts.
We note that from the definition of the cover operator:
$$
\phi = \pi \land \bigwedge_{\agentC \in \agentsC} (\necessaryC \bigvee_{\gamma \in \Gamma_\agentC} \gamma \land \bigwedge_{\gamma \in \Gamma_\agentC} \possibleC \gamma)
$$
Thus we will show individually that:
\begin{enumerate}
\item $\entails \actionA{\aPModel{\aStateTest}} \pi$
\item $\entails \actionA{\aPModel{\aStateTest}} \necessaryC \bigvee_{\gamma \in \Gamma_\agentC} \gamma$, for every $\agentC \in \agentsC$
\item $\entails \actionA{\aPModel{\aStateTest}} \bigwedge_{\gamma \in \Gamma_\agentC} \possibleC \gamma$, for every $\agentC \in \agentsC$
\end{enumerate}

We show that $\entails \actionA{\aPModel{\aStateTest}} \pi$.
\begin{eqnarray}
    && \entails \phi \implies \pi \label{aaml-covers-1}\\
    && \entails \lnot \pi \implies \lnot \phi \label{aaml-covers-2}\\
    && \entails  \allactsBs (\lnot \pi \implies \lnot \phi) \label{aaml-covers-3}\\
    && \entails  \allactsBs \lnot \pi \implies \allactsBs \lnot \phi \label{aaml-covers-4}\\
    && \entails  \someactsBs \phi \implies \someactsBs \pi \label{aaml-covers-5}\\
    && \entails  \aPrecondition(\aStateTest) \implies \pi \label{aaml-covers-6}\\
    && \entails  \actionA{\aPModel{\aStateTest}} \pi \label{aaml-covers-7}
\end{eqnarray}
(\ref{aaml-covers-1}) and
(\ref{aaml-covers-2}) follow from propositional reasoning;
(\ref{aaml-covers-3}) follows from \axiomRamlK{} rule {\bf NecR};
(\ref{aaml-covers-4}) follows from \axiomRamlK{} axiom {\bf R};
(\ref{aaml-covers-5}) follows from the definition of $\someactsBs$;
(\ref{aaml-covers-6}) follows from the construction of $\aPModel{\aStateTest}$ and \axiomRamlK{} axiom{\bf RP}; and
(\ref{aaml-covers-7}) follows from \axiomRamlK{} axiom {\bf AP}.

We show that $\entails \actionA{\aPModel{\aStateTest}} \necessaryC \bigvee_{\gamma \in \Gamma_\agentC} \gamma$, for every $\agentC \in \agentsC$.
Let $\agentC \in \agentsC$.
\begin{eqnarray}
    && \entails \actionA{\aPModel[\gamma]{\aStatesT[\gamma]}} \gamma \text{ for every } \gamma \in \Gamma_\agentC \label{aaml-covers-8}\\
    && \entails \actionA{\aPModel{\aStatesT[\gamma]}} \gamma \text{ for every } \gamma \in \Gamma_\agentC \label{aaml-covers-9}\\
    && \entails \bigwedge_{\aStateT \in \aStatesT[\gamma]} \actionA{\aPModel[\gamma]{\aStateT}} \gamma \text{ for every } \gamma \in \Gamma_\agentC \label{aaml-covers-10}\\
    && \entails \necessaryC \bigwedge_{\aStateT \in \aStatesT[\gamma]} \actionA{\aPModel[\gamma]{\aStateT}} \gamma \text{ for every } \gamma \in \Gamma_\agentC \label{aaml-covers-11}\\
    && \entails \bigwedge_{\gamma \in \Gamma_\agentC} \necessaryC \bigwedge_{\aStateT \in \aStatesT[\gamma]} \actionA{\aPModel[\gamma]{\aStateT}} \gamma \label{aaml-covers-12}\\
    && \entails \bigwedge_{\gamma \in \Gamma_\agentC} \bigwedge_{\aStateT \in \aStatesT[\gamma]} \necessaryC \actionA{\aPModel[\gamma]{\aStateT}} \gamma \label{aaml-covers-13}\\
    && \entails \bigwedge_{\gamma \in \Gamma_\agentC} \bigwedge_{\aStateT \in \aStatesT[\gamma]} \necessaryC \actionA{\aPModel[\gamma]{\aStateT}} \bigvee_{\gamma' \in \Gamma_\agentC} \gamma' \label{aaml-covers-14}\\
    && \entails \bigwedge_{\aStateT \in \aSuccessorsC{\aStateTest}} \necessaryC \actionA{\aPModel[\gamma]{\aStateT}} \bigvee_{\gamma \in \Gamma_\agentC} \gamma \label{aaml-covers-15}\\
    && \entails \aPrecondition(\aStateTest) \implies \bigwedge_{\aStateT \in \aSuccessorsC{\aStateTest}} \necessaryC \actionA{\aPModel{\aStateT}} \bigvee_{\gamma \in \Gamma_\agentC} \gamma \label{aaml-covers-16}\\
    && \entails \actionA{\aPModel{\aStateTest}} \necessaryC \bigvee_{\gamma \in \Gamma_\agentC} \gamma \label{aaml-covers-17}
\end{eqnarray}
(\ref{aaml-covers-8}) follows from hypothesis;
(\ref{aaml-covers-9}) follows from the above note that $\aModel[\gamma]{\aStateT[\gamma]} \bisimilar \aPModel{\aStateT[\gamma]}$;
(\ref{aaml-covers-10}) follows from \axiomRamlK{} axiom {\bf AU};
(\ref{aaml-covers-14}) follows from propositional disjunction introduction;
(\ref{aaml-covers-15}) follows from the construction of $\aModel$; and
(\ref{aaml-covers-17}) follows from \axiomRamlK{} axiom {\bf AK}.

We show that $\entails \actionA{\aPModel{\aStateTest}} \bigwedge_{\gamma \in \Gamma_\agentC} \possibleC \gamma$, for every $\agentC \in \agentsC$.
Let $\agentC \in \agentsC$.

Suppose that $\agentC \in \agentsB$.
Then:
\begin{eqnarray}
    &&\entails \someactsBs \phi \implies \someactsBs \coversC \Gamma_\agentC \label{aaml-covers-18}\\
    &&\entails \someactsBs \phi \implies \bigwedge_{\gamma \in \Gamma_\agentC} \possibleC \someactsBs \gamma \label{aaml-covers-19}
\end{eqnarray}
(\ref{aaml-covers-18}) follows from \axiomRamlK{} axiom {\bf R} and rule {\bf NecR}; and
(\ref{aaml-covers-19}) follows from \axiomRamlK{} axiom {\bf RK}.

Suppose that $\agentC \notin \agentsB$.
Then:
\begin{eqnarray}
    &&\entails \someactsBs \phi \implies \someactsBs \coversC \Gamma_\agentC \label{aaml-covers-20}\\
    &&\entails \someactsBs \phi \implies \coversC \{\someactsBs \gamma \mid \gamma \in \Gamma_\agentC \}\label{aaml-covers-21}\\
    &&\entails \someactsBs \phi \implies \bigwedge_{\gamma \in \Gamma_\agentC} \possibleC \someactsBs \gamma \label{aaml-covers-22}
\end{eqnarray}
(\ref{aaml-covers-20}) follows from \axiomRamlK{} axiom {\bf R} and rule {\bf NecR};
(\ref{aaml-covers-21}) follows from \axiomRamlK{} axiom {\bf RComm}; and
(\ref{aaml-covers-22}) follows from the definition of the cover operator.

So we have that $\entails \someactsBs \phi \implies \bigwedge_{\gamma \in \Gamma_\agentC} \possibleC \gamma$.
Then:
\begin{eqnarray}
    && \entails \someactsBs \phi \implies \bigwedge_{\gamma \in \Gamma_\agentC} \possibleC \someactsBs \gamma \label{aaml-covers-23}\\
    && \entails \someactsBs \phi \implies \bigwedge_{\gamma \in \Gamma_\agentC} \possibleC \actionE{\aPModel[\gamma]{\aStatesT[\gamma]}} \gamma \label{aaml-covers-24}\\
    && \entails \someactsBs \phi \implies \bigwedge_{\gamma \in \Gamma_\agentC} \possibleC \actionE{\aPModel{\aStatesT[\gamma]}} \gamma \label{aaml-covers-25}\\
    && \entails \someactsBs \phi \implies \bigwedge_{\gamma \in \Gamma_\agentC} \possibleC \bigvee_{\aStateT \in \aStatesT[\gamma]} \actionE{\aPModel{\aStateT}} \gamma \label{aaml-covers-26}\\
    && \entails \someactsBs \phi \implies \bigwedge_{\gamma \in \Gamma_\agentC} \possibleC \bigvee_{\aStateT \in \aSuccessorsC{\aStateTest}} \actionE{\aPModel{\aStateT}} \gamma \label{aaml-covers-27}\\
    && \entails \bigwedge_{\gamma \in \Gamma_\agentC} \left(\someactsBs \phi \implies \possibleC \bigvee_{\aStateT \in \aSuccessorsC{\aStateTest}} \actionE{\aPModel{\aStateT}} \gamma\right) \label{aaml-covers-28}\\
    && \entails \bigwedge_{\gamma \in \Gamma_\agentC} \actionA{\aPModel{\aStateTest}} \possibleC \gamma \label{aaml-covers-29}
\end{eqnarray}
(\ref{aaml-covers-23}) follows from above;
(\ref{aaml-covers-24}) follows from hypothesis;
(\ref{aaml-covers-25}) follows from the above note that $\aModel[\gamma]{\aStateT[\gamma]} \bisimilar \aPModel{\aStateT[\gamma]}$;
(\ref{aaml-covers-26}) follows from \axiomRamlK{} axiom {\bf AU};
(\ref{aaml-covers-27}) follows from the construction of $\aModel$ and propositional disjunction introduction;
(\ref{aaml-covers-28}) follows from propositional reasoning; and
(\ref{aaml-covers-29}) follows from \axiomRamlK{} axiom {\bf AK}.

Therefore $\entails \actionA{\aPModel{\aStateTest}} \phi$.

Next we show that $\entails \actionE{\aPModel{\aStateTest}} \phi \iff \someactsBs \phi$. 
This is straight-forward, given what we have shown above.
\begin{eqnarray}
    && \entails \actionE{\aPModel{\aStateTest}} \phi \iff (\aPrecondition(\aStateTest) \land \actionA{\aPModel{\aStateTest}} \phi) \label{aaml-covers-30}\\
    && \entails \actionE{\aPModel{\aStateTest}} \phi \iff \aPrecondition(\aStateTest) \label{aaml-covers-31}\\
    && \entails \actionE{\aPModel{\aStateTest}} \phi \iff \someactsBs \phi \label{aaml-covers-32}
\end{eqnarray}
(\ref{aaml-covers-30}) follows from the definition of $\actionE{}$;
(\ref{aaml-covers-31}) follows from $\entails \actionA{\aPModel{\aStateTest}} \phi$ above;
(\ref{aaml-covers-32}) follows from the construction of $\aModel$.

Therefore $\entails \actionE{\aPModel{\aStateTest}} \phi \iff \someactsBs \phi$.

We next show that for every $\kPModel{\kStateS} \in \classK$ if $\kPModel{\kStateS} \entails \aPrecondition(\aStateTest)$ then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel{\aStateTest}$.
Let $\kPModel{\kStateS} \in \classK$ such that $\kPModel{\kStateS} \entails \aPrecondition(\aStateTest)$.
For every $\agentC \in \agentsC$, $\gamma \in \Gamma_\agentC$, $\aStateT[\agentC, \gamma] \in \aStatesT[\agentC, \gamma]$, $\kStateT \in \kSuccessorsC{\kStateS}$ such that $\kPModel{\kStateT} \entails \aPrecondition[\agentC,\gamma](\aStateT[\agentC,\gamma])$ we have that $\kPModel{\kStateT} \simulatesBs \kPModel{\kStateT} \exec \aPModel[\agentC, \gamma]{\aStateT[\agentC, \gamma]}$.
From above $\aPModel[\agentC, \gamma]{\aStateT[\agentC, \gamma]} \bisimilar \aPModel{\aStateT[\agentC, \gamma]}$ and so by Proposition~\ref{action-bisimulation-results} we have that $\kPModel{\kStateT} \exec \aPModel[\agentC, \gamma]{\aStateT[\agentC, \gamma]} \bisimilar \kPModel{\kStateT} \exec \aPModel{\aStateT[\agentC, \gamma]}$.
From Corollary~\ref{bisimilar-refinement} and Proposition~\ref{refinements-preorder} we have that $\kPModel{\kStateT} \simulatesBs \kPModel{\kStateT} \exec \aPModel{\aStateT[\agentC, \gamma]}$ (say via a $\agentsB$-refinement $\refinement^{\kStateT, \aStateT[\agentC, \gamma]}$).

Let $\kPModelP{(\kStateS, \aStateTest)} = \kPModel{\kStateS} \exec \aPModel{\aStateTest}$.
We define $\refinement \subseteq \kStates \times \kStatesP$ where:
\begin{eqnarray*}
\refinement &=& 
\{(\kStateS, (\kStateS, \aStateTest))\} \cup 
\{(\kStateT, (\kStateT, \aStateSkip)) \mid \kStateT \in \kStates\}  \\&&\quad \cup
\bigcup \{\refinement^{\kStateT, \aStateT[\agentC, \gamma]} \mid \agentC \in \agentsC, \gamma \in \Gamma_\agentC, \aStateT[\agentC, \gamma] \in \aStatesT[\agentC, \gamma], \kStateT \in \kSuccessorsC{\kStateT}, \kPModel{\kStateT} \entails \aPrecondition(\aStateT[\agentC, \gamma])\}
\end{eqnarray*}

We show that $\refinement$ is a $\agentsB$-refinement from $\kModel{\kStateS}$ to $\kModelP{(\kStateS, \aStateTest)}$.
Let $\atomP \in \atoms$, $\agentA \in \agents$ and $\agentD \in \agents \setminus \agentsB$.
We show by cases that the relationships in $\refinement$ satisfy the conditions {\bf atoms-$\atomP$}, {\bf forth-$\agentD$}, and {\bf back-$\agentA$}.

\begin{description}
    \item[{Case $(\kStateS, (\kStateS, \aStateTest)) \in \refinement$:}] \hfill\\
        \begin{description}
            \item[atoms-$\atomP$]
                By construction $\kStateS \in \kValuation(\atomP)$ if and only if $(\kStateS, \aStateTest) \in \kValuationP(\atomP)$.
            \item[forth-$\agentD$]
                Suppose that $\agentD \in \agentsC$.
                Let $\kStateT \in \kSuccessorsD{\kStateS}$.
                By hypothesis $\kPModel{\kStateS} \entails \someactsBs (\pi \land \bigwedge_{\agentC \in \agentsC} \coversC \Gamma_\agentC)$, and in particular $\kPModel{\kStateS} \entails \someactsBs \coversD \Gamma_\agentD$.
                As $\agentD \neq \agentsB$, by the \axiomRamlK{} axiom {\bf RComm} we have that $\kPModel{\kStateS} \entails \coversD \{\someactsBs \gamma' \mid \gamma' \in \Gamma_\agentD\}$ and by the definition of the cover operator we have that $\kPModel{\kStateS} \entails \necessaryD \bigvee_{\gamma' \in \Gamma_\agentD} \someactsBs \gamma'$ so there exists $\gamma' \in \Gamma_\agentD$ such that $\kPModel{\kStateT} \entails \someactsBs \gamma'$.
                By hypothesis $\entails \someactsBs \gamma' \implies \actionE{\aPModel[\agentC, \gamma']{\aStatesT[\agentC, \gamma']}} \gamma'$ so there exists $\aStateT[\agentC, \gamma'] \in \aStatesT[\agentC, \gamma']$ such that $\kPModel{\kStateT} \entails \aPrecondition[\agentC, \gamma'](\aStateT[\agentC, \gamma'])$.
                By construction $\aStateT[\agentC, \gamma'] \in \aSuccessorsD{\aStateTest}$ and $\aPrecondition(\aStateT[\agentC, \gamma']) = \aPrecondition[\agentC, \gamma'](\aStateT[\agentC, \gamma'])$ so $\kPModel{\kStateT} \entails \aPrecondition(\aStateT[\agentC, \gamma'])$, $(\kStateT, \aStateT[\agentC, \gamma']) \in \kSuccessorsPD{(\kStateS, \aStateTest)}$, and $(\kStateT, (\kStateT, \aStateT[\agentC, \gamma'])) \in \refinement^{\kStateT, \aStateT[\agentC, \gamma']} \subseteq \refinement$.

                Suppose that $\agentD \notin \agentsC$.
                Let $\kStateT \in \kSuccessorsD{\kStateS}$.
                By construction $\aStateSkip \in \aSuccessorsD{\aStateTest}$ and $\kPModel{\kStateT} \entails \aPrecondition(\aStateSkip)$, so $(\kStateT, \aStateSkip) \in \kSuccessorsPD{(\kStateS, \aStateTest)}$ and $(\kStateT, (\kStateT, \aStateSkip)) \in \refinement$.
            \item[back-$\agentA$]
                Suppose that $\agentA \in \agentsC$.
                Let $(\kStateT, \aStateT[\agentA, \gamma]) \in \kSuccessorsPA{(\kStateS, \aStateTest)}$ where $\gamma \in \Gamma_\agentA$ and $\aStateT[\agentA, \gamma] \in \aStatesT[\agentA, \gamma]$.
                By construction $\kStateT \in \kSuccessorsA{\kStateS}$ and $\kPModel{\kStateT} \entails \aPrecondition(\aStateT[\agentA, \gamma])$ so by hypothesis $(\kStateT, (\kStateT, \aStateT[\agentA, \gamma])) \in \refinement^{\kStateT, \aStateT[\agentC, \gamma]} \subseteq \refinement$.
                Suppose that $\agentA \notin \agentsC$.
                Let $(\kStateT, \aStateSkip) \in \kSuccessorsPA{(\kStateS, \aStateTest)}$.
                By construction $\kStateT \in \kSuccessorsA{\kStateS}$ and $(\kStateT, (\kStateT, \aStateSkip)) \in \refinement$.
        \end{description}
    \item[{Case $(\kStateT, (\kStateT, \aStateSkip)) \in \refinement$ where $\kStateT \in \kStates$:}] \hfill\\
        \begin{description}
            \item[atoms-$\atomP$]
                By construction $\kStateT \in \kValuation(\atomP)$ if and only if $(\kStateT, \aStateSkip) \in \kValuationP(\atomP)$.
            \item[forth-$\agentD$]
                Let $\kStateU \in \kSuccessorsD{\kStateT}$.
                By construction $\aStateSkip \in \aSuccessorsD{\aStateSkip}$ and $\kPModel{\kStateU} \entails \aPrecondition(\aStateSkip)$, so $(\kStateU, \aStateSkip) \in \kSuccessorsPD{(\kStateT, \aStateSkip)}$ and $(\kStateU, (\kStateU, \aStateSkip)) \in \refinement$.
            \item[back-$\agentA$]
                Let $(\kStateU, \aStateSkip) \in \kSuccessorsPA{(\kStateT, \aStateSkip)}$.
                By construction $\kStateU \in \kSuccessorsA{\kStateT}$ and $(\kStateU, (\kStateU, \aStateSkip)) \in \refinement$.
        \end{description}
    \item[{Case $(\kStateT, \kStateTP) \in \refinement^{\kStateT, \aStateT[\agentC, \gamma]} \subseteq \refinement$ where $\agentC \in \agentsC$, $\gamma \in \Gamma_\agentC$, $\aStateT[\agentC, \gamma] \in \aStatesT[\agentC, \gamma]$, $\kStateT \in \kStates$, and $\kPModel{\kStateT} \entails \aPrecondition(\aStateT[\agentC, \gamma])$:}] \hfill\\
        \begin{description}
            \item[atoms-$\atomP$]
                By {\bf atoms-$\atomP$} for $\refinement^{\kStateT, \aStateT[\agentC, \gamma]}$ we have that $\kStateT \in \kValuation(\atomP)$ if and only if $\kStateTP \in \kValuationP(\atomP)$.
            \item[forth-$\agentD$]
                Let $\kStateU \in \kSuccessorsD{\kStateT}$.
                By {\bf forth-$\agentD$} for $\refinement^{\kStateT, \aStateT[\agentC, \gamma]}$ there exists $\kStateUP \in \kSuccessorsPD{\kStateTP}$ such that $(\kStateU, \kStateUP) \in \refinement^{\kStateT, \aStateT[\agentC, \gamma]} \subseteq \refinement$.
            \item[back-$\agentA$]
                Let $\kStateUP \in \kSuccessorsPA{\kStateTP}$.
                By {\bf back-$\agentA$} for $\refinement^{\kStateT, \aStateT[\agentC, \gamma]}$ there exists $\kStateU \in \kSuccessorsA{\kStateT}$ such that $(\kStateU, \kStateUP) \in \refinement^{\kStateT, \aStateT[\agentC, \gamma]} \subseteq \refinement$.
        \end{description}
\end{description}

Therefore $\refinement$ is a $\agentsB$-refinement and $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel{\aStateTest}$.

\end{proof}

We combine the two previous lemmas into an inductive construction that works for all formulas.

\begin{theorem}\label{aaml-k-synthesis}
Let $\agentsB \subseteq \agents$ and let $\phi \in \langAaml$.
There exists an action model $\aPModelAndTuple{\aStatesT} \in \classAmK$ such that 
$\entails \actionA{\aPModel{\aStatesT}} \phi$,
$\entails \actionE{\aPModel{\aStatesT}} \phi \iff \someactsBs \phi$, and
for every $\aStateT \in \aStatesT$, $\kPModel{\kStateS} \in \classK$ if $\kPModel{\kStateS} \entails \aPrecondition(\aStateT)$ then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel{\aStateT}$.
\end{theorem}

\begin{proof}
Without loss of generality, by Corollary~\ref{raml-k-expressive-equivalence} we may assume that $\phi \in \langMl$ and by Lemma~\ref{dnf-equivalent} we may further assume that $\phi$ is in disjunctive normal form.
Then we proceed by induction on the structure of $\phi$.  
Suppose that $\phi = \pi \land \bigwedge_{\agentC \in \agentsC} \Gamma_\agentC$ where $\pi \in \langPl$, $\agentsC \subseteq \agents$ and for every $\agentC \in \agentsC$, $\Gamma_\agentC \subseteq \langMl$ is a finite set of modal formulas.
We note that the base case for the induction occurs when for every $\agentC \in \agentsC$, $\Gamma_\agentC = \emptyset$.
By the induction hypothesis for every $\agentC \in \agentsC$, $\gamma \in \Gamma_\agentC$ there exists 
an action model $\aPModel[\gamma]{\aStatesT[\gamma]} \in \classAmK$ such that
$\entails \actionA{\aPModel[\gamma]{\aStatesT[\gamma]}} \gamma$,
$\entails \actionE{\aPModel[\gamma]{\aStatesT[\gamma]}} \gamma \iff \someactsBs \gamma$, and
for every $\aStateT[\gamma] \in \aStatesT[\gamma]$, $\kPModel{\kStateS} \in \classK$ if $\kPModel{\kStateS} \entails \aPrecondition[\gamma](\aStateT[\gamma])$ then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel[\gamma]{\aStateT[\gamma]}$.
By Lemma~\ref{aaml-k-covers} there exists a $\agentsB$-action model $\aPModel{\aStatesT} \in \classAmK$ such that 
$\entails \actionA{\aPModel{\aStatesT}} \phi$,
$\entails \actionE{\aPModel{\aStatesT}} \phi \iff \someactsBs \phi$, and
for every $\aStateT \in \aStatesT$, $\kPModel{\kStateS} \in \classK$ if $\kPModel{\kStateS} \entails \aPrecondition(\aStateT)$ then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel{\aStateT}$.

Suppose that $\phi = \alpha \lor \beta$ where $\alpha, \beta \in \langMl$.
By the induction hypothesis there exists $\agentsB$-action models
$\aPModel[\alpha]{\aStatesT[\alpha]} \in \classAmK$ and $\aPModel[\beta]{\aStatesT[\beta]} \in \classAmK$ such that 
$\entails \actionA{\aPModel[\alpha]{\aStatesT[\alpha]}} \alpha$, 
$\entails \actionE{\aPModel[\alpha]{\aStatesT[\alpha]}} \alpha \iff \someactsBs \alpha$, 
$\entails \actionA{\aPModel[\beta]{\aStatesT[\beta]}} \beta$,
$\entails \actionE{\aPModel[\beta]{\aStatesT[\beta]}} \beta \iff \someactsBs \beta$,
for every $\aStateT[\alpha] \in \aStatesT[\alpha]$, $\kPModel{\kStateS} \in \classK$ if $\kPModel{\kStateS} \entails \aPrecondition[\alpha](\aStateT[\alpha])$ then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel[\alpha]{\aStateT[\alpha]}$, and
for every $\aStateT[\beta] \in \aStatesT[\beta]$, $\kPModel{\kStateS} \in \classK$ if $\kPModel{\kStateS} \entails \aPrecondition[\beta](\aStateT[\beta])$ then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel[\beta]{\aStateT[\beta]}$.
By Lemma~\ref{aaml-k-choice} there exists a $\agentsB$-action model $\aPModel{\aStatesT} \in \classAmK$ such that 
$\entails \actionA{\aPModel{\aStateS}} \phi$,
$\entails \actionE{\aPModel{\aStateS}} \phi \iff \someactsBs \phi$, and
for every $\aStateT \in \aStatesT$, $\kPModel{\kStateS} \in \classK$ if $\kPModel{\kStateS} \entails \aPrecondition(\aStateT)$ then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel{\aStateT}$.
\end{proof}

Given this result we can show that the logics \logicAamlK{} and \logicRamlK{} agree on all \langAaml{} formulas.

\begin{theorem}\label{aaml-k-semantics-equivalent}
The semantics of \logicAamlK{} and the semantics of \logicRamlK{} agree on all formulas of \langAaml{}.
That is, for every $\phi \in \langAaml$, $\kPModel{\kStateS} \in \classK$: $\kPModel{\kStateS} \entails_\logicAamlK \phi$ if and only if $\kPModel{\kStateS} \entails_\logicAamlK \phi$.
\end{theorem}

\begin{proof}
Let $\phi \in \langAaml$.
We show by induction on the structure of $\phi$ that for every $\kPModel{\kStateS} \in \classK$, $\kPModel{\kStateS} \entails_\logicAamlK \phi$ if and only $\kPModel{\kStateS} \entails_\logicRamlK \phi$.
The cases where $\phi = \atomP$, $\phi = \lnot \psi$,  $\phi = \psi \land \chi$, $\phi = \necessaryA \psi$ or $\phi = \actionA{\aPModel{\aStateS}} \psi$ where $\atomP \in \atoms$ and $\psi, \chi \in \langAaml$ follow directly from the semantics of \logicAamlK{} and \logicRamlK{}.

Suppose that $\phi = \someactsBs \psi$ where $\psi \in \langAaml$. 
We will show that $\kPModel{\kStateS} \entails_\logicAamlK \someactsBs \psi$ if and only if $\kPModel{\kStateS} \entails_\logicRamlK \someactsBs \psi$.

Suppose that $\kPModel{\kStateS} \entails_\logicAamlK \someactsBs \psi$.
Then there exists an action model $\aPModelAndTuple{\aStateS} \in \aSignatureFamily$ such that $\kPModel{\kStateS} \entails_\logicAamlK \aPrecondition(\aStateS)$, $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel{\aStateS}$, and $\kPModel{\kStateS} \exec \aPModel{\aStateS} \entails_\logicAamlK \psi$.
By Lemma~\ref{action-models-refinements} we have $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel{\aStateS}$.
By the induction hypothesis we have $\kPModel{\kStateS} \entails_\logicRamlK \aPrecondition(\aStateS)$ and $\kPModel{\kStateS} \exec \aPModel{\aStateS} \entails_\logicRamlK \psi$.
Therefore $\kPModel{\kStateS} \entails_\logicRamlK \someactsBs \psi$.

Suppose that $\kPModel{\kStateS} \entails_\logicRamlK \someactsBs \psi$.
From Theorem~\ref{aaml-k-synthesis} there exists an action model $\aPModel{\aStatesT} \in \classAmK$ such that 
$\entails_\logicRamlK \actionA{\aPModel{\aStatesT}} \psi$,
$\entails_\logicRamlK \actionE{\aPModel{\aStatesT}} \psi \iff \someactsBs \psi$, and
for every $\aStateT \in \aStatesT$, $\kPModel{\kStateS} \in \classK$ if $\kPModel{\kStateS} \entails_\logicRamlK \aPrecondition(\aStateT)$ then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel{\aStateT}$.
Without loss of generality, by Corollary~\ref{raml-k-expressive-equivalence} we assume that $\aPModel{\aStatesT}$ has preconditions defined on \langMl{}.
Then $\kPModel{\kStateS} \entails_\logicRamlK \actionE{\aPModel{\aStatesT}} \psi$ and so there exists $\aStateT \in \aStatesT$ such that $\kPModel{\kStateS} \entails_\logicRamlK \aPrecondition(\aStateT)$, $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel{\aStateT}$, and $\kPModel{\kStateS} \exec \aPModel{\aStateT} \entails_\logicRamlK \psi$.
As $\aPrecondition(\aStateT) \in \langMl$ then $\kPModel{\kStateS} \entails_\logicAamlK \aPrecondition(\aStateT)$
By the induction hypothesis $\kPModel{\kStateS} \exec \aPModel{\aStateT} \entails_\logicAamlK \psi$.
Therefore $\kPModel{\kStateS} \entails_\logicAamlK \someactsBs \psi$.
\end{proof}

As a consequence of the equivalence between \logicAamlK{} and \logicRamlK{}, we get as corollaries all of the results that we have previously shown for \logicRamlK{}.

\begin{corollary}
The logics \logicAamlK{} and \logicAmlK{} agree on all formulas of \langAml{}.
That is, for every $\phi \in \langAml$, $\kPModel{\kStateS} \in \classK$: $\kPModel{\kStateS} \entails_\logicAamlK \phi$ if and only if $\kPModel{\kStateS} \entails_\logicAmlK \phi$.
\end{corollary}

\begin{corollary}
The logics \logicAamlK{} and \logicRmlK{} agree on all formulas of \langRml{}.
That is, for every $\phi \in \langRml$, $\kPModel{\kStateS} \in \classK$: $\kPModel{\kStateS} \entails_\logicAamlK \phi$ if and only if $\kPModel{\kStateS} \entails_\logicRmlK \phi$.
\end{corollary}

\begin{corollary}
The axiomatisation \axiomRamlK{} is sound and strongly complete with respect to the semantics of the logic \logicAamlK{}.
\end{corollary}

\begin{corollary}
The logic \logicAamlK{} is expressively equivalent to the logic \logicK{}.
\end{corollary}

\begin{corollary}
The logic \logicAamlK{} is compact.
\end{corollary}

\begin{corollary}
The satisfiability problem for the logic \logicAamlK{} is decidable.
\end{corollary}
