\section{\classK{}}\label{aaml-k}

In this section we consider results specific to the logic \logicAamlK{} in the setting of \classK{}.
The main result of this section is that the action model quantifiers of \logicAamlK{} are equivalent to the refinement quantifiers of \logicRmlK{}.
We show this equivalence by showing that if there exists a refinement where a given formula is satisfied then we can construct a finite action model that results in that formula being satisfied.

We rely heavily on results from the action model logic \logicAmlK{} and the refinement modal logic \logicRmlK{}, particularly the axiomatisations from both.
In the previous section we defined the refinement action model logic, \logicRamlK{}, that extends action model logic with refinement quantifiers, so that we can use results from \logicAmlK{} and \logicRmlK{} with a combined syntax, semantics and proof theory.

We first note that as the syntax and semantics of \logicRamlK{} are formed by combining the semantics of \logicAmlK{} and \logicRmlK{}, then \logicAmlK{} and \logicRmlK{} agree with \logicRamlK{} on formulas from their respective sublanguages.

\begin{lemma}\label{raml-k-aml}
The logics \logicRamlK{} and \logicAmlK{} agree on all formulas of \langAml{}.
That is, for every $\phi \in \langAml$, $\kPModel{\kStateS} \in \classK$: $\kPModel{\kStateS} \entails_\logicRamlK \phi$ if and only if $\kPModel{\kStateS} \entails_\logicAmlK \phi$.
\end{lemma}

\begin{lemma}\label{raml-k-rml}
The logics \logicRamlK{} and \logicRmlK{} agree on all formulas of \langRml{}.
That is, for every $\phi \in \langRml$, $\kPModel{\kStateS} \in \classK$: $\kPModel{\kStateS} \entails_\logicRamlK \phi$ if and only if $\kPModel{\kStateS} \entails_\logicRmlK \phi$.
\end{lemma}

These results follow directly from the definitions.
We note that these results only apply for \langAml{} and \langRml{} formulas respectively, and do not consider \langAaml{} formulas that contain both action model operators and quantifiers. 

Given these results we can give a sound and complete axiomatisation for \logicRamlK{} by combining the axiomatisations for \logicAmlK{} and \logicRmlK{}.

\pagebreak

\begin{definition}[Axiomatisation \axiomRamlK{}]\label{raml-k-axiomatisation}
The axiomatisation \axiomRamlK{} is a substitution schema consisting of the axioms and rules of \axiomAmlK{} and the axioms and rules of \axiomRmlK{}:
$$
\begin{array}{rl}
    {\bf P}     & \text{All propositional tautologies}\\
    {\bf K}     & \proves \necessaryA (\phi \implies \psi) \implies (\necessaryA \phi \implies \necessaryA \psi)\\
    {\bf AP} & \proves \actionA{\aPModel{\aStateS}} \atomP \iff (\aPrecondition(\aStateS) \implies \atomP)\\
    {\bf AN} & \proves \actionA{\aPModel{\aStateS}} \lnot \phi \iff (\aPrecondition(\aStateS) \implies \lnot \actionA{\aPModel{\aStateS}} \phi)\\
    {\bf AC} & \proves \actionA{\aPModel{\aStateS}} (\phi \land \psi) \iff (\actionA{\aPModel{\aStateS}} \phi \land \actionA{\aPModel{\aStateS}} \psi)\\
    {\bf AK} & \proves \actionA{\aPModel{\aStateS}} \necessaryA \phi \iff (\aPrecondition(\aStateS) \implies \necessaryA \bigwedge_{\aStateT \in \aSuccessorsA{\aStateS}} \actionA{\aPModel{\aStateT}} \phi)\\
    {\bf AU} & \proves \actionA{\aPModel{\aStatesT}} \phi \iff \bigwedge_{\aStateT \in \aStatesT} \actionA{\aPModel{\aStateT}} \phi\\
    {\bf R} & \proves \allrefsBs (\phi \implies \psi) \implies (\allrefsBs \phi \implies \allrefsBs \psi)\\
    {\bf RP} & \proves \allrefsBs \pi \iff \pi\\
    {\bf RK} & \proves \somerefsBs \coversA \Gamma_\agentA \iff \bigwedge_{\gamma \in \Gamma_\agentA} \possibleA \somerefsBs \gamma \text{ where } \agentA \in \agentsB\\
    {\bf RComm} & \proves \somerefsBs \coversA \Gamma_\agentA \iff \coversA \{\somerefsBs \gamma \mid \gamma \in \Gamma_\agentA\} \text{ where } \agentA \notin \agentsB\\
    {\bf RDist} & \proves \somerefsBs \bigwedge_{\agentC \in \agentsC} \coversC \Gamma_\agentC \iff \bigwedge_{\agentC \in \agentsC} \somerefsBs \coversC \Gamma_\agentC\\
    {\bf MP}    & \text{From } \proves \phi \implies \psi \text{ and } \proves \phi \text{ infer } \proves \psi\\
    {\bf NecK}  & \text{From } \proves \phi \text{ infer } \proves \necessaryA \phi\\
    {\bf NecA} & \text{From } \proves \phi \text{ infer } \proves \actionA{\aPModel{\aStatesT}} \phi\\
    {\bf NecR} & \text{From } \proves \phi \text{ infer } \proves \allrefsBs \phi
\end{array}
$$
where $\phi, \psi \in \langAaml$, $\agentA \in \agents$, $\aPModel{\aStateS} \in \classAmK$, $\atomP \in \atoms$, $\pi \in \langPl$, $\agentsB, \agentsC \subseteq \agents$, and for every $\agentA \in \agents$: $\Gamma_\agentA \subseteq \langRml$ is a finite set of formulas.
\end{definition}

We note that the axiomatisation \axiomRamlK{} is closed under substitution of equivalents.

\begin{lemma}
Let $\phi, \psi, \chi \in \langAaml$ be formulas and let $\atomP \in \atoms$ be a propositional atom.
If $\proves \psi \iff \chi$ then $\proves \phi[\psi\backslash\atomP] \iff \phi[\chi\backslash\atomP]$.
\end{lemma}

This is shown by combining the reasoning that \axiomAmlK{} and \axiomRmlK{} are closed under substitution of equivalents.

We show that \axiomRamlK{} is sound and complete.

\begin{lemma}\label{raml-k-sound-complete}
The axiomatisation \axiomRamlK{} is sound and strongly complete with respect to the semantics of the logic \logicRamlK{}.
\end{lemma}

\begin{proof}[Proof]
Soundness of the axioms and rules of \axiomAmlK{} and \axiomRmlK{} follow from the same reasoning used to show that they are sound in \logicAmlK{} and \logicRmlK{} respectively.
Alternatively we can show that the axioms and rules of \axiomAmlK{} and \axiomRmlK{} are sound in \logicRamlK{} for formulas from the languages \langAml{} and \langRml{} respectively, as the logics \logicAmlK{} and \logicRmlK{} agree with \logicRamlK{} on all formulas of \langAml{} and \langRml{} respectively.
These restricted axioms are all that is required for the following completeness proof via provably correct translation to work.
After we have shown expressive equivalence between \logicRamlK{} and \logicK{} we can easily show soundness of versions of the axioms and rules of \axiomAmlK{} and \axiomRmlK{} that apply for formulas from the full language \langAaml{} by relying on substitution of equivalents.

Strong completeness follows from essentially the same reasoning used to show the strong completeness of \axiomRmlK{} in Lemma~\ref{rml-k-sound-complete}, using a provably correct translation from \langAaml{} to \langMl{}.
As the action model logic \logicAmlK{} is expressively equivalent to the underlying modal logic \logicK{} using the reduction axioms of \axiomAmlK{} there is a provably correct translation from \langAml{} to \langMl{}.
Likewise, as the refinement model logic \logicRmlK{} is expressively equivalent to the underlying modal logic \logicK{} using the reduction axioms of \axiomRmlK{} there is a provably correct translation from \langRml{} to \langMl{}.
These provably correct translations can be combined into a provably correct translation from \langAaml{} to \langMl{}, by inductively applying the provably correct translation for \logicAmlK{} to subformulas containing action model operators but not refinement quantifiers, and applying the provably correct translation for \logicRmlK{} to subformulas containing refinement quantifiers but not action model operators, relying on closure under substitution of equivalents to allow us to replace such subformulas with equivalent \langMl{} formulas.
\end{proof}

We note that, much like the provably correct translation for \logicRmlK{}, the provably correct translations we have presented here can result in a non-elementary increase in the size compared to the original formula.

The provably correct translation also implies that \logicRamlK{} is expressively equivalent to \logicK{}.

\begin{corollary}\label{raml-k-expressive-equivalence}
The logic \logicRamlK{} is expressively equivalent to the logic \logicK{}.
\end{corollary}

From expressive equivalence we have that \logicRamlK{} is compact and decidable.

\begin{corollary}
The logic \logicRamlK{} is compact.
\end{corollary}

\begin{corollary}
The model-checking and satisfiability problems for the logic \logicRamlK{} are decidable.
\end{corollary}

We note that most results from \logicAmlK{} and \logicRmlK{} generalise to \logicRamlK{} trivially thanks to a combination of \logicRamlK{} agreeing with \logicAmlK{} and \logicRmlK{} on their respective sublanguages, and the expressive equivalence of \logicRamlK{} and \logicK{}.
For example, in Chapter~\ref{rml} we showed that \logicRmlK{} has the Church-Rosser property; that is, $\entails_\logicRmlK \allrefsBs \somerefsBs \phi \implies \somerefsBs \allrefsBs \phi$ for every $\phi \in \langRml$.
By Lemma~\ref{raml-k-rml} we have $\entails_\logicRamlK \allrefsBs \somerefsBs \phi \implies \somerefsBs \allrefsBs \phi$ for every $\phi \in \langRml$.
By Corollary~\ref{raml-k-expressive-equivalence} every $\phi \in \langAaml$ has an equivalent $\phi' \in \langMl \subseteq \langRml$.
Therefore we have $\entails_\logicRamlK \allrefsBs \somerefsBs \phi \implies \somerefsBs \allrefsBs \phi$ for every $\phi \in \langAaml$.

We now move on to our main result, that the action model quantifiers of \logicAamlK{} are equivalent to the refinement quantifiers of \logicRmlK{}.
We show this equivalence by showing that if there exists a refinement where a given formula is satisfied then we can construct a finite action model that results in that formula being satisfied.
The converse we have already shown; if there exists an action model that results in a given formula being satisfied then by Proposition~\ref{action-models-refinements} the result of executing the action model is itself a refinement, so there exists a refinement where the formula is satisfied.

One way of stating our eventual result is as follows: for every $\phi \in \langAaml$, $\kPModel{\kStateS} \in \classK$ if there exists $\kPModelP{\kStateSP} \in \classK$ such that $\kPModel{\kStateS} \simulates \kPModelP{\kStateSP}$ and $\kPModelP{\kStateSP} \entails \phi$ then there exists $\aPModel{\aStateS} \in \classAmK$ such that $\kPModel{\kStateS} \entails \aPrecondition(\aStateS)$ and $\kPModel{\kStateS} \exec \aPModel{\aStateS} \entails \phi$. 
As we have our combined logic \logicRamlK{} for reasoning about refinements and action models, we can restate much of this using refinement action model logic syntax: for every $\phi \in \langAaml$, $\kPModel{\kStateS} \in \classK$ there exists $\aPModel{\aStateS} \in \classAmK$ such that $\kPModel{\kStateS} \entails \somerefs \phi \implies \actionE{\aPModel{\aStateS}} \phi$.
We actually show a stronger result.
This statement allows a different action model for each Kripke model in order to result in the given formula.
However we can show that there is a single action model that will result in the given formula, regardless of the Kripke model that we start with.
We show that: for every $\phi \in \langAaml$ there exists $\aPModel{\aStateS} \in \classAmK$ such that $\entails \actionA{\aPModel{\aStateS}} \phi$ and $\entails \actionE{\aPModel{\aStateS}} \phi \iff \somerefs \phi$.
This statement requires that there be a single action model that will result in the given formula for every Kripke model.
This allows us to use such action models in settings such as the proof theory where formulas are not interpreted with respect to just a single Kripke model.

We show our result using an inductive construction for a given formula.
Our construction is very similar to the constructions used to show the soundness of the axioms {\bf RK}, {\bf RComm}, and {\bf RDist} in \logicRmlK{}.
We reuse the disjunctive normal form we used for \logicRmlK{}, defined in Definition~\ref{dnf}, and we separate our inductive steps into two lemmas for each syntactic case from the disjunctive normal form.

We first show the case where the given formula is a disjunction.

\begin{lemma}\label{aaml-k-choice}
Let $\agentsB \subseteq \agents$, 
let $\phi = \alpha \lor \beta \in \langAaml$, and 
let $\aPModel[\alpha]{\aStatesT[\alpha]} \in \classAmK$ and $\aPModel[\beta]{\aStatesT[\beta]} \in \classAmK$ be action models such that 
$\entails \actionA{\aPModel[\alpha]{\aStatesT[\alpha]}} \alpha$, 
$\entails \actionE{\aPModel[\alpha]{\aStatesT[\alpha]}} \alpha \iff \someactsBs \alpha$, 
$\entails \actionA{\aPModel[\beta]{\aStatesT[\beta]}} \beta$,
$\entails \actionE{\aPModel[\beta]{\aStatesT[\beta]}} \beta \iff \someactsBs \beta$,
for every $\aStateT[\alpha] \in \aStatesT[\alpha]$, $\kPModel{\kStateS} \in \classK$ if $\kPModel{\kStateS} \entails \aPrecondition[\alpha](\aStateT[\alpha])$ then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel[\alpha]{\aStateT[\alpha]}$, and
for every $\aStateT[\beta] \in \aStatesT[\beta]$, $\kPModel{\kStateS} \in \classK$ if $\kPModel{\kStateS} \entails \aPrecondition[\beta](\aStateT[\beta])$ then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel[\beta]{\aStateT[\beta]}$.
Then there exists an action model $\aPModel{\aStatesT} \in \classAmK$ such that 
$\entails \actionA{\aPModel{\aStatesT}} \phi$,
$\entails \actionE{\aPModel{\aStatesT}} \phi \iff \someactsBs \phi$, and
for every $\aStateT \in \aStatesT$, $\kPModel{\kStateS} \in \classK$ if $\kPModel{\kStateS} \entails \aPrecondition(\aStateT)$ then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel{\aStateT}$.
\end{lemma}

\begin{proof}
Without loss of generality we assume that $\aModel[\alpha]$ and $\aModel[\beta]$ are disjoint.
We construct the action model $\aPModelAndTuple{\aStatesT}$ as the disjoint union of $\aModel[\alpha]$ and $\aModel[\beta]$ where:
    \begin{eqnarray*}
        \aStates &=& \aStates[\alpha] \cup \aStates[\beta]\\
        \aAccessibilityA &=& \aAccessibilityA[\alpha] \cup \aAccessibilityA[\beta]\\
        \aPrecondition &=& \aPrecondition[\alpha] \cup \aPrecondition[\beta]\\
        \aStatesT &=& \aStatesT[\alpha] \cup \aStatesT[\beta]
    \end{eqnarray*}
As $\aModel$ is formed by the disjoint union of $\aModel[\alpha]$ and $\aModel[\beta]$ we note that each state of $\aModel[\alpha]$ and $\aModel[\beta]$ is bisimilar to the corresponding state in $\aModel$.

We first show that for every $\aStateT \in \aStatesT$, $\kPModel{\kStateS} \in \classK$ if $\kPModel{\kStateS} \entails \aPrecondition(\aStateT)$ then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel{\aStateT}$.
Let $\gamma \in \{\alpha, \beta\}$, $\aStateT[\gamma] \in \aStatesT[\gamma] \subseteq \aStatesT$, and $\kPModel{\kStateS} \in \classK$ such that $\kPModel{\kStateS} \entails \aPrecondition(\aStateT[\gamma])$.
By construction $\aPrecondition(\aStateT[\gamma]) = \aPrecondition[\gamma](\aStateT[\gamma])$ and so $\kPModel{\kStateS} \entails \aPrecondition[\gamma](\aStateT[\gamma])$. 
By hypothesis then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel[\gamma]{\aStateT[\gamma]}$.
From above $\aPModel{\aStateT[\gamma]} \bisimilar \aPModel[\gamma]{\aStateT[\gamma]}$ and so from Proposition~\ref{action-bisimulation-results} we have that $\kPModel{\kStateS} \exec \aPModel{\aStateT[\gamma]} \bisimilar \kPModel{\kStateS} \exec \aPModel[\gamma]{\aStateT[\gamma]}$.
From Corollary~\ref{bisimilar-refinement} and Proposition~\ref{refinements-preorder} we have that $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel{\aStateT[\gamma]}$.

We next show that $\entails \actionA{\aPModel{\aStatesT}} \phi$.
\begin{eqnarray}
    &&\entails \actionA{\aPModel[\alpha]{\aStatesT[\alpha]}} \alpha \land \actionA{\aPModel[\beta]{\aStatesT[\beta]}} \beta \label{aaml-k-choice-1}\\
    &&\entails \actionA{\aPModel{\aStatesT[\alpha]}} \alpha \land \actionA{\aPModel{\aStatesT[\beta]}} \beta \label{aaml-k-choice-2}\\
    &&\entails \actionA{\aPModel{\aStatesT[\alpha]}} (\alpha \lor \beta) \land \actionA{\aPModel{\aStatesT[\beta]}} (\alpha \lor \beta) \label{aaml-k-choice-3}\\
    &&\entails \actionA{\aPModel{\aStatesT}} (\alpha \lor \beta) \label{aaml-k-choice-4}
\end{eqnarray}
(\ref{aaml-k-choice-1}) follows from hypothesis;
(\ref{aaml-k-choice-2}) follows from the above note that $\aPModel[\alpha]{\aStatesT[\alpha]} \bisimilar \aPModel{\aStatesT[\alpha]}$ and $\aPModel[\beta]{\aStatesT[\beta]} \bisimilar \aPModel{\aStatesT[\beta]}$ and Proposition~\ref{aml-bisimilar-actions};
(\ref{aaml-k-choice-3}) follows from propositional disjunction introduction; and
(\ref{aaml-k-choice-4}) follows from \axiomRamlK{} axiom {\bf AU}, as $\aStatesT = \aStatesT[\alpha] \cup \aStatesT[\beta]$.

Finally we show that $\entails \actionE{\aPModel{\aStatesT}} \phi \iff \someactsBs \phi$.
\begin{eqnarray}
    &&\entails \someactsBs (\alpha \lor \beta) \implies (\someactsBs \alpha \lor \someactsBs \beta) \label{aaml-k-choice-5}\\
    &&\entails \someactsBs (\alpha \lor \beta) \implies (\actionE{\aPModel[\alpha]{\aStatesT[\alpha]}} \alpha \lor \actionE{\aPModel[\beta]{\aStatesT[\beta]}} \beta) \label{aaml-k-choice-6}\\
    &&\entails \someactsBs (\alpha \lor \beta) \implies (\actionE{\aPModel{\aStatesT[\alpha]}} \alpha \lor \actionE{\aPModel{\aStatesT[\beta]}} \beta) \label{aaml-k-choice-7}\\
    &&\entails \someactsBs (\alpha \lor \beta) \implies (\actionE{\aPModel{\aStatesT[\alpha]}} (\alpha \lor \beta) \lor \actionE{\aPModel{\aStatesT[\beta]}} (\alpha \lor \beta)) \label{aaml-k-choice-8}\\
    &&\entails \someactsBs (\alpha \lor \beta) \implies \actionE{\aPModel{\aStatesT}} (\alpha \lor \beta) \label{aaml-k-choice-9}
\end{eqnarray}
(\ref{aaml-k-choice-5}) follows from \axiomRamlK{} axiom {\bf R};
(\ref{aaml-k-choice-6}) follows from hypothesis;
(\ref{aaml-k-choice-7}) follows from the above note that $\aPModel[\alpha]{\aStatesT[\alpha]} \bisimilar \aPModel{\aStatesT[\alpha]}$ and $\aPModel[\beta]{\aStatesT[\beta]} \bisimilar \aPModel{\aStatesT[\beta]}$ and Proposition~\ref{aml-bisimilar-actions};
(\ref{aaml-k-choice-8}) follows from propositional disjunction introduction; and
(\ref{aaml-k-choice-9}) follows from \axiomRamlK{} axiom {\bf AU}, as $\aStatesT = \aStatesT[\alpha] \cup \aStatesT[\beta]$.

The converse, that $\entails \actionE{\aPModel{\aStatesT}} \phi \implies \someactsBs \phi$ follows from a simple semantic argument.
Let $\kPModel{\kStateS} \in \classK$ and suppose that $\kPModel{\kStateS} \entails \actionE{\aPModel{\aStatesT}} \phi$.
Then there exists $\aStateS \in \aStatesT$ such that $\kPModel{\kStateS} \entails \aPrecondition(\aStateS)$ and $\kPModel{\kStateS} \exec \aPModel{\aStateS} \entails \phi$.
From above, $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel{\aStateS}$, so $\kPModel{\kStateS} \entails \someactsBs \phi$.
Therefore $\entails \actionE{\aPModel{\aStatesT}} \phi \implies \someactsBs \phi$.
\end{proof}

We next show the case where the given formula is a conjunction of a propositional formula and cover operators.

\begin{lemma}\label{aaml-k-covers}
Let $\agentsB, \agentsC \subseteq \agents$, 
let $\phi = \pi \land \bigwedge_{\agentC \in \agentsC} \coverC \Gamma_\agentC \in \langAaml$ where $\pi \in \langPl$, and 
for every $\agentC \in \agentsC$, $\gamma \in \Gamma_\agentsC$
let $\aPModelAndTuple[\gamma]{\aStatesT[\gamma]} \in \classAmK$ be a $\agentsB$-action model such that 
$\entails \actionA{\aPModel[\gamma]{\aStatesT[\gamma]}} \gamma$,
$\entails \actionE{\aPModel[\gamma]{\aStatesT[\gamma]}} \gamma \iff \someactsBs \gamma$, and
for every $\aStateT[\gamma] \in \aStatesT[\gamma]$, $\kPModel{\kStateS} \in \classK$ if $\kPModel{\kStateS} \entails \aPrecondition[\gamma](\aStateT[\gamma])$ then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel[\gamma]{\aStateT[\gamma]}$.
Then there exists a $\agentsB$-action model $\aPModel{\aStatesT} \in \classAmK$ such that 
$\entails \actionA{\aPModel{\aStatesT}} \phi$, and 
$\entails \actionE{\aPModel{\aStatesT}} \phi \iff \someactsBs \phi$.
for every $\aStateT \in \aStatesT$, $\kPModel{\kStateS} \in \classK$ if $\kPModel{\kStateS} \entails \aPrecondition(\aStateT)$ then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel{\aStateT}$.
\end{lemma}

\pagebreak

\begin{proof}
Without loss of generality we assume that each $\aModel[\gamma]$ is pair-wise disjoint.

We construct the action model $\aPModelAndTuple{\aStateTest}$ where:
\begin{eqnarray*}
    \aStates &=& \{\aStateTest, \aStateSkip\} \cup \bigcup_{\agentC \in \agentsC, \gamma \in \Gamma_\agentC} \aStates[\gamma]\\
    \aAccessibilityC &=& \{(\aStateTest, \aStateT[\gamma]) \mid \gamma \in \Gamma_\agentC, \aStateT[\gamma] \in \aStatesT[\gamma]\} \cup \{(\aStateSkip, \aStateSkip)\} \cup \bigcup_{\agentD \in \agentsC, \gamma \in \Gamma_\agentD} \aAccessibilityC[\gamma]\\
    \aAccessibilityB &=& \{(\aStateTest, \aStateSkip), (\aStateSkip, \aStateSkip)\} \cup \bigcup_{\agentC \in \agentsC, \gamma \in \Gamma_\agentC} \aAccessibilityB[\gamma]\\
    \aPrecondition &=& \{(\aStateTest, \someactsBs \phi), (\aStateSkip, \top)\} \cup \bigcup_{\agentC \in \agentsC, \gamma \in \Gamma_\agentC} \aPrecondition[\gamma]
\end{eqnarray*}
where $\agentC \in \agentsC$ and $\agentB \in \agents \setminus \agentsC$.

\begin{figure}
    \caption{A schematic of the constructed action model.}\label{aaml-k-construction}
    \centering
    \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=7em,thick]

    \node (test) {$\someactsBs \phi$};
    \node (mTd) [below=7em of test] {$\cdots$};
    \node (mTc1gn) [left=2.5em of mTd] {$\aPModel[\gamma^{\agentC_1}]{\aStatesT[\gamma^{\agentC_1}_1]}$};
    \node (mTc1d) [left=2.5em of mTc1gn] {$\cdots$};
    \node (mTc1g1) [left=2.5em of mTc1d] {$\aPModel[\gamma^{\agentC_1}]{\aStatesT[\gamma^{\agentC_1}_{n_1}]}$};
    \node (mTcmg1) [right=2.5em of mTd] {$\aPModel[\gamma^{\agentC_m}]{\aStatesT[\gamma^{\agentC_m}_1]}$};
    \node (mTcmd) [right=2.5em of mTcmg1] {$\cdots$};
    \node (mTcmgn) [right=2.5em of mTcmd] {$\aPModel[\gamma^{\agentC_m}]{\aStatesT[\gamma^{\agentC_m}_{n_m}]}$};
    \node (skip) [above=7em of test] {$\top$};

      \path[every node/.style={font=\sffamily\small},->]
        (skip) edge [loop right] node {$\agents$} (skip)
        (test) edge node {$\agentC_1$} (mTc1g1)
               edge node {$\agentC_1$} (mTc1gn)
               edge [swap] node {$\agentC_m$} (mTcmg1)
               edge [swap] node {$\agentC_m$} (mTcmgn)
               edge node {$\agents \setminus \{\agentC_1, \dots, \agentC_m\}$} (skip);
    \end{tikzpicture}
\end{figure}

A schematic of the action model $\aPModel{\aStateTest}$ and an overview of our construction is shown in Figure~\ref{aaml-k-construction}.
Here we can see that $\aPModel{\aStateTest}$ is formed by taking each action model $\aPModel[\gamma]{\aStatesT[\gamma]}$ for $\agentC \in \agentsC$, $\gamma \in \Gamma_\agentC$ and combining them into a single model with a new state with the precondition $\someactsBs \phi$.
This is similar to the construction used to show the soundness of the axiom {\bf RK} in \logicRmlK{}, but it deals with all agents in $\agentsC$ at once, rather than a single agent at a time.

We note for every $\agentC \in \agentsC$, $\gamma \in \Gamma_\agentC$, $\aStateS[\gamma] \in \aStates[\gamma]$ that $\aPModel{\aStateS[\gamma]} \bisimilar \aPModel[\gamma]{\aStateS[\gamma]}$, as by construction $\aModel$ contains the disjoint union of each $\aModel[\gamma]$ and no outward-facing edges are added to any state from $\aStates[\gamma]$ in $\aModel$.

We first show that $\entails \actionA{\aPModel{\aStateTest}} \phi$, in several parts.
We note that from the definition of the cover operator:
$$
\phi = \pi \land \bigwedge_{\agentC \in \agentsC} (\necessaryC \bigvee_{\gamma \in \Gamma_\agentC} \gamma \land \bigwedge_{\gamma \in \Gamma_\agentC} \possibleC \gamma)
$$
Thus we will show individually that:
\begin{enumerate}
\item $\entails \actionA{\aPModel{\aStateTest}} \pi$
\item $\entails \actionA{\aPModel{\aStateTest}} \necessaryC \bigvee_{\gamma \in \Gamma_\agentC} \gamma$, for every $\agentC \in \agentsC$
\item $\entails \actionA{\aPModel{\aStateTest}} \bigwedge_{\gamma \in \Gamma_\agentC} \possibleC \gamma$, for every $\agentC \in \agentsC$
\end{enumerate}

We show that $\entails \actionA{\aPModel{\aStateTest}} \pi$.
\begin{eqnarray}
    && \entails \phi \implies \pi \label{aaml-covers-1}\\
    && \entails \lnot \pi \implies \lnot \phi \label{aaml-covers-2}\\
    && \entails  \allactsBs (\lnot \pi \implies \lnot \phi) \label{aaml-covers-3}\\
    && \entails  \allactsBs \lnot \pi \implies \allactsBs \lnot \phi \label{aaml-covers-4}\\
    && \entails  \someactsBs \phi \implies \someactsBs \pi \label{aaml-covers-5}\\
    && \entails  \aPrecondition(\aStateTest) \implies \pi \label{aaml-covers-6}\\
    && \entails  \actionA{\aPModel{\aStateTest}} \pi \label{aaml-covers-7}
\end{eqnarray}
(\ref{aaml-covers-1}) and
(\ref{aaml-covers-2}) follow from propositional reasoning;
(\ref{aaml-covers-3}) follows from \axiomRamlK{} rule {\bf NecR};
(\ref{aaml-covers-4}) follows from \axiomRamlK{} axiom {\bf R};
(\ref{aaml-covers-5}) follows from the definition of $\someactsBs$;
(\ref{aaml-covers-6}) follows from the construction of $\aPModel{\aStateTest}$ and \axiomRamlK{} axiom{\bf RP}; and
(\ref{aaml-covers-7}) follows from \axiomRamlK{} axiom {\bf AP}.

We show that $\entails \actionA{\aPModel{\aStateTest}} \necessaryC \bigvee_{\gamma \in \Gamma_\agentC} \gamma$, for every $\agentC \in \agentsC$.
Let $\agentC \in \agentsC$.
\begin{eqnarray}
    && \entails \actionA{\aPModel[\gamma]{\aStatesT[\gamma]}} \gamma \text{ for every } \gamma \in \Gamma_\agentC \label{aaml-covers-8}\\
    && \entails \actionA{\aPModel{\aStatesT[\gamma]}} \gamma \text{ for every } \gamma \in \Gamma_\agentC \label{aaml-covers-9}\\
    && \entails \bigwedge_{\aStateT \in \aStatesT[\gamma]} \actionA{\aPModel[\gamma]{\aStateT}} \gamma \text{ for every } \gamma \in \Gamma_\agentC \label{aaml-covers-10}\\
    && \entails \necessaryC \bigwedge_{\aStateT \in \aStatesT[\gamma]} \actionA{\aPModel[\gamma]{\aStateT}} \gamma \text{ for every } \gamma \in \Gamma_\agentC \label{aaml-covers-11}\\
    && \entails \bigwedge_{\gamma \in \Gamma_\agentC} \necessaryC \bigwedge_{\aStateT \in \aStatesT[\gamma]} \actionA{\aPModel[\gamma]{\aStateT}} \gamma \label{aaml-covers-12}\\
    && \entails \bigwedge_{\gamma \in \Gamma_\agentC} \bigwedge_{\aStateT \in \aStatesT[\gamma]} \necessaryC \actionA{\aPModel[\gamma]{\aStateT}} \gamma \label{aaml-covers-13}\\
    && \entails \bigwedge_{\gamma \in \Gamma_\agentC} \bigwedge_{\aStateT \in \aStatesT[\gamma]} \necessaryC \actionA{\aPModel[\gamma]{\aStateT}} \bigvee_{\gamma' \in \Gamma_\agentC} \gamma' \label{aaml-covers-14}\\
    && \entails \bigwedge_{\aStateT \in \aSuccessorsC{\aStateTest}} \necessaryC \actionA{\aPModel[\gamma]{\aStateT}} \bigvee_{\gamma \in \Gamma_\agentC} \gamma \label{aaml-covers-15}\\
    && \entails \aPrecondition(\aStateTest) \implies \bigwedge_{\aStateT \in \aSuccessorsC{\aStateTest}} \necessaryC \actionA{\aPModel{\aStateT}} \bigvee_{\gamma \in \Gamma_\agentC} \gamma \label{aaml-covers-16}\\
    && \entails \actionA{\aPModel{\aStateTest}} \necessaryC \bigvee_{\gamma \in \Gamma_\agentC} \gamma \label{aaml-covers-17}
\end{eqnarray}
(\ref{aaml-covers-8}) follows from hypothesis;
(\ref{aaml-covers-9}) follows from the above note that $\aPModel[\gamma]{\aStateT[\gamma]} \bisimilar \aPModel{\aStateT[\gamma]}$;
(\ref{aaml-covers-10}) follows from \axiomRamlK{} axiom {\bf AU};
(\ref{aaml-covers-14}) follows from propositional disjunction introduction;
(\ref{aaml-covers-15}) follows from the construction of $\aModel$;
(\ref{aaml-covers-16}) follows from propositional disjunction introduction; and
(\ref{aaml-covers-17}) follows from \axiomRamlK{} axiom {\bf AK}.

We show that $\entails \actionA{\aPModel{\aStateTest}} \bigwedge_{\gamma \in \Gamma_\agentC} \possibleC \gamma$, for every $\agentC \in \agentsC$.
Let $\agentC \in \agentsC$.

Suppose that $\agentC \in \agentsB$.
Then:
\begin{eqnarray}
    &&\entails \someactsBs \phi \implies \someactsBs \coversC \Gamma_\agentC \label{aaml-covers-18}\\
    &&\entails \someactsBs \phi \implies \bigwedge_{\gamma \in \Gamma_\agentC} \possibleC \someactsBs \gamma \label{aaml-covers-19}
\end{eqnarray}
(\ref{aaml-covers-18}) follows from \axiomRamlK{} axiom {\bf R} and rule {\bf NecR}; and
(\ref{aaml-covers-19}) follows from \axiomRamlK{} axiom {\bf RK}.

Suppose that $\agentC \notin \agentsB$.
Then:
\begin{eqnarray}
    &&\entails \someactsBs \phi \implies \someactsBs \coversC \Gamma_\agentC \label{aaml-covers-20}\\
    &&\entails \someactsBs \phi \implies \coversC \{\someactsBs \gamma \mid \gamma \in \Gamma_\agentC \}\label{aaml-covers-21}\\
    &&\entails \someactsBs \phi \implies \bigwedge_{\gamma \in \Gamma_\agentC} \possibleC \someactsBs \gamma \label{aaml-covers-22}
\end{eqnarray}
(\ref{aaml-covers-20}) follows from \axiomRamlK{} axiom {\bf R} and rule {\bf NecR};
(\ref{aaml-covers-21}) follows from \axiomRamlK{} axiom {\bf RComm}; and
(\ref{aaml-covers-22}) follows from the definition of the cover operator.

So we have that $\entails \someactsBs \phi \implies \bigwedge_{\gamma \in \Gamma_\agentC} \possibleC \gamma$.
Then:
\begin{eqnarray}
    && \entails \someactsBs \phi \implies \bigwedge_{\gamma \in \Gamma_\agentC} \possibleC \someactsBs \gamma \label{aaml-covers-23}\\
    && \entails \someactsBs \phi \implies \bigwedge_{\gamma \in \Gamma_\agentC} \possibleC \actionE{\aPModel[\gamma]{\aStatesT[\gamma]}} \gamma \label{aaml-covers-24}\\
    && \entails \someactsBs \phi \implies \bigwedge_{\gamma \in \Gamma_\agentC} \possibleC \actionE{\aPModel{\aStatesT[\gamma]}} \gamma \label{aaml-covers-25}\\
    && \entails \someactsBs \phi \implies \bigwedge_{\gamma \in \Gamma_\agentC} \possibleC \bigvee_{\aStateT \in \aStatesT[\gamma]} \actionE{\aPModel{\aStateT}} \gamma \label{aaml-covers-26}\\
    && \entails \someactsBs \phi \implies \bigwedge_{\gamma \in \Gamma_\agentC} \possibleC \bigvee_{\aStateT \in \aSuccessorsC{\aStateTest}} \actionE{\aPModel{\aStateT}} \gamma \label{aaml-covers-27}\\
    && \entails \bigwedge_{\gamma \in \Gamma_\agentC} \left(\someactsBs \phi \implies \possibleC \bigvee_{\aStateT \in \aSuccessorsC{\aStateTest}} \actionE{\aPModel{\aStateT}} \gamma\right) \label{aaml-covers-28}\\
    && \entails \bigwedge_{\gamma \in \Gamma_\agentC} \actionA{\aPModel{\aStateTest}} \possibleC \gamma \label{aaml-covers-29}
\end{eqnarray}
(\ref{aaml-covers-23}) follows from above;
(\ref{aaml-covers-24}) follows from hypothesis;
(\ref{aaml-covers-25}) follows from the above note that $\aPModel[\gamma]{\aStateT[\gamma]} \bisimilar \aPModel{\aStateT[\gamma]}$;
(\ref{aaml-covers-26}) follows from \axiomRamlK{} axiom {\bf AU};
(\ref{aaml-covers-27}) follows from the construction of $\aModel$ and propositional disjunction introduction;
(\ref{aaml-covers-28}) follows from propositional reasoning; and
(\ref{aaml-covers-29}) follows from \axiomRamlK{} axiom {\bf AK}.

Therefore $\entails \actionA{\aPModel{\aStateTest}} \phi$.

Next we show that $\entails \actionE{\aPModel{\aStateTest}} \phi \iff \someactsBs \phi$. 
This is straight-forward, given what we have shown above.
\begin{eqnarray}
    && \entails \actionE{\aPModel{\aStateTest}} \phi \iff (\aPrecondition(\aStateTest) \land \actionA{\aPModel{\aStateTest}} \phi) \label{aaml-covers-30}\\
    && \entails \actionE{\aPModel{\aStateTest}} \phi \iff \aPrecondition(\aStateTest) \label{aaml-covers-31}\\
    && \entails \actionE{\aPModel{\aStateTest}} \phi \iff \someactsBs \phi \label{aaml-covers-32}
\end{eqnarray}
(\ref{aaml-covers-30}) follows from the definition of $\actionE{}$;
(\ref{aaml-covers-31}) follows from $\entails \actionA{\aPModel{\aStateTest}} \phi$ above;
(\ref{aaml-covers-32}) follows from the construction of $\aModel$.

Therefore $\entails \actionE{\aPModel{\aStateTest}} \phi \iff \someactsBs \phi$.

We next show that for every $\kPModel{\kStateS} \in \classK$ if $\kPModel{\kStateS} \entails \aPrecondition(\aStateTest)$ then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel{\aStateTest}$.
Let $\kPModel{\kStateS} \in \classK$ such that $\kPModel{\kStateS} \entails \aPrecondition(\aStateTest)$.
For every $\agentC \in \agentsC$, $\gamma \in \Gamma_\agentC$, $\aStateT[\gamma^\agentC] \in \aStatesT[\gamma^\agentC]$, $\kStateT \in \kSuccessorsC{\kStateS}$ such that $\kPModel{\kStateT} \entails \aPrecondition[\agentC,\gamma](\aStateT[\agentC,\gamma])$ we have that $\kPModel{\kStateT} \simulatesBs \kPModel{\kStateT} \exec \aPModel[\gamma^\agentC]{\aStateT[\gamma^\agentC]}$.
From above $\aPModel[\gamma^\agentC]{\aStateT[\gamma^\agentC]} \bisimilar \aPModel{\aStateT[\gamma^\agentC]}$ and so by Proposition~\ref{action-bisimulation-results} we have that $\kPModel{\kStateT} \exec \aPModel[\gamma^\agentC]{\aStateT[\gamma^\agentC]} \bisimilar \kPModel{\kStateT} \exec \aPModel{\aStateT[\gamma^\agentC]}$.
From Corollary~\ref{bisimilar-refinement} and Proposition~\ref{refinements-preorder} we have that $\kPModel{\kStateT} \simulatesBs \kPModel{\kStateT} \exec \aPModel{\aStateT[\gamma^\agentC]}$ (say via a $\agentsB$-refinement $\refinement^{\kStateT, \aStateT[\gamma^\agentC]}$).

Let $\kPModelP{(\kStateS, \aStateTest)} = \kPModel{\kStateS} \exec \aPModel{\aStateTest}$.
We define $\refinement \subseteq \kStates \times \kStatesP$ where:
\begin{eqnarray*}
\refinement &=& 
\{(\kStateS, (\kStateS, \aStateTest))\} \cup 
\{(\kStateT, (\kStateT, \aStateSkip)) \mid \kStateT \in \kStates\}  \\&&\quad \cup
\bigcup \{\refinement^{\kStateT, \aStateT[\gamma^\agentC]} \mid \agentC \in \agentsC, \gamma \in \Gamma_\agentC, \aStateT[\gamma^\agentC] \in \aStatesT[\gamma^\agentC], \kStateT \in \kSuccessorsC{\kStateT}, \kPModel{\kStateT} \entails \aPrecondition(\aStateT[\gamma^\agentC])\}
\end{eqnarray*}

We show that $\refinement$ is a $\agentsB$-refinement from $\kPModel{\kStateS}$ to $\kPModelP{(\kStateS, \aStateTest)}$.
Let $\atomP \in \atoms$, $\agentA \in \agents$ and $\agentD \in \agents \setminus \agentsB$.
We show by cases that the relationships in $\refinement$ satisfy the conditions {\bf atoms-$\atomP$}, {\bf forth-$\agentD$}, and {\bf back-$\agentA$}.

\begin{description}
    \item[{Case $(\kStateS, (\kStateS, \aStateTest)) \in \refinement$:}]\hfill
        \begin{description}
            \item[atoms-$\atomP$]
                By construction $\kStateS \in \kValuation(\atomP)$ if and only if $(\kStateS, \aStateTest) \in \kValuationP(\atomP)$.
            \item[forth-$\agentD$]
                Suppose that $\agentD \in \agentsC$.
                Let $\kStateT \in \kSuccessorsD{\kStateS}$.
                By hypothesis $\kPModel{\kStateS} \entails \someactsBs (\pi \land \bigwedge_{\agentC \in \agentsC} \coversC \Gamma_\agentC)$, and in particular $\kPModel{\kStateS} \entails \someactsBs \coversD \Gamma_\agentD$.
                As $\agentD \neq \agentsB$, by the \axiomRamlK{} axiom {\bf RComm} we have that $\kPModel{\kStateS} \entails \coversD \{\someactsBs \gamma' \mid \gamma' \in \Gamma_\agentD\}$ and by the definition of the cover operator we have that $\kPModel{\kStateS} \entails \necessaryD \bigvee_{\gamma' \in \Gamma_\agentD} \someactsBs \gamma'$ so there exists $\gamma' \in \Gamma_\agentD$ such that $\kPModel{\kStateT} \entails \someactsBs \gamma'$.
                By hypothesis $\entails \someactsBs \gamma' \implies \actionE{\aPModel[\agentC, \gamma']{\aStatesT[\agentC, \gamma']}} \gamma'$ so there exists $\aStateT[\agentC, \gamma'] \in \aStatesT[\agentC, \gamma']$ such that $\kPModel{\kStateT} \entails \aPrecondition[\agentC, \gamma'](\aStateT[\agentC, \gamma'])$.
                By construction $\aStateT[\agentC, \gamma'] \in \aSuccessorsD{\aStateTest}$ and $\aPrecondition(\aStateT[\agentC, \gamma']) = \aPrecondition[\agentC, \gamma'](\aStateT[\agentC, \gamma'])$ so $\kPModel{\kStateT} \entails \aPrecondition(\aStateT[\agentC, \gamma'])$, $(\kStateT, \aStateT[\agentC, \gamma']) \in \kSuccessorsPD{(\kStateS, \aStateTest)}$, and $(\kStateT, (\kStateT, \aStateT[\agentC, \gamma'])) \in \refinement^{\kStateT, \aStateT[\agentC, \gamma']} \subseteq \refinement$.

                Suppose that $\agentD \notin \agentsC$.
                Let $\kStateT \in \kSuccessorsD{\kStateS}$.
                By construction $\aStateSkip \in \aSuccessorsD{\aStateTest}$ and $\kPModel{\kStateT} \entails \aPrecondition(\aStateSkip)$, so $(\kStateT, \aStateSkip) \in \kSuccessorsPD{(\kStateS, \aStateTest)}$ and $(\kStateT, (\kStateT, \aStateSkip)) \in \refinement$.
            \item[back-$\agentA$]
                Suppose that $\agentA \in \agentsC$.
                Let $(\kStateT, \aStateT[\agentA, \gamma]) \in \kSuccessorsPA{(\kStateS, \aStateTest)}$ where $\gamma \in \Gamma_\agentA$ and $\aStateT[\agentA, \gamma] \in \aStatesT[\agentA, \gamma]$.
                By construction $\kStateT \in \kSuccessorsA{\kStateS}$ and $\kPModel{\kStateT} \entails \aPrecondition(\aStateT[\agentA, \gamma])$ so by hypothesis $(\kStateT, (\kStateT, \aStateT[\agentA, \gamma])) \in \refinement^{\kStateT, \aStateT[\gamma^\agentC]} \subseteq \refinement$.
                Suppose that $\agentA \notin \agentsC$.
                Let $(\kStateT, \aStateSkip) \in \kSuccessorsPA{(\kStateS, \aStateTest)}$.
                By construction $\kStateT \in \kSuccessorsA{\kStateS}$ and $(\kStateT, (\kStateT, \aStateSkip)) \in \refinement$.
        \end{description}
    \item[{Case $(\kStateT, (\kStateT, \aStateSkip)) \in \refinement$ where $\kStateT \in \kStates$:}] \hfill
        \begin{description}
            \item[atoms-$\atomP$]
                By construction $\kStateT \in \kValuation(\atomP)$ if and only if $(\kStateT, \aStateSkip) \in \kValuationP(\atomP)$.
            \item[forth-$\agentD$]
                Let $\kStateU \in \kSuccessorsD{\kStateT}$.
                By construction $\aStateSkip \in \aSuccessorsD{\aStateSkip}$ and $\kPModel{\kStateU} \entails \aPrecondition(\aStateSkip)$, so $(\kStateU, \aStateSkip) \in \kSuccessorsPD{(\kStateT, \aStateSkip)}$ and $(\kStateU, (\kStateU, \aStateSkip)) \in \refinement$.
            \item[back-$\agentA$]
                Let $(\kStateU, \aStateSkip) \in \kSuccessorsPA{(\kStateT, \aStateSkip)}$.
                By construction $\kStateU \in \kSuccessorsA{\kStateT}$ \\and $(\kStateU, (\kStateU, \aStateSkip)) \in \refinement$.
        \end{description}
    \item[{Case $(\kStateT, \kStateTP) \in \refinement^{\kStateT, \aStateT[\gamma^\agentC]} \subseteq \refinement$ where $\agentC \in \agentsC$, $\gamma \in \Gamma_\agentC$, $\aStateT[\gamma^\agentC] \in \aStatesT[\gamma^\agentC]$, $\kStateT \in \kStates$, and $\kPModel{\kStateT} \entails \aPrecondition(\aStateT[\gamma^\agentC])$:}]\hfill
        \begin{description}
            \item[atoms-$\atomP$]
                By {\bf atoms-$\atomP$} for $\refinement^{\kStateT, \aStateT[\gamma^\agentC]}$ we have that $\kStateT \in \kValuation(\atomP)$ if and only if $\kStateTP \in \kValuationP(\atomP)$.
            \item[forth-$\agentD$]
                Let $\kStateU \in \kSuccessorsD{\kStateT}$.
                By {\bf forth-$\agentD$} for $\refinement^{\kStateT, \aStateT[\gamma^\agentC]}$ there exists $\kStateUP \in \kSuccessorsPD{\kStateTP}$ such that $(\kStateU, \kStateUP) \in \refinement^{\kStateT, \aStateT[\gamma^\agentC]} \subseteq \refinement$.
            \item[back-$\agentA$]
                Let $\kStateUP \in \kSuccessorsPA{\kStateTP}$.
                By {\bf back-$\agentA$} for $\refinement^{\kStateT, \aStateT[\gamma^\agentC]}$ there exists $\kStateU \in \kSuccessorsA{\kStateT}$ such that $(\kStateU, \kStateUP) \in \refinement^{\kStateT, \aStateT[\gamma^\agentC]} \subseteq \refinement$.
        \end{description}
\end{description}

Therefore $\refinement$ is a $\agentsB$-refinement and $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel{\aStateTest}$.

\end{proof}

We combine the two previous lemmas into an inductive construction that works for all formulas.

\begin{theorem}\label{aaml-k-synthesis}
Let $\agentsB \subseteq \agents$ and let $\phi \in \langAaml$.
There exists an action model $\aPModelAndTuple{\aStatesT} \in \classAmK$ such that 
$\entails \actionA{\aPModel{\aStatesT}} \phi$,
$\entails \actionE{\aPModel{\aStatesT}} \phi \iff \someactsBs \phi$, and
for every $\aStateT \in \aStatesT$, $\kPModel{\kStateS} \in \classK$ if $\kPModel{\kStateS} \entails \aPrecondition(\aStateT)$ then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel{\aStateT}$.
\end{theorem}

\begin{proof}
Without loss of generality, by Corollary~\ref{raml-k-expressive-equivalence} we may assume that $\phi \in \langMl$ and by Lemma~\ref{dnf-equivalent} we may further assume that $\phi$ is in disjunctive normal form.
Then we proceed by induction on the structure of $\phi$.  
Suppose that $\phi = \pi \land \bigwedge_{\agentC \in \agentsC} \Gamma_\agentC$ where $\pi \in \langPl$, $\agentsC \subseteq \agents$ and for every $\agentC \in \agentsC$, $\Gamma_\agentC \subseteq \langMl$ is a finite set of modal formulas.
We note that the base case for the induction occurs when for every $\agentC \in \agentsC$, $\Gamma_\agentC = \emptyset$.
By the induction hypothesis for every $\agentC \in \agentsC$, $\gamma \in \Gamma_\agentC$ there exists 
an action model $\aPModel[\gamma]{\aStatesT[\gamma]} \in \classAmK$ such that
$\entails \actionA{\aPModel[\gamma]{\aStatesT[\gamma]}} \gamma$,
$\entails \actionE{\aPModel[\gamma]{\aStatesT[\gamma]}} \gamma \iff \someactsBs \gamma$, and
for every $\aStateT[\gamma] \in \aStatesT[\gamma]$, $\kPModel{\kStateS} \in \classK$ if $\kPModel{\kStateS} \entails \aPrecondition[\gamma](\aStateT[\gamma])$ then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel[\gamma]{\aStateT[\gamma]}$.
By Lemma~\ref{aaml-k-covers} there exists a $\agentsB$-action model $\aPModel{\aStatesT} \in \classAmK$ such that 
$\entails \actionA{\aPModel{\aStatesT}} \phi$,
$\entails \actionE{\aPModel{\aStatesT}} \phi \iff \someactsBs \phi$, and
for every $\aStateT \in \aStatesT$, $\kPModel{\kStateS} \in \classK$ if $\kPModel{\kStateS} \entails \aPrecondition(\aStateT)$ then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel{\aStateT}$.

Suppose that $\phi = \alpha \lor \beta$ where $\alpha, \beta \in \langMl$.
By the induction hypothesis there exists $\agentsB$-action models
$\aPModel[\alpha]{\aStatesT[\alpha]} \in \classAmK$ and $\aPModel[\beta]{\aStatesT[\beta]} \in \classAmK$ such that 
$\entails \actionA{\aPModel[\alpha]{\aStatesT[\alpha]}} \alpha$, 
$\entails \actionE{\aPModel[\alpha]{\aStatesT[\alpha]}} \alpha \iff \someactsBs \alpha$, 
$\entails \actionA{\aPModel[\beta]{\aStatesT[\beta]}} \beta$,
$\entails \actionE{\aPModel[\beta]{\aStatesT[\beta]}} \beta \iff \someactsBs \beta$,
for every $\aStateT[\alpha] \in \aStatesT[\alpha]$, $\kPModel{\kStateS} \in \classK$ if $\kPModel{\kStateS} \entails \aPrecondition[\alpha](\aStateT[\alpha])$ then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel[\alpha]{\aStateT[\alpha]}$, and
for every $\aStateT[\beta] \in \aStatesT[\beta]$, $\kPModel{\kStateS} \in \classK$ if $\kPModel{\kStateS} \entails \aPrecondition[\beta](\aStateT[\beta])$ then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel[\beta]{\aStateT[\beta]}$.
By Lemma~\ref{aaml-k-choice} there exists a $\agentsB$-action model $\aPModel{\aStatesT} \in \classAmK$ such that 
$\entails \actionA{\aPModel{\aStateS}} \phi$,
$\entails \actionE{\aPModel{\aStateS}} \phi \iff \someactsBs \phi$, and
for every $\aStateT \in \aStatesT$, $\kPModel{\kStateS} \in \classK$ if $\kPModel{\kStateS} \entails \aPrecondition(\aStateT)$ then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel{\aStateT}$.
\end{proof}

Given this result we can show that the logics \logicAamlK{} and \logicRamlK{} agree on all \langAaml{} formulas.

\begin{theorem}\label{aaml-k-semantics-equivalent}
The semantics of \logicAamlK{} and the semantics of \logicRamlK{} agree on all formulas of \langAaml{}.
That is, for every $\phi \in \langAaml$, $\kPModel{\kStateS} \in \classK$: $\kPModel{\kStateS} \entails_\logicAamlK \phi$ if and only if $\kPModel{\kStateS} \entails_\logicRamlK \phi$.
\end{theorem}

\begin{proof}
Let $\phi \in \langAaml$.
We show by induction on the structure of $\phi$ that for every $\kPModel{\kStateS} \in \classK$, $\kPModel{\kStateS} \entails_\logicAamlK \phi$ if and only $\kPModel{\kStateS} \entails_\logicRamlK \phi$.
The cases where $\phi = \atomP$, $\phi = \lnot \psi$,  $\phi = \psi \land \chi$, $\phi = \necessaryA \psi$ or $\phi = \actionA{\aPModel{\aStateS}} \psi$ where $\atomP \in \atoms$ and $\psi, \chi \in \langAaml$ follow directly from the semantics of \logicAamlK{} and \logicRamlK{}.

Suppose that $\phi = \someactsBs \psi$ where $\psi \in \langAaml$. 
We will show that $\kPModel{\kStateS} \entails_\logicAamlK \someactsBs \psi$ if and only if $\kPModel{\kStateS} \entails_\logicRamlK \someactsBs \psi$.

Suppose that $\kPModel{\kStateS} \entails_\logicAamlK \someactsBs \psi$.
Then there exists an action model $\aPModelAndTuple{\aStateS} \in \aSignatureFamily$ such that $\kPModel{\kStateS} \entails_\logicAamlK \aPrecondition(\aStateS)$, $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel{\aStateS}$, and $\kPModel{\kStateS} \exec \aPModel{\aStateS} \entails_\logicAamlK \psi$.
By the induction hypothesis we have $\kPModel{\kStateS} \exec \aPModel{\aStateS} \entails_\logicRamlK \psi$.
As $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel{\aStateS}$ and $\kPModel{\kStateS} \exec \aPModel{\aStateS} \entails_\logicRamlK \psi$ then $\kPModel{\kStateS} \entails_\logicRamlK \someactsBs \psi$.

Suppose that $\kPModel{\kStateS} \entails_\logicRamlK \someactsBs \psi$.
From Theorem~\ref{aaml-k-synthesis} there exists an action model $\aPModel{\aStatesT} \in \classAmK$ such that 
$\entails_\logicRamlK \actionA{\aPModel{\aStatesT}} \psi$,
$\entails_\logicRamlK \actionE{\aPModel{\aStatesT}} \psi \iff \someactsBs \psi$, and
for every $\aStateT \in \aStatesT$, $\kPModel{\kStateS} \in \classK$ if $\kPModel{\kStateS} \entails_\logicRamlK \aPrecondition(\aStateT)$ then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel{\aStateT}$.
Without loss of generality, by Corollary~\ref{raml-k-expressive-equivalence} we assume that $\aPModel{\aStatesT}$ has preconditions defined on \langMl{}.
Then $\kPModel{\kStateS} \entails_\logicRamlK \actionE{\aPModel{\aStatesT}} \psi$ and so there exists $\aStateT \in \aStatesT$ such that $\kPModel{\kStateS} \entails_\logicRamlK \aPrecondition(\aStateT)$, $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel{\aStateT}$, and $\kPModel{\kStateS} \exec \aPModel{\aStateT} \entails_\logicRamlK \psi$.
As $\aPrecondition(\aStateT) \in \langMl$ then $\kPModel{\kStateS} \entails_\logicAamlK \aPrecondition(\aStateT)$
By the induction hypothesis $\kPModel{\kStateS} \exec \aPModel{\aStateT} \entails_\logicAamlK \psi$.
Then $\kPModel{\kStateS} \entails_\logicAamlK \someactsBs \psi$.

Therefore by induction over $\phi$ we have for every $\kPModel{\kStateS} \in \classK$: $\kPModel{\kStateS} \entails_\logicAamlK \phi$ if and only if $\kPModel{\kStateS} \entails_\logicAamlK \phi$.
\end{proof}

As a consequence of the equivalence between \logicAamlK{} and \logicRamlK{}, we get as corollaries all of the results that we have previously shown for \logicRamlK{}.

\begin{corollary}
The logics \logicAamlK{} and \logicAmlK{} agree on all formulas of \langAml{}.
That is, for every $\phi \in \langAml$, $\kPModel{\kStateS} \in \classK$: $\kPModel{\kStateS} \entails_\logicAamlK \phi$ if and only if $\kPModel{\kStateS} \entails_\logicAmlK \phi$.
\end{corollary}

\begin{corollary}
The logics \logicAamlK{} and \logicRmlK{} agree on all formulas of \langRml{}.
That is, for every $\phi \in \langRml$, $\kPModel{\kStateS} \in \classK$: $\kPModel{\kStateS} \entails_\logicAamlK \phi$ if and only if $\kPModel{\kStateS} \entails_\logicRmlK \phi$.
\end{corollary}

\begin{corollary}
The axiomatisation \axiomRamlK{} is sound and strongly complete with respect to the semantics of the logic \logicAamlK{}.
\end{corollary}

\begin{corollary}
The logic \logicAamlK{} is expressively equivalent to the logic \logicK{}.
\end{corollary}

\begin{corollary}
The logic \logicAamlK{} is compact.
\end{corollary}

\begin{corollary}
The model-checking and satisfiability problems for the logic \logicAamlK{} are decidable.
\end{corollary}

Similar to \logicRmlK{}, the provably correct translation from \langAaml{} to \langMl{} may result in a non-elementary increase in size compared to the original formula.
Therefore any algorithm that relies on the provably correct translation will have a non-elementary complexity.
We leave the consideration of better complexity bounds and succinctness results for \logicAamlK{} to future work.

The proof of Theorem~\ref{aaml-k-synthesis} and the associated lemmas describe a recursive synthesis procedure that can be applied in order to construct action models that result in desired knowledge goals.
Suppose that we have an initial knowledge state involving knowledge and a desired knowledge goal, and we would like to achieve our desired knowledge goal through a specific epistemic update from our initial knowledge state.
That is, given a pointed Kripke model $\kPModel{\kStateS} \in \classK$, and a formula $\phi \in \langAaml$ we want to find a specific action model $\aPModel{\aStatesT} \in \classAmK$ such that $\kPModel{\kStateS} \entails \actionE{\aPModel{\aStatesT}} \phi$.
However whether this is possible depends on the initial knowledge state and the desired knowledge goal.
For example, if $\kPModel{\kStateS} \entails \necessaryA \bot$ and $\phi = \possible \top$, then for every $\aPModel{\aStatesT} \in \classAmK$ we have $\kPModel{\kStateS} \nentails \actionE{\aPModel{\aStatesT}} \possible \top$.
So we can only find a specific epistemic update that achieves our desired knowledge goal if the desired knowledge goal can be achieved by some epistemic update from our initial knowledge state. 
To rephrase using the language of \logicAaml{}: if $\kPModel{\kStateS} \entails \someacts \phi$ then we want to find a specific $\aPModel{\aStatesT} \in \classAmK$ such that $\kPModel{\kStateS} \entails \actionE{\aPModel{\aStatesT}} \phi$; if $\kPModel{\kStateS} \nentails \someacts \phi$ then clearly we can't find any such action model.
It should be clear that by using the synthesis procedure described in Theorem~\ref{aaml-k-synthesis} we can find such an action model, when such an action model exists.
In fact the action model given by Theorem~\ref{aaml-k-synthesis} depends only on $\phi$ and not on $\kPModel{\kStateS}$, so what we get is a single, specific action model $\aPModel{\aStatesT} \in \classAmK$, corresponding to $\phi$, such that $\entails \someacts \phi \iff \actionE{\aPModel{\aStatesT}} \phi$ and $\entails \actionA{\aPModel{\aStatesT}} \phi$.
That is, the same action model for $\phi$ can be executed on any initial Kripke model to achieve the desired knowledge goal, whenever that knowledge goal cab be achieved by some epistemic update from that initial Kripke model.

We note that as the synthesis procedure described in Theorem~\ref{aaml-k-synthesis} relies on the expressive equivalence of \logicRamlK{} and \logicK{}, and the provably correct translation from \langAaml{} to \langMl{} may result in a non-elementary increase in size compared to the original formula, the action model produced by the synthesis procedure may be non-elementary in size compared to the original formula.
However if the original formula is already in \langMl{} and in disjunctive normal form, then we note that the procedure constructs an action model that is linearithmic in size compared to the original disjunctive normal formula (size measured in bits).
The number of states in the action model is linear in size compared to the original disjunctive normal formula.
This can be noted as the construction step in Lemma~\ref{aaml-k-covers} is performed at most once for each subformula of the original disjunctive normal formula and introduces only two new states, whilst the construction step in Lemma~\ref{aaml-k-choice} introduces no new states.
The number of relationships in the action model is also linear in size compared to the original disjunctive normal formula, as we note that each state has at most two in-bound edges for each agent, including possibly one reflexive state, and one edge from another state.
As the number of states is linear in size compared to the original disjunctive normal formula, then a state can be represented with a logarithmic number of bits, so the accessibility relations can be represented in linearithmic space.
As the preconditions of each state correspond to a subformula of the original disjunctive normal formula, or $\top$, then a subformula can be represented in logarithmic space, by identifying it as the $i$th symbol in the formula, so the precondition function can be represented in linearithmic space.
If we had an improved provably correct translation from \langAaml{} to \langMl{} then the size of the action models produced by this synthesis procedure would be correspondingly improved.
Bozzelli, et al.~\cite{bozzelli:2014a} showed that \logicRmlK{} is at least doubly exponentially more succinct than \logicK{}, a result that carries over to \logicAamlK{}, so there are limits to this improvement.
However the synthesis procedure results in action models that have a great degree of redundancy, so the size of the action model may be reduced through other means.
We leave the consideration of synthesis procedures with improved complexity to future work.

Finally we give an example of an application of the action models synthesised by the above procedure.

\begin{example}
Let $\phi = \necessaryA \atomP \land \lnot \necessaryB \atomP$.
Suppose that we want an action model $\aPModel{\aStatesT}$
such that $\entails \actionA{\aPModel{\aStatesT}} \phi$
and $\entails \actionE{\aPModel{\aStatesT}} \phi \iff \someacts \phi$.
The action model $\aPModel{\aStatesT}$ is in a sense a general-purpose action model for achieving $\phi$.
For any Kripke model either it is possible to achieve $\phi$ as the result of executing an action model, in which case we can execute $\aPModel{\aStatesT}$ and result in $\phi$ being satisfied, or it is not possible to achieve $\phi$ as the result of executing any action model, in which case we can't execute $\aPModel{\aStatesT}$.

We note that $\phi$ is equivalent to the disjunctive normal formula $\coversA \emptyset \land \coversB \{\lnot \atomP, \top\} \lor \coversA \{\atomP\} \land \coversB \{\lnot \atomP, \top\}$.
Then recursively following the constructions given in Lemma~\ref{aaml-k-choice} and Lemma~\ref{aaml-k-covers} we get the multi-pointed action model $\aPModel{\aStatesT}$ shown in Figure~\ref{aaml-k-example}.
That $\entails \actionA{\aPModel{\aStateT}} \phi$ and $\entails \somerefs \phi \implies \actionE{\aPModel{\aStatesT}} \phi$ can easily be demonstrated by applying the \axiomAmlK{} axioms.
We note that there is an amount of redundancy in the action model, such as multiple identical states with the precondition $\top$, and some states that are subsumed by other states, such as the $\someacts \lnot \atomP$ states, which are subsumed by the $\someacts \top$ states, which are in turn subsumed by the $\top$ states.
We leave as an exercise to the reader the identification of the smaller action model that results from removing these redundancies.
Automated techniques could in principle identify these redundancies and produce smaller action models.

\begin{figure}
    \caption{An general-purpose action model $\aPModel{\aStatesT}$ for achieving $\necessaryA \atomP \land \lnot \necessaryB \atomP$, produced by our synthesis procedure.}\label{aaml-k-example}
    \centering
    \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=6em,thick]
        \node (left) {\underline{$\someacts (\coversA \emptyset \land \coversB \{\lnot \atomP, \top\})$}};
        \node (ls) [above of=left] {$\top$};
        \node (lbnp) [left of=ls] {$\someacts \lnot \atomP$};
        \node (lbt) [left of=lbnp] {$\someacts \top$};
        \node (lbnps) [above of=lbnp] {$\top$};
        \node (lbts) [above of=lbt] {$\top$};

        \node (right) [below of=left] {\underline{$\someacts (\coversA \{\atomP\} \land \coversB \{\lnot \atomP, \top\})$}};
        \node (rs) [below of=right] {$\top$};
        \node (rap) [left of=rs] {$\someacts \atomP$};
        \node (rbnp) [left of=rap] {$\someacts \lnot \atomP$};
        \node (rbt) [left of=rbnp] {$\someacts \top$};
        \node (raps) [below of=rap] {$\top$};
        \node (rbnps) [below of=rbnp] {$\top$};
        \node (rbts) [below of=rbt] {$\top$};

        \path[every node/.style={font=\sffamily\small},->]
            (left) edge [swap] node {$\agentB$} (lbnp)
                  edge [swap] node {$\agentB$} (lbt)
                  edge [swap] node {$\agents \setminus \{\agentA, \agentB\}$} (ls)
            (lbnp) edge node {$\agents$} (lbnps)
            (lbt) edge node {$\agents$} (lbts)
            (ls) edge [loop above] node {$\agents$} (ls)
            (lbnps) edge [loop above] node {$\agents$} (lbnps)
            (lbts) edge [loop above] node {$\agents$} (lbts)
            (right) edge node {$\agentA$} (rap)
                  edge node {$\agentB$} (rbnp)
                  edge node {$\agentB$} (rbt)
                  edge node {$\agents \setminus \{\agentA, \agentB\}$} (rs)
            (rap) edge node {$\agents$} (raps)
            (rbnp) edge node {$\agents$} (rbnps)
            (rbt) edge node {$\agents$} (rbts)
            (rs) edge [loop below] node {$\agents$} (rs)
            (raps) edge [loop below] node {$\agents$} (raps)
            (rbnps) edge [loop below] node {$\agents$} (rbnps)
            (rbts) edge [loop below] node {$\agents$} (rbts);
    \end{tikzpicture}
\end{figure}
\end{example}

\pagebreak
