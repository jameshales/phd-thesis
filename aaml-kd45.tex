\section{\classKFF{}}\label{aaml-kd45}

In this section we consider results specific to the logic \logicAamlKFF{} in the setting of \classKFF{}.
The main result of this section is that the action model quantifiers of \logicAamlKFF{} are equivalent to the refinement quantifiers of \logicRmlKFF{}.
We show this equivalence by showing that if there exists a refinement where a given formula is satisfied then we can construct a finite action model that results in that formula being satisfied.

As in the previous section, we rely heavily on results from the action model logic \logicAmlKFF{} and the refinement modal logic \logicRmlKFF{}, particularly the axioms from both.
We use the combined refinement action model logic \logicRamlKFF{} so that we can use results from \logicAmlKFF{} and \logicRmlKFF{} with a combined syntax, semantics and proof theory.

We first note that as the syntax and semantics of \logicRamlKFF{} are formed by combining the semantics of \logicAmlKFF{} and \logicRmlKFF{}, then \logicAmlKFF{} and \logicRmlKFF{} agree with \logicRamlKFF{} on formulas from their respective sublanguages.

\begin{lemma}\label{raml-k45-aml}
The logics \logicRamlKFF{} and \logicAmlKFF{} agree on all formulas of \langAml{}.
That is, for every $\phi \in \langAml$, $\kPModel{\kStateS} \in \classKFF$: $\kPModel{\kStateS} \entails_\logicRamlKFF \phi$ iff $\kPModel{\kStateS} \entails_\logicAmlKFF \phi$.
\end{lemma}

\begin{lemma}\label{raml-k45-rml}
The logics \logicRamlKFF{} and \logicAmlKFF{} agree on all formulas of \langRml{}.
That is, for every $\phi \in \langRml$, $\kPModel{\kStateS} \in \classKFF$: $\kPModel{\kStateS} \entails_\logicRamlKFF \phi$ iff $\kPModel{\kStateS} \entails_\logicRmlKFF \phi$.
\end{lemma}

These results follow directly from the definitions.
We note that these results only apply for \langAml{} and \langRml{} formulas respectively, and do not consider \langAaml{} formulas that contain both action model operators and quantifiers. 

Given these results we can give a sound and complete axiomatisation for \logicRamlKFF{} by combining the axiomatisations for \logicAmlKFF{} and \logicRmlKFF{}.

\pagebreak

\begin{definition}[Axiomatisation \axiomRamlKFF{}]\label{raml-k45-axiomatisation}
The axiomatisation \axiomRamlKFF{} is a substitution schema consisting of the axioms and rules of \axiomAmlKFF{} and the axioms and rules of \axiomRmlKFF{}:
$$
\begin{array}{rl}
    {\bf P}     & \text{All propositional tautologies}\\
    {\bf K}     & \proves \necessaryA (\phi \implies \psi) \implies (\necessaryA \phi \implies \necessaryA \psi)\\
    {\bf 4}     & \proves \necessaryA \phi \implies \necessaryA \necessaryA \phi\\
    {\bf 5}     & \proves \possibleA \phi \implies \necessaryA \possibleA \phi\\
    {\bf AP} & \proves \actionA{\aPModel{\aStateS}} \atomP \iff (\aPrecondition(\aStateS) \implies \atomP)\\
    {\bf AN} & \proves \actionA{\aPModel{\aStateS}} \lnot \phi \iff (\aPrecondition(\aStateS) \implies \lnot \actionA{\aPModel{\aStateS}} \phi)\\
    {\bf AC} & \proves \actionA{\aPModel{\aStateS}} (\phi \land \psi) \iff (\actionA{\aPModel{\aStateS}} \phi \land \actionA{\aPModel{\aStateS}} \psi)\\
    {\bf AK} & \proves \actionA{\aPModel{\aStateS}} \necessaryA \phi \iff (\aPrecondition(\aStateS) \implies \necessaryA \bigwedge_{\aStateT \in \aSuccessorsA{\aStateS}} \actionA{\aPModel{\aStateT}} \phi)\\
    {\bf AU} & \proves \actionA{\aPModel{\aStatesT}} \phi \iff \bigwedge_{\aStateT \in \aStatesT} \actionA{\aPModel{\aStateT}} \phi\\
    {\bf R} & \proves \allrefsBs (\phi \implies \psi) \implies (\allrefsBs \phi \implies \allrefsBs \psi)\\
    {\bf RP} & \proves \allrefsBs \pi \iff \pi\\
    {\bf RK45} & \proves \somerefsBs \coversA \Gamma_\agentA \iff \bigwedge_{\gamma \in \Gamma_\agentA} \possibleA \somerefsBs \gamma \text{ where } \agentA \in \agentsB\\
    {\bf RComm} & \proves \somerefsBs \coversA \Gamma_\agentA \iff \coversA \{\somerefsBs \gamma \mid \gamma \in \Gamma_\agentA\} \text{ where } \agentA \notin \agentsB\\
    {\bf RDist} & \proves \somerefsBs \bigwedge_{\agentC \in \agentsC} \coversC \Gamma_\agentC \iff \bigwedge_{\agentC \in \agentsC} \somerefsBs \coversC \Gamma_\agentC\\
    {\bf MP}    & \text{From } \proves \phi \implies \psi \text{ and } \proves \phi \text{ infer } \proves \psi\\
    {\bf NecK}  & \text{From } \proves \phi \text{ infer } \proves \necessaryA \phi\\
    {\bf NecA} & \text{From } \proves \phi \text{ infer } \proves \actionA{\aPModel{\aStatesT}} \phi\\
    {\bf NecR} & \text{From } \proves \phi \text{ infer } \proves \allrefsBs \phi
\end{array}
$$
where $\phi, \psi \in \langAaml$, $\agentA \in \agents$, $\aPModel{\aStateS} \in \classAmKFF$, $\atomP \in \atoms$, $\pi \in \langPl$, $\agentsB, \agentsC \subseteq \agents$, and for every $\agentA \in \agents$: $\Gamma_\agentA$ is a finite set of $(\agents \setminus \{\agentA\})$-restricted modal formulas.
\end{definition}

We note that the axiomatisation \axiomRamlKFF{} is closed under substitution of equivalents.

\begin{lemma}
Let $\phi, \psi, \chi \in \langAaml$ be formulas and let $\atomP \in \atoms$ be a propositional atom.
If $\proves \psi \iff \chi$ then $\proves \phi[\psi\backslash\atomP] \iff \phi[\chi\backslash\atomP]$.
\end{lemma}

This is shown by combining the reasoning that \axiomAmlKFF{} and \axiomRmlKFF{} are closed under substitution of equivalents.

We also note that the axiomatisation \axiomRamlKFF{} is sound and complete.

\begin{lemma}\label{raml-k45-sound-complete}
The axiomatisation \axiomRamlKFF{} is sound and strongly complete with respect to the semantics of the logic \logicRamlKFF{}.
\end{lemma}

Soundness and completeness follows from the same reasoning used to show soundness and completeness of \axiomRamlK{} in Lemma~\ref{raml-k-sound-complete}.
Soundness follows from the same reasoning that the axioms are sound in \logicAmlKFF{} and \logicRmlKFF{}.
Completeness follows from a provably correct translation from \langAaml{} to \langMl{} that is formed by combining the provably correct translations from \langAml{} and \langRml{} to \langMl{}.

We note that, much like the provably correct translation for \logicRmlS{}, the provably correct translations we have presented here can result in a non-elementary increase in the size compared to the original formula.

The provably correct translation also implies that \logicRamlKFF{} is expressively equivalent to \logicKFF{}.

\begin{corollary}\label{raml-k45-expressive-equivalence}
The logic \logicRamlKFF{} is expressively equivalent to \logicKFF{}.
\end{corollary}

From expressive equivalence we have that \logicRmlKFF{} is compact and decidable.

\begin{corollary}
The logic \logicRamlKFF{} is compact.
\end{corollary}

\begin{corollary}
The model-checking and satisfiability problems for the logic \logicRamlKFF{} are decidable.
\end{corollary}

Similar to \logicRamlK{}, we note that most results from \logicAmlKFF{} and \logicRmlKFF{} generalise to \logicRamlKFF{} trivially thanks to a combination of \logicRamlKFF{} agreeing with \logicAmlKFF{} and \logicRmlKFF{} on their respective sublanguages, and the expressive equivalence of \logicRamlKFF{} and \logicKFF{}.

We now move on to our main result, that the action model quantifiers of \logicAamlK{} are equivalent to the refinement quantifiers of \logicRmlK{}.
We show this equivalence by showing that if there exists a refinement where a given formula is satisfied then we can construct a finite action model that results in that formula being satisfied.
The converse we have already shown; if there exists a (possibly infinite) action model that results in a given formula being satisfied then by Proposition~\ref{action-models-refinements} the result of executing the action model is itself a refinement, so there exists a refinement where the formula is satisfied.

We show our result using an inductive construction for a given formula.
Our construction is based on the construction used for \logicRamlK{} in the previous section, and is very similar to the constructions used to show the soundness of the axioms {\bf RK45}, {\bf RComm}, and {\bf RDist} in \logicRmlKFF{}.
We reuse the alternating disjunctive normal form we used for \logicRmlKFF{}, defined in Definition~\ref{adnf}, and we separate our inductive steps into two lemmas for each syntactic case from the alternating disjunctive normal form.
In \logicRmlKFF{} we relied on the fact that $\agentsB$-restricted modal formulas are preserved in $\agentsB$-bisimilar Kripke models.
We rely on a similar notion of $\agentsB$-bisimilarity for action models, which we define now.

\begin{definition}[$\agentsB$-bisimilarity of action models]
Let $\agentsB \subseteq \agents$ be a set of agents and let $\aPModelAndTuple{\aStateS}$ and $\aPModelAndTupleP{\aStateSP}$ be pointed action models.
Then $\aPModel{\aStateS}$ and $\aPModelP{\aStateSP}$ are $\agentsB$-bisimilar and we write $\aPModel{\aStateS} \bisimilar[\agentsB] \aPModelP{\aStateSP}$ if and only if for every $\agentB \in \agentsB$ the following conditions, {\bf pre}, {\bf forth-$\agentB$} and {\bf back-$\agentB$} holds:

\paragraph{pre}
$\entails \aPrecondition(\aStateS) \iff \aPreconditionP(\aStateSP)$.

\paragraph{forth-$\agentB$}
For every $\aStateT \in \aSuccessorsB{\aStateS}$ there exists $\aStateTP \in \aSuccessorsPB{\aStateSP}$ such that $\aPModel{\aStateT} \bisimilar \aPModelP{\aStateTP}$.

\paragraph{back-$\agentB$}
For every $\aStateTP \in \aSuccessorsPB{\aStateSP}$ there exists $\aStateT \in \aSuccessorsB{\aStateS}$ such that $\aPModel{\aStateT} \bisimilar \aPModelP{\aStateTP}$.
\end{definition}

We show that $\agentsB$-bisimilar action models result in the same $\agentsB$-restricted modal formulas.
Recall that $\agentsB$-restricted modal formulas were defined in Definition~\ref{b-restricted}.

\begin{lemma}\label{action-b-bisimulation-results}
Let $\agentsB \subseteq \agents$ be a set of agents, let $\kPModel{\kStateS}$ and $\kPModelP{\kStateSP}$ be pointed Kripke models such that $\kPModel{\kStateS} \bisimilar[\agentsB] \kPModelP{\kStateSP}$ and let $\aPModel{\aStateS}$ and $\aPModelP{\aStateSP}$ be pointed action models such that $\aPModel{\aStateS} \bisimilar[\agentsB] \aPModelP{\aStateSP}$ and $\aPrecondition(\aStateS)$ and $\aPreconditionP(\aStateSP)$ are $\agentsB$-restricted modal formulas.
Then $\kPModel{\kStateS} \entails \aPrecondition(\aStateS)$ if and only if $\kPModelP{\kStateSP} \entails \aPreconditionP(\aStateSP)$, and (when they are defined) $\kPModel{\kStateS} \exec \aPModel{\aStateS} \bisimilar[\agentsB] \kPModelP{\kStateSP} \exec \aPModelP{\aStateSP}$.
\end{lemma}

\begin{proof}
As $\aPModel{\aStateS} \bisimilar[\agentsB] \aPModelP{\aStateSP}$ from {\bf pre} we have that $\entails \aPrecondition(\aStateS) \iff \aPreconditionP(\aStateSP)$.
As $\kPModel{\kStateS} \bisimilar[\agentsB] \kPModelP{\kStateSP}$ from Lemma~\ref{b-restricted-invariance} we have that $\kPModel{\kStateS} \entails \aPrecondition(\aStateS)$ if and only if $\kPModelP{\kStateSP} \entails \aPreconditionP(\aStateSP)$.

Suppose that $\kPModel{\kStateS} \entails \aPrecondition(\aStateS)$ and $\kPModelP{\kStateSP} \entails \aPreconditionP(\aStateSP)$.
Let $\kPModelPP{(\kStateS, \aStateS)} = \kPModel{\kStateS} \exec \aPModel{\aStateS}$ and let $\kPModelPPP{(\kStateSP, \aStateSP))} = \kPModelP{\kStateSP} \exec \aPModelP{\aStateSP}$.
We show that $\kPModelPP{(\kStateS, \aStateS)} \bisimilar[\agentsB] \kPModelPPP{(\kStateSP, \aStateSP))}$.
Let $\atomP \in \atoms$ and $\agentB \in \agentsB$.

\paragraph{atoms-$\atomP$}
By construction $(\kStateS, \aStateS) \in \kValuationPP(\atomP)$ if and only if $\kStateS \in \kValuation(\atomP)$.
As $\kPModel{\kStateS} \bisimilar[\agentsB] \kPModelP{\kStateSP}$ from {\bf atoms-$\atomP$} we have that $\kStateS \in \kValuation(\atomP)$ if and only if $\kStateSP \in \kValuationP(\atomP)$.
By construction $\kStateSP \in \kValuationP(\atomP)$ if and only if $(\kStateSP, \aStateSP) \in \kValuationPPP(\atomP)$.

\paragraph{forth-$\agentB$}
Let $(\kStateT, \aStateT) \in \kSuccessorsPPB{(\kStateS, \aStateS)}$.
By construction $\kStateT \in \kSuccessorsB{\kStateS}$, $\aStateT \in \aSuccessorsB{\aStateS}$ and $\kPModel{\kStateT} \entails \aPrecondition(\aStateT)$.
As $\aPModel{\aStateS} \bisimilar[\agentsB] \aPModelP{\aStateSP}$ from {\bf forth-$\agentB$} there exists $\aStateTP \in \aSuccessorsPB{\aStateSP}$ such that $\aPModel{\aStateT} \bisimilar \aPModelP{\aStateTP}$ and from {\bf pre} we have that $\entails \aPrecondition(\aStateT) \iff \aPreconditionP(\aStateTP)$.
As $\kPModel{\kStateS} \bisimilar[\agentsB] \kPModelP{\kStateSP}$ from {\bf forth-$\agentB$} there exists $\kStateTP \in \kSuccessorsPB{\kStateSP}$ such that $\kPModel{\kStateT} \bisimilar \kPModelP{\kStateTP}$ and from Proposition~\ref{modal-bisimulation-invariance} as $\kPModel{\kStateT} \entails \aPrecondition(\aStateT)$ then $\kPModelP{\kStateTP} \entails \aPreconditionP(\aStateTP)$.
Therefore $(\kStateTP, \aStateTP) \in \kSuccessorsPPPB{(\kStateSP, \aStateSP)}$ and $\kPModelPP{(\kStateT, \aStateT)} \bisimilar \kPModelPPP{(\kStateTP, \aStateTP)}$.

\paragraph{back-$\agentB$}
Follows from symmetric reasoning to {\bf forth-$\agentB$}.
\end{proof}

\begin{corollary}
Let $\agentsB \subseteq \agents$ be a set of agents and let $\aPModel{\aStateS}$ and $\aPModelP{\aStateSP}$ be pointed action models such that $\aPModel{\aStateS} \bisimilar[\agentsB] \aPModelP{\aStateSP}$ and $\aPrecondition(\aStateS)$ and $\aPreconditionP(\aStateSP)$ are $\agentsB$-restricted modal formulas.
Then for every pointed Kripke model $\kPModel{\kStateS}$ and every $\agentsB$-restricted modal formula $\phi \in \langAaml$ we have that $\kPModel{\kStateS} \entails \actionA{\aPModel{\aStateS}} \phi$ if and only if $\kPModel{\kStateS} \entails \actionA{\aPModelP{\aStateSP}} \phi$.
\end{corollary}

\begin{proof}
This result follows from essentially the same reasoning as the analogous result, Proposition~\ref{aml-bisimilar-actions}, for bisimilar action models, using Lemma~\ref{action-b-bisimulation-results} in place of the analogous Proposition~\ref{action-bisimulation-results}.
\end{proof}

We use this lemma in the construction used for our main result.
First, the case where the given formula is a disjunction is handled exactly as it was for \logicAamlK{}.

\begin{lemma}\label{aaml-k45-choice}
Let $\agentsB \subseteq \agents$, 
let $\phi = \alpha \lor \beta \in \langAaml$, and 
let $\aPModel[\alpha]{\aStatesT[\alpha]} \in \classAmKFF$ and $\aPModel[\beta]{\aStatesT[\beta]} \in \classAmKFF$ be action models such that 
$\entails \actionA{\aPModel[\alpha]{\aStatesT[\alpha]}} \alpha$, 
$\entails \actionE{\aPModel[\alpha]{\aStatesT[\alpha]}} \alpha \iff \someactsBs \alpha$, 
$\entails \actionA{\aPModel[\beta]{\aStatesT[\beta]}} \beta$,
$\entails \actionE{\aPModel[\beta]{\aStatesT[\beta]}} \beta \iff \someactsBs \beta$,
for every $\aStateT[\alpha] \in \aStatesT[\alpha]$, $\kPModel{\kStateS} \in \classKFF$ if $\kPModel{\kStateS} \entails \aPrecondition[\alpha](\aStateT[\alpha])$ then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel[\alpha]{\aStateT[\alpha]}$, and
for every $\aStateT[\beta] \in \aStatesT[\beta]$, $\kPModel{\kStateS} \in \classKFF$ if $\kPModel{\kStateS} \entails \aPrecondition[\beta](\aStateT[\beta])$ then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel[\beta]{\aStateT[\beta]}$.
Then there exists an action model $\aPModel{\aStatesT} \in \classAmKFF$ such that 
$\entails \actionA{\aPModel{\aStatesT}} \phi$,
$\entails \actionE{\aPModel{\aStatesT}} \phi \iff \someactsBs \phi$, and
for every $\aStateT \in \aStatesT$, $\kPModel{\kStateS} \in \classKFF$ if $\kPModel{\kStateS} \entails \aPrecondition(\aStateT)$ then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel{\aStateT}$.
\end{lemma}

\begin{proof}[Proof]
We use the same construction and reasoning as in the proof of Lemma~\ref{aaml-k-choice}, noting additionally that the disjoint union of two $\classAmKFF$ action models is also a $\classAmKFF$ action model.
\end{proof}

We next show the case where the given formula is a conjunction of a propositional formula and cover operators.

\begin{lemma}\label{aaml-k45-covers}
Let $\agentsB, \agentsC \subseteq \agents$, 
let $\phi = \pi \land \bigwedge_{\agentC \in \agentsC} \coverC \Gamma_\agentC \in \langAaml$ where $\pi \in \langPl$, and 
for every $\agentC \in \agentsC$, $\gamma \in \agentsC$
let $\gamma$ be a $(\agents \setminus \{\agentC\})$-restricted modal formula, and
let $\aPModelAndTuple[\agentC, \gamma]{\aStatesT[\agentC, \gamma]} \in \classAmKFF$ be an action model such that 
$\entails \actionA{\aPModel[\agentC, \gamma]{\aStatesT[\agentC, \gamma]}} \gamma$,
$\entails \actionE{\aPModel[\agentC, \gamma]{\aStatesT[\agentC, \gamma]}} \gamma \iff \someactsBs \gamma$, and
for every $\aStateT[\agentC, \gamma] \in \aStatesT[\agentC, \gamma]$, $\kPModel{\kStateS} \in \classKFF$ if $\kPModel{\kStateS} \entails \aPrecondition[\agentC, \gamma](\aStateT[\agentC, \gamma])$ then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel[\agentC, \gamma]{\aStateT[\agentC, \gamma]}$.
Then there exists an action model $\aPModel{\aStatesT} \in \classAmKFF$ such that 
$\entails \actionA{\aPModel{\aStatesT}} \phi$
$\entails \actionE{\aPModel{\aStatesT}} \phi \iff \someactsBs \phi$, and
for every $\aStateT \in \aStatesT$, $\kPModel{\kStateS} \in \classKFF$ if $\kPModel{\kStateS} \entails \aPrecondition(\aStateT)$ then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel{\aStateT}$.
\end{lemma}

\begin{proof}
Without loss of generality we assume that each $\aModel[\agentC, \gamma]$ for every $\agentC \in \agentsC$, $\gamma \in \Gamma_\agentC$ is disjoint.

We construct the action model $\aPModelAndTuple{\aStateTest}$ where:
\begin{eqnarray*}
    \aStates &=& \{\aStateTest, \aStateSkip\} \cup \{\aPStateT[\agentC, \gamma] \mid \agentC \in \agentsC, \gamma \in \Gamma_\agentC, \aStateT[\agentC, \gamma] \in \aStatesT[\agentC, \gamma]\} \cup \bigcup_{\agentC \in \agentsC, \gamma \in \Gamma_\agentC} \aStates[\agentC, \gamma]\\
    \aAccessibilityC &=& \{(\aStateTest, \aPStateT[\agentC, \gamma]) \mid \gamma \in \Gamma_\agentC, \aStateT[\agentC, \gamma] \in \aStatesT[\agentC, \gamma]\} \cup \{(\aStateSkip, \aStateSkip)\} \\&&\quad \cup \{(\aPStateT[\agentC, \gamma], \aPStateU[\agentC, \gamma']) \mid \gamma, \gamma' \in \Gamma_\agentC, \aStateT[\agentC, \gamma] \in \aStatesT[\agentC, \gamma], \aStateU[\agentC, \gamma'] \in \aStatesT[\agentC, \gamma']\} \\&& \quad \cup \{(\aPStateT[\agentD, \gamma], \aStateU[\agentD, \gamma]) \mid \agentD \in \agentsC \setminus \{\agentC\}, \gamma \in \Gamma_\agentD, \aStateT[\agentD, \gamma] \in \aStatesT[\agentD, \gamma], \aStateU[\agentD, \gamma] \in \aSuccessorsC[\agentD, \gamma]{\aStateT[\agentD, \gamma]}\}  \\&& \quad \cup \bigcup_{\agentD \in \agentsC, \gamma \in \Gamma_\agentD} \aAccessibilityC[\agentD, \gamma]\\
    \aAccessibilityB &=& \{(\aStateTest, \aStateSkip), (\aStateSkip, \aStateSkip)\} \\&& \quad \cup \{(\aPStateT[\agentD, \gamma], \aStateU[\agentD, \gamma]) \mid \agentD \in \agentsC, \gamma \in \Gamma_\agentD, \aStateT[\agentD, \gamma] \in \aStatesT[\agentD, \gamma], \aStateU[\agentD, \gamma] \in \aSuccessorsB[\agentD, \gamma]{\aStateT[\agentD, \gamma]}\} \\&&\quad \cup \bigcup_{\agentD \in \agentsC, \gamma \in \Gamma_\agentD} \aAccessibilityB[\agentD, \gamma] \text{ for } \agentA \in \agents \setminus \agentsC\\
    \aPrecondition &=& \{(\aStateTest, \someactsBs \phi), (\aStateSkip, \top)\} \\&&\quad \cup \{(\aPStateT[\agentC, \gamma], \aPrecondition[\agentC, \gamma](\aStateT[\agentC, \gamma])) \mid \agentC \in \agentsC, \gamma \in \Gamma_\agentsC, \aStateT[\agentC, \gamma] \in \aStatesT[\agentC, \gamma]\} \\&&\quad \cup \bigcup_{\agentC \in \agentsC, \gamma \in \Gamma_\agentC} \aPrecondition[\agentC, \gamma]
\end{eqnarray*}
where $\agentC \in \agentsC$, and $\agentB \in \agents \setminus \agentsC$.

We note that by construction $\aModel \in \classAmKFF$.

\begin{figure}
    \caption{A schematic of the constructed action model.}\label{aaml-k45-construction}
    \centering
    \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=7em,thick]

    \node (test) {$\someactsBs \phi$};
    \node (skip) [above=7em of test] {$\top$};

    \node (mTPd) [below=7em of test] {$\cdots$};
    \node (mTPc1gn) [left=1.5em of mTPd] {$\aPModel{\aPStatesT[\agentC_1, \gamma^{\agentC_1}_1]}$};
    \node (mTPc1d) [left=1.5em of mTPc1gn] {$\cdots$};
    \node (mTPc1g1) [left=1.5em of mTPc1d] {$\aPModel{\aPStatesT[\agentC_1, \gamma^{\agentC_1}_{n_1}]}$};
    \node (mTPcmg1) [right=1.5em of mTPd] {$\aPModel{\aPStatesT[\agentC_m, \gamma^{\agentC_m}_1]}$};
    \node (mTPcmd) [right=1.5em of mTPcmg1] {$\cdots$};
    \node (mTPcmgn) [right=1.5em of mTPcmd] {$\aPModel{\aPStatesT[\agentC_m, \gamma^{\agentC_m}_{n_m}]}$};

    \node (mTc1gnvd) [below of=mTPc1gn] {$\vdots$};
    \node (mTc1g1vd) [below of=mTPc1g1] {$\vdots$};
    \node (mTcmg1vd) [below of=mTPcmg1] {$\vdots$};
    \node (mTcmgnvd) [below of=mTPcmgn] {$\vdots$};
    \node (mTdd) [below of=mTPd] {};

    \node (mTd) [below=7em of mTdd] {$\cdots$};
    \node (mTc1gn) [left=1.5em of mTd] {$\aPModel[\agentC_1, \gamma^{\agentC_1}]{\aStatesT[\agentC_1, \gamma^{\agentC_1}_1]}$};
    \node (mTc1d) [left=1.5em of mTc1gn] {$\cdots$};
    \node (mTc1g1) [left=1.5em of mTc1d] {$\aPModel[\agentC_1, \gamma^{\agentC_1}]{\aStatesT[\agentC_1, \gamma^{\agentC_1}_{n_1}]}$};
    \node (mTcmg1) [right=1.5em of mTd] {$\aPModel[\agentC_m, \gamma^{\agentC_m}]{\aStatesT[\agentC_m, \gamma^{\agentC_m}_1]}$};
    \node (mTcmd) [right=1.5em of mTcmg1] {$\cdots$};
    \node (mTcmgn) [right=1.5em of mTcmd] {$\aPModel[\agentC_m, \gamma^{\agentC_m}]{\aStatesT[\agentC_m, \gamma^{\agentC_m}_{n_m}]}$};

      \path[every node/.style={font=\sffamily\small},->]
        (skip) edge [loop right] node {$\agents$} (skip)
        (test) edge node {$\agentC_1$} (mTPc1g1)
               edge node {$\agentC_1$} (mTPc1gn)
               edge [swap] node {$\agentC_m$} (mTPcmg1)
               edge [swap] node {$\agentC_m$} (mTPcmgn)
               edge node {$\agents \setminus \{\agentC_1, \dots, \agentC_m\}$} (skip)
        (mTPc1g1) edge node {$\agents \setminus \{\agentC_1\}$} (mTc1g1vd)
                  edge [loop left,distance=1em] node {$\agentC_1$} (mTPc1g1)
                  edge [<->,bend right] node {$\agentC_1$} (mTPc1gn)
        (mTPc1gn) edge node {$\agents \setminus \{\agentC_1\}$} (mTc1gnvd)
                  edge [loop right,distance=1em] node {$\agentC_1$} (mTPc1gn)
        (mTPcmg1) edge node {$\agents \setminus \{\agentC_m\}$} (mTcmg1vd)
                  edge [loop left,distance=1em] node {$\agentC_m$} (mTPcmg1)
                  edge [<->,bend right] node {$\agentC_m$} (mTPcmgn)
        (mTPcmgn) edge node {$\agents \setminus \{\agentC_m\}$} (mTcmgnvd)
                  edge [loop right,distance=1em] node {$\agentC_1$} (mTPcmgn)
        (mTc1g1) edge node {$\agents \setminus \{\agentC_1\}$} (mTc1g1vd)
        (mTc1gn) edge node {$\agents \setminus \{\agentC_1\}$} (mTc1gnvd)
        (mTcmg1) edge node {$\agents \setminus \{\agentC_m\}$} (mTcmg1vd)
        (mTcmgn) edge node {$\agents \setminus \{\agentC_m\}$} (mTcmgnvd);
    \end{tikzpicture}
\end{figure}

We call each state $\aPStateT[\agentC, \gamma]$ a ``proxy state'' for the corresponding state $\aStateT[\agentC, \gamma]$.
Similar to the construction used to show the soundness of the axiom {\bf RK45} in \logicRmlKFF{} the intention is that each proxy state $\aPStateT[\agentC, \gamma]$ is $(\agents \setminus \{\agentC\})$-bisimilar to the corresponding state $\aStateT[\agentC, \gamma]$.
In general we cannot have the $\aStateT[\agentC, \gamma]$ states be direct $\agentC$-successors of $\aStateTest$ whilst also having $\aPModel{\aStateT[\agentC, \gamma]} \bisimilar \aPModel[\agentC, \gamma]{\aStateT[\agentC, \gamma]}$.
This is because our construction would require additional $\agentC$-edges from the $\aStateT[\agentC, \gamma]$ states in order to satisfy the transitive and Euclidean properties of \classKFF{}.
We introduce proxy states to act a proxy for the non-$\agentC$-successors of the corresponding refinement state, so that $\aPModel{\aPStateT[\agentC, \gamma]} \bisimilar[(\agents \setminus \{\agentC\})] \aPModel[\agentC, \gamma]{\aStateT[\agentC, \gamma]}$.
As each $\gamma$ is a $(\agents \setminus \{\agentC\})$-restricted modal formula, and $(\agents \setminus \{\agentC\})$-bisimilar action models agree on $(\agents \setminus \{\agentC\})$-restricted modal formulas, this is enough to ensure that $\aPModel{\aPStateT[\agentC, \gamma]} \entails \gamma$.

A schematic of the action model $\aPModel{\aStateTest}$ and an overview of our construction is shown in Figure~\ref{aaml-k45-construction}.
This is similar to the construction used to show the soundness of the axiom {\bf RK45} in \logicRmlKFF{}, but it deals with all agents in $\agentsC$ at once, rather than a single agent at a time.
Here we can see that each of the action models, $\aPModel[\agentC_1,\gamma_1]{\aStatesT[\agentC_1, \gamma_1]}, \dots, \aPModel[\agentC_1,\gamma_{n_1}]{\aStatesT[\agentC_1, \gamma_{n_1}]} \dots \aPModel[\agentC_m,\gamma_1]{\aStatesT[\agentC_m, \gamma_1]}, \dots, \aPModel[\agentC_m,\gamma_{n_m}]{\aStatesT[\agentC_m, \gamma_{n_m}]}$, are combined into the larger action model $\aPModel{\aStateTest}$.
We can see the use of the proxy states $\aPModel[\agentC_1,\gamma_1]{\aPStatesT[\agentC_1, \gamma_1]}, \dots, \aPModel[\agentC_1,\gamma_{n_1}]{\aPStatesT[\agentC_1, \gamma_{n_1}]} \dots \aPModel[\agentC_m,\gamma_1]{\aPStatesT[\agentC_m, \gamma_1]}, \dots, \aPModel[\agentC_m,\gamma_{n_m}]{\aPStatesT[\agentC_m, \gamma_{n_m}]}$, which have all of the $(\agents \setminus \{\agentC\})$-successors of the respective action models.
We note that the proxy states are $(\agents \setminus \{\agentC\})$-bisimilar to the respective action models, and therefore result in the same respective $(\agents \setminus \{\agentC\})$-restricted formulas $\gamma_1, \dots, \gamma_n$.
We can also see that the proxy states have additional transitive and Euclidean edges in order to ensure that $\aModel \in \classKFF$, and these additional edges are why the proxy states are not fully bisimilar to the respective action models.

We also note for every $\agentC \in \agentsC$, $\gamma \in \Gamma_\agentC$, $\aStateS[\agentC, \gamma] \in \aStates[\agentC, \gamma]$ that $\aPModel{\aStateS[\agentC, \gamma]} \bisimilar \aPModel[\agentC, \gamma]{\aStateS[\agentC, \gamma]}$, as by construction $\aModel$ contains the disjoint union of each $\aModel[\agentC, \gamma]$ and no outward-facing edges are added to any state from $\aStates[\agentC, \gamma]$ in $\aModel$.

We further observe for every $\agentC \in \agentsC$, $\gamma \in \Gamma_\agentC$, $\aStateT[\agentC, \gamma] \in \aStatesT[\agentC, \gamma]$ that $\aPModel{\aPStateT[\agentC, \gamma]} \bisimilar[(\agents \setminus \{\agentC\})] \aPModel[\agentC, \gamma]{\aStateT[\agentC, \gamma]}$, as by construction the precondition and $(\agents \setminus \{\agentC\})$-successors of $\aPStateT[\agentC, \gamma]$ are the same as $\aStateT[\agentC, \gamma]$.
As $\gamma$ is a $(\agents \setminus \{\agentC\})$-restricted modal formula then if we let $\aPStatesT[\agentC, \gamma] = \{\aPStateT[\agentC, \gamma] \mid \aStateT[\agentC, \gamma]\}$ we have that
$\entails \actionA{\aPModel{\aPStatesT[\agentC, \gamma]}} \gamma$, and
$\entails \actionE{\aPModel{\aPStatesT[\agentC, \gamma]}} \gamma \iff \someactsBs \gamma$.

We show that
$\entails \actionA{\aPModel{\aStateTest}} \phi$, and 
$\entails \actionE{\aPModel{\aStateTest}} \phi \iff \someactsBs \phi$
by using the same reasoning as in the proof of Lemma~\ref{aaml-k-covers},
but substituting occurrences of $\aPModel{\aPStatesT[\agentC, \gamma]}$ with $\aPModel{\aStatesT[\agentC, \gamma]}$, noting from above that these states each satisfy the corresponding formulas $\gamma$, as required in the proof of Lemma~\ref{aaml-k-covers}.

We next show that for every $\kPModel{\kStateS} \in \classKFF$ if $\kPModel{\kStateS} \entails \aPrecondition(\aStateTest)$ then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel{\aStateTest}$.
Let $\kPModel{\kStateS} \in \classKFF$ such that $\kPModel{\kStateS} \entails \aPrecondition(\aStateTest)$.
For every $\agentC \in \agentsC$, $\gamma \in \Gamma_\agentC$, $\aStateT[\agentC, \gamma] \in \aStatesT[\agentC, \gamma]$, $\kStateT \in \kSuccessorsC{\kStateS}$ such that $\kPModel{\kStateT} \entails \aPrecondition[\agentC,\gamma](\aStateT[\agentC,\gamma])$ we have that $\kPModel{\kStateT} \simulatesBs \kPModel{\kStateT} \exec \aPModel[\agentC, \gamma]{\aStateT[\agentC, \gamma]}$.
From above $\aPModel[\agentC, \gamma]{\aStateT[\agentC, \gamma]} \bisimilar \aPModel{\aStateT[\agentC, \gamma]}$ and so by 
Proposition~\ref{action-bisimulation-results} we have that $\kPModel{\kStateT} \exec \aPModel[\agentC, \gamma]{\aStateT[\agentC, \gamma]} \bisimilar \kPModel{\kStateT} \exec \aPModel{\aStateT[\agentC, \gamma]}$.
From Corollary~\ref{bisimilar-refinement} and Proposition~\ref{refinements-preorder} we have that $\kPModel{\kStateT} \simulatesBs \kPModel{\kStateT} \exec \aPModel{\aStateT[\agentC, \gamma]}$ (say via a $\agentsB$-refinement $\refinement^{\kStateT, \aStateT[\agentC, \gamma]}$).

Let $\kPModelAndTupleP{(\kStateS, \aStateTest)} = \kPModel{\kStateS} \exec \aPModel{\aStateTest}$.
We define $\refinement \subseteq \kStates \times \kStatesP$ where:
\begin{eqnarray*}
\refinement &=& 
\{(\kStateS, (\kStateS, \aStateTest))\} \cup 
\{(\kStateT, (\kStateT, \aStateSkip)) \mid \kStateT \in \kStates\}  \\&&\quad \cup
\bigcup \{\{(\kStateT, (\kStateT, \aPStateT[\agentC, \gamma]))\} \cup \refinement^{\kStateT, \aStateT[\agentC, \gamma]} \mid \agentC \in \agentsC, \gamma \in \Gamma_\agentC, \aStateT[\agentC, \gamma] \in \aStatesT[\agentC, \gamma], \kStateT \in \kSuccessorsC{\kStateT}, \kPModel{\kStateT} \entails \aPrecondition(\aStateT[\agentC, \gamma])\}
\end{eqnarray*}

We show that $\refinement$ is a $\agentsB$-refinement from $\kPModel{\kStateS}$ to $\kPModelP{(\kStateS, \aStateTest)}$.
Let $\atomP \in \atoms$, $\agentA \in \agents$ and $\agentD \in \agents \setminus \agentsB$.
We show by cases that the relationships in $\refinement$ satisfy the conditions {\bf atoms-$\atomP$}, {\bf forth-$\agentD$}, and {\bf back-$\agentA$}.

\begin{description}
    \item[{Case $(\kStateS, (\kStateS, \aStateTest)) \in \refinement$:}] \hfill
        \begin{description}
            \item[atoms-$\atomP$]
                By construction $\kStateS \in \kValuation(\atomP)$ if and only if $(\kStateS, \aStateTest) \in \kValuationP(\atomP)$.
            \item[forth-$\agentD$]
                Suppose that $\agentD \in \agentsC$.
                Let $\kStateT \in \kSuccessorsD{\kStateS}$.
                By hypothesis $\kPModel{\kStateS} \entails \someactsBs (\pi \land \bigwedge_{\agentC \in \agentsC} \coversC \Gamma_\agentC)$, and in particular $\kPModel{\kStateS} \entails \someactsBs \coversD \Gamma_\agentD$.
                As $\agentD \notin \agentsB$, by the \axiomAamlKFF{} axiom {\bf RComm} we have that $\kPModel{\kStateS} \entails \coversD \{\someactsBs \gamma' \mid \gamma' \in \Gamma_\agentD\}$ and by the definition of the cover operator we have that $\kPModel{\kStateS} \entails \necessaryD \bigvee_{\gamma' \in \Gamma_\agentD} \someactsBs \gamma'$ so there exists $\gamma' \in \Gamma_\agentD$ such that $\kPModel{\kStateT} \entails \someactsBs \gamma'$.
                By hypothesis $\entails \someactsBs \gamma' \implies \actionE{\aPModel[\agentC, \gamma']{\aStatesT[\agentC, \gamma']}} \gamma'$ so there exists $\aStateT[\agentC, \gamma'] \in \aStatesT[\agentC, \gamma']$ such that $\kPModel{\kStateT} \entails \aPrecondition[\agentC, \gamma'](\aStateT[\agentC, \gamma'])$.
                By construction $\aPStateT[\agentC, \gamma'] \in \aSuccessorsD{\aStateTest}$ and $\aPrecondition(\aPStateT[\agentC, \gamma']) = \aPrecondition[\agentC, \gamma'](\aStateT[\agentC, \gamma'])$ so $\kPModel{\kStateT} \entails \aPrecondition(\aPStateT[\agentC, \gamma'])$, $(\kStateT, \aPStateT[\agentC, \gamma']) \in \kSuccessorsPD{(\kStateS, \aStateTest)}$, and $(\kStateT, (\kStateT, \aPStateT[\agentC, \gamma'])) \in \refinement$.

                Suppose that $\agentD \notin \agentsC$.
                Let $\kStateT \in \kSuccessorsD{\kStateS}$.
                By construction $\aStateSkip \in \aSuccessorsD{\aStateTest}$ and $\kPModel{\kStateT} \entails \aPrecondition(\aStateSkip)$, so $(\kStateT, \aStateSkip) \in \kSuccessorsPD{(\kStateS, \aStateTest)}$ and $(\kStateT, (\kStateT, \aStateSkip)) \in \refinement$.
            \item[back-$\agentA$]
                Suppose that $\agentA \in \agentsC$.
                Let $(\kStateT, \aPStateT[\agentA, \gamma]) \in \kSuccessorsPA{(\kStateS, \aStateTest)}$ where $\gamma \in \Gamma_\agentA$ and $\aStateT[\agentA, \gamma] \in \aStatesT[\agentA, \gamma]$.
                By construction $\kStateT \in \kSuccessorsA{\kStateS}$ and $\kPModel{\kStateT} \entails \aPrecondition(\aPStateT[\agentA, \gamma])$ so by construction $(\kStateT, (\kStateT, \aPStateT[\agentA, \gamma])) \in \refinement$.

                Suppose that $\agentA \notin \agentsC$.
                Let $(\kStateT, \aStateSkip) \in \kSuccessorsPA{(\kStateS, \aStateTest)}$.
                By construction $\kStateT \in \kSuccessorsA{\kStateS}$ and $(\kStateT, (\kStateT, \aStateSkip)) \in \refinement$.
        \end{description}
    \item[{Case $(\kStateT, (\kStateT, \aStateSkip)) \in \refinement$ where $\kStateT \in \kStates$:}] \hfill
        \begin{description}
            \item[atoms-$\atomP$]
                By construction $\kStateT \in \kValuation(\atomP)$ if and only if $(\kStateT, \aStateSkip) \in \kValuationP(\atomP)$.
            \item[forth-$\agentD$]
                Let $\kStateU \in \kSuccessorsD{\kStateT}$.
                By construction $\aStateSkip \in \aSuccessorsD{\aStateSkip}$ and $\kPModel{\kStateU} \entails \aPrecondition(\aStateSkip)$, so $(\kStateU, \aStateSkip) \in \kSuccessorsPD{(\kStateT, \aStateSkip)}$ and $(\kStateU, (\kStateU, \aStateSkip)) \in \refinement$.
            \item[back-$\agentA$]
                Let $(\kStateU, \aStateSkip) \in \kSuccessorsPA{(\kStateT, \aStateSkip)}$.
                By construction $\kStateU \in \kSuccessorsA{\kStateT}$ and $(\kStateU, (\kStateU, \aStateSkip)) \in \refinement$.
        \end{description}
    \item[{Case $(\kStateT, (\kStateT, \aPStateT[\agentC, \gamma])) \in \refinement$ where $\agentC \in \agentsC$, $\gamma \in \Gamma_\agentC$, $\aStateT[\agentC, \gamma] \in \aStatesT[\agentC, \gamma]$, $\kStateT \in \kStates$, and $\kPModel{\kStateT} \entails \aPrecondition(\aStateT[\agentC, \gamma])$:}] \hfill
        \begin{description}
            \item[atoms-$\atomP$]
                By construction $\kStateT \in \kValuation(\atomP)$ if and only if $(\kStateT, \aStateT[\agentC, \gamma]) \in \kValuationP(\atomP)$.
            \item[forth-$\agentD$]
                Suppose that $\agentD = \agentC$.
                Let $\kStateU \in \kSuccessorsD{\kStateT}$.
                As $\kModel \in \classKFF$ then by transitivity $\kStateU \in \kSuccessorsD{\kStateS}$.
                By hypothesis $\kPModel{\kStateS} \entails \someactsBs (\pi \land \bigwedge_{\agentC \in \agentsC} \coversC \Gamma_\agentC)$, and in particular $\kPModel{\kStateS} \entails \someactsBs \coversD \Gamma_\agentD$.
                As $\agentD \notin \agentsB$, by the \axiomAamlKFF{} axiom {\bf RComm} we have that $\kPModel{\kStateS} \entails \coversD \{\someactsBs \gamma' \mid \gamma' \in \Gamma_\agentD\}$ and by the definition of the cover operator we have that $\kPModel{\kStateS} \entails \necessaryD \bigvee_{\gamma' \in \Gamma_\agentD} \someactsBs \gamma'$ so there exists $\gamma' \in \Gamma_\agentD$ such that $\kPModel{\kStateU} \entails \someactsBs \gamma'$.
                By hypothesis $\entails \someactsBs \gamma' \implies \actionE{\aPModel[\agentC, \gamma']{\aStatesT[\agentC, \gamma']}} \gamma'$ so there exists $\aStateU[\agentC, \gamma'] \in \aStatesT[\agentC, \gamma']$ such that $\kPModel{\kStateU} \entails \aPrecondition[\agentC, \gamma'](\aStateU[\agentC, \gamma'])$.
                By construction $\aPStateU[\agentC, \gamma'] \in \aSuccessorsD{\aPStateT[\agentC, \gamma]}$ and $\aPrecondition(\aPStateU[\agentC, \gamma']) = \aPrecondition[\agentC, \gamma'](\aStateU[\agentC, \gamma'])$ so $\kPModel{\kStateU} \entails \aPrecondition(\aPStateU[\agentC, \gamma'])$, $(\kStateU, \aPStateU[\agentC, \gamma']) \in \kSuccessorsPD{(\kStateT, \aPStateT[\agentC, \gamma])}$, and $(\kStateU, (\kStateU, \aPStateU[\agentC, \gamma'])) \in \refinement$.

                Suppose that $\agentD \neq \agentC$.
                Let $\kStateU \in \kSuccessorsD{\kStateT}$.
                As $\kPModel{\kStateT} \entails \aPrecondition(\aStateT[\agentC, \gamma])$ then by hypothesis $(\kStateT, (\kStateT, \aStateT[\agentC, \gamma])) \in \refinement^{\kStateT, \aStateT[\agentC, \gamma]}$.
                By {\bf forth-$\agentD$} for $\refinement^{\kStateT, \aStateT[\agentC, \gamma]}$ there exists $(\kStateV, \aStateV[\agentC, \gamma]) \in \kSuccessorsPD{(\kStateT, \aStateT[\agentC, \gamma])} = \kSuccessorsPD{(\kStateT, \aPStateT[\agentC, \gamma])}$ such that $(\kStateU, (\kStateV, \aStateV[\agentC, \gamma])) \in \refinement^{\kStateT, \aStateT[\agentC, \gamma]} \subseteq \refinement$.
            \item[back-$\agentA$]
                Suppose that $\agentA \in \agentsC$.
                Let $(\kStateU, \aPStateU[\agentC, \gamma']) \in \kSuccessorsPA{(\kStateT, \aPStateT[\agentC, \gamma])}$ where $\gamma' \in \Gamma_\agentC$ and $\aPStateU[\agentC, \gamma'] \in \aStatesT[\agentC, \gamma']$.
                As $\kModel \in \classKFF$ then by transitivity $\kStateU \in \kSuccessorsD{\kStateS}$.
                As $(\kStateU, \aPStateU[\agentC, \gamma']) \in \kStatesP$ then $\kPModel{\kStateU} \entails \aPrecondition(\aPStateU[\agentC, \gamma'])$ so by construction $(\kStateU, (\kStateU, \aPStateU[\agentC, \gamma'])) \in \refinement$.

                Suppose that $\agentA \notin \agentsC$.
                Let $(\kStateU, \aStateU[\agentC, \gamma]) \in \kSuccessorsPA{(\kStateT, \aPStateT[\agentC, \gamma])}$ where $\aStateU[\agentC, \gamma] \in \aSuccessorsA{\aStateT[\agentC, \gamma]} = \aSuccessorsA{\aPStateT[\agentC, \gamma]}$.
                As $\kPModel{\kStateT} \entails \aPrecondition(\aStateT[\agentC, \gamma])$ then by hypothesis $(\kStateT, (\kStateT, \aStateT[\agentC, \gamma])) \in \refinement^{\kStateT, \aStateT[\agentC, \gamma]}$.
                By {\bf back-$\agentA$} for $\refinement^{\kStateT, \aStateT[\agentC, \gamma]}$ there exists $\kStateV \in \kSuccessorsA{\kStateT}$ such that $(\kStateV, (\kStateU, \aStateU[\agentC, \gamma])) \in \refinement^{\kStateT, \aStateT[\agentC, \gamma]} \subseteq \refinement$.
        \end{description}
    \item[{Case $(\kStateT, \kStateTP) \in \refinement^{\kStateT, \aStateT[\agentC, \gamma]} \subseteq \refinement$ where $\agentC \in \agentsC$, $\gamma \in \Gamma_\agentC$, $\aStateT[\agentC, \gamma] \in \aStatesT[\agentC, \gamma]$, $\kStateT \in \kStates$, and $\kPModel{\kStateT} \entails \aPrecondition(\aStateT[\agentC, \gamma])$:}] \hfill
        \begin{description}
            \item[atoms-$\atomP$]
                From {\bf atoms-$\atomP$} for $\refinement^{\kStateT, \aStateT[\agentC, \gamma]}$ we have that $\kStateT \in \kValuation(\atomP)$ if and only if $\kStateTP \in \kValuationP(\atomP)$.
            \item[forth-$\agentD$]
                Let $\kStateU \in \kSuccessorsD{\kStateT}$.
                By {\bf forth-$\agentD$} for $\refinement^{\kStateT, \aStateT[\agentC, \gamma]}$ there exists $\kStateUP \in \kSuccessorsPD{\kStateTP}$ such that $(\kStateU, \kStateUP) \in \refinement^{\kStateT, \aStateT[\agentC, \gamma]} \subseteq \refinement$.
            \item[back-$\agentA$]
                Let $\kStateUP \in \kSuccessorsPA{\kStateTP}$.
                By {\bf back-$\agentA$} for $\refinement^{\kStateT, \aStateT[\agentC, \gamma]}$ there exists $\kStateU \in \kSuccessorsA{\kStateT}$ such that $(\kStateU, \kStateUP) \in \refinement^{\kStateT, \aStateT[\agentC, \gamma]} \subseteq \refinement$.
        \end{description}
\end{description}

Therefore $\refinement$ is a $\agentsB$-refinement and $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel{\aStateTest}$.
\end{proof}

We combine the two previous lemmas into an inductive construction that works for all formulas.

\begin{theorem}\label{aaml-k45-synthesis}
Let $\agentsB \subseteq \agents$ and let $\phi \in \langAaml$.
There exists an action model $\aPModelAndTuple{\aStatesT} \in \classAmKFF$ such that 
$\entails \actionA{\aPModel{\aStatesT}} \phi$,
$\entails \actionE{\aPModel{\aStatesT}} \phi \iff \someactsBs \phi$, and
for every $\aStateT \in \aStatesT$, $\kPModel{\kStateS} \in \classK$ if $\kPModel{\kStateS} \entails \aPrecondition(\aStateT)$ then $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS} \exec \aPModel{\aStateT}$.
\end{theorem}

\begin{proof}[Proof]
We use the same reasoning used to show the analogous result for \logicAamlK{}, in Theorem~\ref{aaml-k-synthesis}, using Lemma~\ref{aaml-k45-choice} and Lemma~\ref{aaml-k45-covers} for the inductive steps, to inductively construct an action model.
We convert the formula to alternating disjunctive normal form instead of disjunctive normal form, which ensures that the construction from Lemma~\ref{aaml-k45-covers} can be applied inductively to the formula, by satisfying the requirement that $\coversC$~operators are only applied to sets of $(\agents \setminus \{\agentC\})$-restricted modal formulas.
\end{proof}

\begin{theorem}\label{aaml-k45-semantics-equivalent}
The semantics of \logicAamlKFF{} and the semantics of \logicRamlKFF{} agree on all formulas of \langAaml{}.
That is, for every $\phi \in \langAaml$, $\kPModel{\kStateS} \in \classKFF$: $\kPModel{\kStateS} \entails_\logicAamlKFF \phi$ if and only if $\kPModel{\kStateS} \entails_\logicAamlKFF \phi$.
\end{theorem}

\begin{proof}
We use the same reasoning used to show the analogous result for \logicAamlK{}, in Theorem~\ref{aaml-k-semantics-equivalent}, using Theorem~\ref{aaml-k45-synthesis} in place of the analogous Theorem~\ref{aaml-k-synthesis}.
\end{proof}

As a consequence of the equivalence between \logicAamlKFF{} and \logicRamlKFF{}, we get as corollaries all of the results that we have previously shown for \logicRamlKFF{}.

\begin{corollary}
The logics \logicAamlKFF{} and \logicAmlKFF{} agree on all formulas of \langAml{}.
That is, for every $\phi \in \langAml$, $\kPModel{\kStateS} \in \classK$: $\kPModel{\kStateS} \entails_\logicAamlK \phi$ if and only if $\kPModel{\kStateS} \entails_\logicAmlK \phi$.
\end{corollary}

\begin{corollary}
The logics \logicAamlKFF{} and \logicRmlKFF{} agree on all formulas of \langRml{}.
That is, for every $\phi \in \langRml$, $\kPModel{\kStateS} \in \classK$: $\kPModel{\kStateS} \entails_\logicAamlK \phi$ if and only if $\kPModel{\kStateS} \entails_\logicRmlK \phi$.
\end{corollary}

\begin{corollary}
The axiomatisation \axiomRamlKFF{} is sound and strongly complete with respect to the semantics of the logic \logicAamlKFF{}.
\end{corollary}

\begin{corollary}
The logic \logicAamlKFF{} is expressively equivalent to \logicKFF{}.
\end{corollary}

\begin{corollary}
The logic \logicAamlKFF{} is compact.
\end{corollary}

\begin{corollary}
The model-checking and satisfiability problems for the logic \logicAamlKFF{} are decidable.
\end{corollary}

Similar to \logicAamlK{}, discussed in the previous section, the provably correct translation from \langAaml{} to \langMl{} may result in a non-elementary increase in size compared to the original formula.
Therefore any algorithm that relies on the provably correct translation will have a non-elementary complexity.
We leave the consideration of better complexity bounds and succinctness results for \logicAamlKFF{} to future work.

Also similar to \logicAamlK{}, the proof of Theorem~\ref{aaml-k45-synthesis} and the associated lemmas describe a recursive synthesis procedure that can be applied in order to construct action models that result in desired knowledge goals.
The action model given by Theorem~\ref{aaml-s5-synthesis} depends only on the desired knowledge goal, and not on the initial knowledge state, so the action model can be executed on any initial Kripke model to achieve the desired knowledge goal, whenever that knowledge goal cab be achieved by some epistemic update from that initial Kripke model.
Similar to \logicAamlK{}, as the synthesis procedure relies on the expressive equivalence of \logicRamlKFF{} and \logicKFF{}, and the provably correct translation from \langAaml{} to \langMl{} may result in a non-elementary increase in size compared to the original formula, the action model produced by the synthesis procedure may be non-elementary in size compared to the original formula.
If the original formula is already in \langMl{} and in alternating disjunctive normal form, then the action model is linearithmic in size compared to the original alternating disjunctive normal formula.
If we had an improved provably correct translation from \langAaml{} to \langMl{} then the size of the action models produced by this synthesis procedure would be correspondingly improved.
We leave the consideration of synthesis procedures with improved complexity to future work.
