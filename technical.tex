\chapter{Technical preliminaries}

In this chapter we introduce the technical preliminaries used throughout this dissertation.

\section{Modal logic}

We recall definitions and results from modal logic.

\subsection{Syntax and semantics}

Let $\atoms$ be a non-empty, countable set of propositional atoms, and
let $\agents$ be a non-empty, finite set of agents.

\begin{definition}[Language of modal logic]
The {\em language of modal logic}, \langMl{}, is inductively defined inductively as:
$$
\phi ::= 
    \atomP \mid
    \lnot \phi \mid
    (\phi \land \phi) \mid
    \necessary[\agentA] \phi
$$
where $\atomP \in \atoms$ and $\agentA \in \agents$.
\end{definition}

We use all of the standard abbreviations from propositional logic, in addition to the standard abbreviation $\possible[\agentA] \phi ::= \lnot \necessary[\agentA] \lnot \phi$.

The formula $\necessary[\agentA] \phi$ may be read as ``agent $\agentA$ {\em knows} that $\phi$ is true'', or ``agent $\agentA$ {\em believes} that $\phi$ is true'', depending on which terminology is appropriate for the setting we are working in.
The formula $\possible[\agentA] \phi$ may be read as ``agent $\agentA$ considers it possible that $\phi$ is true'', i.e. agent $\agentA$ doesn't know (or believe) that $\phi$ is not true.

\begin{definition}[Kripke model]
A {\em Kripke model}, $\modelAndTuple$ consists of:
\begin{itemize}
    \item A {\em domain} $\states$, which is a non-empty set of states (or {\em possible worlds}).
    \item An indexed set of {\em accessibility relations} $\accessibilityRel$, indexed on $\agents$, where for every $\agentA \in \agents$, $\accessibility{\agentA} \subseteq \states \times \states$ is a binary relation on states.
    \item A {\em valuation function} $\valuation : \atoms \to \powerset(\states)$, which is a function from propositional atoms to sets of states.
\end{itemize}
A {\em pointed Kripke model} $\pointedModelAndTuple{\stateS}$ consists of a Kripke model $\modelAndTuple$ along with a designated state $\stateS \in \states$.
\end{definition}

We write $\stateS \accessibility{\agentA} \stateT$ to denote that $(\stateS, \stateT) \in \accessibility{\agentA}$.
We write $\successors{\agentA}{\stateS}$ to denote the set of successor states $\successors{\agentA}{\stateS} = \{\stateT \in \states \mid \stateS \accessibility{\agentA} \stateT\}$ and
we write $\predecessors{\agentA}{\stateT}$ to denote the set of predecessor states $\predecessors{\agentA}{\stateT} = \{\stateS \in \states \mid \stateS \accessibility{\agentA} \stateT\}$.
As we will often be required to discuss several Kripke models at once, we will use the convention that $\pointedModelAndTuple{\stateS}$, $\pointedModelAndTuple[\prime]{\stateS[\prime]}$, $\pointedModelAndTuple[\gamma]{\stateS[\gamma]}$, etc.

We will be working with a variety of modal logics that are defined by relational properties on Kripke models.
We define those relational properties here.

\begin{definition}[Relational properties]
Let $\states$ be a set and let $\accessibilityRel \subseteq \states \times \states$ be a binary relation on $\states$. 
Then we say that $\accessibilityRel$ is\ldots
\begin{itemize}
    \item \ldots {\em serial} if and only if for every $\stateS \in \states$ there exists $\stateT \in \states$ such that $\stateS \accessibility{} \stateT$.
    \item \ldots {\em reflexive} if and only if for every $\stateS \in \states$: $\stateS \accessibility{} \stateS$.
    \item \ldots {\em transitive} if and only if for every $\stateS, \stateT, \stateU \in \states$: if $\stateS \accessibility{} \stateT$ and $\stateT \accessibility{} \stateU$ then $\stateS \accessibility{} \stateU$.
    \item \ldots {\em symmetric} if and only if for every $\stateS, \stateT \in \states$: if $\stateS \accessibility{} \stateT$ then $\stateT \accessibility{} \stateS$.
    \item \ldots {\em Euclidean} if and only if for every $\stateS, \stateT, \stateU \in \states$: if $\stateS \accessibility{} \stateT$ and $\stateS \accessibility{} \stateU$ then $\stateT \accessibility{} \stateU$.
\end{itemize}
\end{definition}

We say that a Kripke model $\modelAndTuple$ is \{serial, reflexive, etc.\} if and only if for every $\agentA \in \agents$ the binary relation $\accessibility{\agentA}$ is \{serial, reflexive, etc.\}.
We thus use these properties to define the classes of Kripke models that we will be working with.

\begin{definition}[Classes of Kripke models]
We define the following classes of Kripke models:
\begin{itemize}
    \item The class \classK{} of all Kripke models.
    \item The class \classKF{} of all transitive Kripke models.
    \item The class \classKFF{} of all transitive and Euclidean Kripke models.
    \item The class \classKD{} of all serial, transitive and Euclidean Kripke models.
    \item The class \classSF{} of all reflexive and transitive Kripke models.
    \item The class \classS{} of all reflexive, transitive and Euclidean Kripke models.
\end{itemize}
\end{definition}

We next define the semantics of modal logic.
We define the semantics in terms of a parameterised class of Kripke models, \classC{}, which could stand for \classK{}, \classKF{}, \classKFF{}, etc. or for any other class of Kripke models so defined.

\begin{definition}[Semantics of modal logic]\label{modal-semantics}
Let $\classC$ be a class of Kripke models, let $\phi \in \langMl$, and let $\pointedModelAndTuple{\stateS} \in \classC$ be a pointed Kripke model.
The interpretation of the formula $\phi$ in the logic \logicC{} on the pointed Kripke model $\pointedModel{\stateS}$ is defined inductively as:
$$
\begin{array}{lcl}
\pointedModel{\stateS} \entails \atomP & \text{ iff } & \stateS \in \valuation(\atomP)\\
\pointedModel{\stateS} \entails \lnot \phi & \text{ iff } & \pointedModel{\stateS} \nentails \phi\\
\pointedModel{\stateS} \entails \phi \land \psi & \text{ iff } & \pointedModel{\stateS} \entails \phi \text{ and } \pointedModel{\stateS} \entails \psi\\
\pointedModel{\stateS} \entails \necessary[\agentA] \phi & \text{ iff } & \text{for every } \stateT \in \successors{\agentA}{\stateS} : \pointedModel{\stateT} \entails \phi
\end{array}
$$
\end{definition}

Thus we get the definitions of the semantics of the modal logics \logicK{}, \logicKF{}, \logicKFF{}, etc. for the corresponding classes of Kripke models \classK{}, \classKF{}, \classKFF{}, etc.

Let $\pointedModelAndTuple{\stateS} \in \classC$ be a pointed Kripke model and
let $\Phi \subseteq \langMl$ be a (possibly infinite) set of formulas.
If $\pointedModel{\stateS} \entails \phi$ for every $\phi \in \Phi$ then we say that $\Phi$ is {\em valid} on $\pointedModel{\stateS}$ and we write $\pointedModel{\stateS} \entails \Phi$.
If $\pointedModel{\stateS} \entails \Phi$ for every $\stateS \in \states$ then we say that $\Phi$ is valid on $\model$ and we denote this by $\model \entails \Phi$.
If $\model \entails \Phi$ for every $\model \in \classC$ then we say that $\Phi$ is valid on \classC{} and we denote this by $\classC \entails \Phi$.
When \classC{} is clear from context we may simply write $\entails \Phi$ instead of $\classC \entails \Phi$.
If $\statesT \subseteq \states$ and there exists $\stateS \in \statesT$ such that $\pointedModel{\stateS} \entails \Phi$ then we say that $\Phi$ is {\em satisfiable} in $\pointedModel{\statesT}$.
If $\Phi$ is satisfiable in $\pointedModel{\states}$ then we say that $\Phi$ is satisfiable in $\model$.
If there exists $\model \in \classC$ such that $\Phi$ is satisfiable in $\model$ then we say that $\Phi$ is satisfiable in \classC{}.
If every finite subset of $\Phi$ is satisfiable in \{$\pointedModel{\statesT}$, $\model$, \classC{}\} then we say that $\Phi$ is {\em finitely satisfiable} in \{$\pointedModel{\statesT}$, $\model$, \classC{}\}.

We write $\interpretation[\model]{\phi}$ to denote the set of states where $\phi$ is valid, $\interpretation[\model]{\phi} = \{\stateS \in \states \mid \pointedModel{\stateS} \entails \phi\}$.

Finally we recall definitions and results related to bisimilarity of Kripke models.
Bisimilarity captures a notion of equivalence between Kripke models with respect to modal validity.

\begin{definition}[Bisimulation]
Let $\modelAndTuple \in \classK$ and $\modelAndTuple[\prime] \in \classK$ be Kripke models.
A non-empty relation $\bisimulation \subseteq \states \times \states[\prime]$ is a {\em bisimulation} if and only if for every $\atomP \in \atoms$, $\agentA \in \agents$ and $(\stateS, \stateS[\prime]) \in \bisimulation$ the following conditions, {\bf atoms-$\atomP$}, {\bf forth-$\agentA$} and {\bf back-$\agentB$} holds:

\paragraph{atoms-$\atomP$}
$\stateS \in \valuation(\atomP)$ if and only if $\stateS[\prime] \in \valuation[\prime](\atomP)$.

\paragraph{forth-$\agentA$}
for every $\stateT \in \successors{\agentA}{\stateS}$ there exists $\stateT[\prime] \in \successors[\prime]{\agentA}{\stateS[\prime]}$ such that $\stateS \bisimulation \stateT$.

\paragraph{back-$\agentA$}
for every $\stateT[\prime] \in \successors[\prime]{\agentA}{\stateS[\prime]}$ there exists $\stateT \in \successors{\agentA}{\stateS}$ such that $\stateS \bisimulation \stateT$.

If there exists a bisimulation $\bisimulation$ such that $\stateS \bisimulation \stateS[\prime]$ then we say that $\pointedModel{\stateS}$ and $\pointedModel[\prime]{\stateS[\prime]}$ are {\em bisimilar} and we denote this by $\pointedModel{\stateS} \bisimilar \pointedModel[\prime]{\stateS[\prime]}$.
\end{definition}

We first note that the bisimilarity relation forms an equivalence relation.

\begin{proposition}
The relation $\bisimilar$ is an equivalence relation (reflexive, transitive and symmetric) on Kripke models.
\end{proposition}

Bisimilar Kripke models are equivalent under modal validity.

\begin{proposition}
Let $\phi \in \langMl$ be a modal formula and 
let $\pointedModel{\stateS}, \pointedModel[\prime]{\stateS[\prime]} \in \classK$ be pointed Kripke models such that $\pointedModel{\stateS} \bisimilar \pointedModel[\prime]{\stateS[\prime]}$.
Then $\pointedModel{\stateS} \entails \phi$ if and only if $\pointedModel[\prime]{\stateS[\prime]} \entails \phi$.
\end{proposition}

The converse, that Kripke models that are equivalent under modal validity are also bisimilar doesn't hold in general.
However we note that the converse holds for modally saturated Kripke models, a notion that we define now.

\begin{definition}
Let $\modelAndTuple \in \classK$ be a Kripke model.
We say that $\model$ is {\em modally saturated} if and only if for every $\agentA \in \agents$, $\stateS \in \states$ and $\Phi \subseteq \langMl$: if $\Phi$ is finitely satisfiable in $\pointedModel{\successors{\agentA}{\stateS}}$ then $\Phi$ is satisfiable in $\pointedModel{\successors{\agentA}{\stateS}}$.
\end{definition}

\begin{proposition}
Let $\phi \in \langMl$ be a modal formula,
let $\model, \model[\prime] \in \classK$ be modally saturated Kripke models, and
let the relation $\bisimulation \subseteq \states \times \states[\prime]$ be defined such that $\stateS \bisimulation \stateS[\prime]$ if and only if for every $\phi \in \langMl$: $\pointedModel{\stateS} \entails \phi$ if and only if $\pointedModel[\prime]{\stateS[\prime]} \entails \phi$.
Then $\bisimulation$ is a bisimulation.
\end{proposition}

A notable class of modally saturated Kripke models are the image-finite Kripke models.

\begin{definition}[Image-finiteness]
Let $\modelAndTuple \in \classK$ be a Kripke model.
We say that $\model$ is {\em image-finite} if and only if for every $\agentA \in \agents$ and $\stateS \in \states$: $\successors{\agentA}{\stateS}$ is finite.
\end{definition}

\begin{proposition}
Every finite Kripke model is image-finite.
\end{proposition}

\begin{proposition}
Every image-finite Kripke model is modally saturated.
\end{proposition}

\subsection{Axiomatisations}

\begin{definition}[Axiomatisation \axiomK{}]
The axiomatisation \axiomK{} is a substitution schema consisting of the following axioms and rules:
$$
\begin{array}{rl}
    {\bf P}     & \text{All propositional tautologies}\\
    {\bf K}     & \proves \necessary[\agentA] (\phi \implies \psi) \implies (\necessary[\agentA] \phi \implies \necessary[\agentA] \psi)\\
    {\bf MP}    & \text{From } \proves \phi \implies \psi \text{ and } \proves \phi \text{ infer } \proves \psi\\
    {\bf NecK}  & \text{From } \proves \phi \text{ infer } \proves \necessary[\agentA] \phi
\end{array}
$$
\end{definition}

If $\proves \phi$ we say that $\phi$ is {\em provable} using the axiomatisation.
If $\Phi \subseteq \langMl$ is a (possibly infinite) set of formulas and there exists $\phi_1, \dots, \phi_n \in \Phi$ such that $\proves (\phi_1 \land \cdots \land \phi_n) \implies \phi$ then we say that $\phi$ is {\em deducible} from $\Phi$ and we write $\Phi \proves \phi$.
If every formula provable using the axiomatisation is valid in the corresponding semantics then we say that the axiomatisation is {\em sound} with respect to the logic.
If every formula valid in a semantics is provable using the corresponding axiomatisation then we say that the axiomatisation is {\em (weakly) complete} with respect to the semantics.
If every set of formulas that is consistent according to an axiomatisation is satisfiable in the corresponding semantics then we say that the axiomatisation is {\em strongly complete} with respect to the semantics.

\begin{proposition}
The axiomatisation \axiomK{} is sound and strongly complete with respect to the semantics of the logic \logicK{}.
\end{proposition}

\begin{definition}[Axiomatisations \axiomKF{}, \axiomKFF{}, \axiomKD{}, \axiomSF{}, and \axiomS{}]
We define the following axioms:
$$
\begin{array}{rl}
    {\bf D}     & \proves \necessary[\agentA] \phi \implies \possible[\agentA] \phi\\
    {\bf T}     & \proves \necessary[\agentA] \phi \implies \phi\\
    {\bf 4}     & \proves \necessary[\agentA] \phi \implies \necessary[\agentA] \necessary[\agentA] \phi\\
    {\bf 5}     & \proves \possible[\agentA] \phi \implies \necessary[\agentA] \possible[\agentA] \phi
\end{array}
$$

Then the axiomatisations \axiomKF{}, \axiomKFF{}, \axiomKD{}, \axiomSF{}, and \axiomS{} consist of the axioms and rules of \axiomK{} along with the following respective additional axioms:
\begin{itemize}
    \item \axiomKF{}: {\bf 4}
    \item \axiomKFF{}: {\bf 4} and {\bf 5}
    \item \axiomKD{}: {\bf D}, {\bf 4} and {\bf 5}
    \item \axiomSF{}: {\bf T} and {\bf 4}
    \item \axiomS{}: {\bf T} and {\bf 5}
\end{itemize}
\end{definition}

\begin{proposition}
The axiomatisations \axiomKF{}, \axiomKFF{}, \axiomKD{}, \axiomSF{}, and \axiomS{} are sound and strongly complete with respect to the semantics of the respective logics \logicKF{}, \logicKFF{}, \logicKD{}, \logicSF{}, and \logicS{}.
\end{proposition}

\section{Public announcement logic}

We recall definitions and results from the public announcement logic of Plaza~\cite{plaza:1989}.

\subsection{Syntax and semantics}

\begin{definition}[Language of public announcement logic]
The {\em language of public announcement logic}, \langPal{}, is inductively defined as:
$$
\phi ::= 
    \atomP \mid
    \lnot \phi \mid
    (\phi \land \phi) \mid
    \necessary[\agentA] \phi \mid
    \announceA{\phi} \phi
$$
where $\atomP \in \atoms$ and $\agentA \in \agents$.
\end{definition}

We use all of the standard abbreviations from modal logic, in addition to the standard abbreviation $\announceE{\phi} \psi ::= \lnot \announceA{\phi} \lnot \psi$.

The formula $\announceA{\phi} \psi$ may be read as ``if $\phi$ is true then after publicly announcing that it is true, $\psi$ is true''.
The formula $\announceE{\phi} \psi$ may be read as ``$\phi$ is true and after publicly announcing that it is true, $\psi$ is true''.

\begin{definition}[Model restriction]
Let $\modelAndTuple \in \classK$ be a Kripke model and let $\statesT \subseteq \states$.
We denote the {\em restriction of $\model$ to $\statesT$} by $\restrict{\model}{\statesT}$ and
define it as $\restrict{\model}{\statesT} = (\statesT, \restrict{\accessibilityRel}{\statesT}, \restrict{\valuation}{\statesT})$ where:
\begin{eqnarray*}
    \restrict{\accessibility{\agentA}}{\statesT} &=& \accessibility{\agentA} \cap (\statesT \times \statesT)\\
    \restrict{\valuation}{\statesT}(\atomP) &=& \valuation(\atomP) \cap \statesT
\end{eqnarray*}

Let \lang{} be a logical language with an interpretation on $\model$, and let $\phi \in \lang$.
We denote the {\em restriction of $\model$ to $\phi$} by $\restrict{\model}{\phi}$ and define it as $\restrict{\model}{\phi} = \restrict{\model}{\interpretation[\model]{\phi}}$.
\end{definition}

\begin{definition}[Semantics of public announcement logic]
Let $\phi \in \langPal$ and let $\pointedModelAndTuple{\stateS} \in \classS$ be a pointed Kripke model.
The interpretation of the formula $\phi$ in the logic \logicPalS{} on the pointed Kripke model $\pointedModel{\stateS}$ is the same as its interpretation in modal logic, defined in Definition~\ref{modal-semantics}, with the additional inductive case:
$$
\begin{array}{lcl}
\pointedModel{\stateS} \entails \announceA{\phi} \psi & \text{ iff } & \pointedModel{\stateS} \entails \phi \text{ implies } \restrict{\pointedModel{\stateS}}{\phi} \entails \psi
\end{array}
$$
\end{definition}

\subsection{Axiomatisation}

\begin{definition}[Axiomatisation \axiomPalS{}]
The axiomatisation \axiomPalS{} is a substitution schema consisting of the axioms and rules of \axiomS{} along with the following additional axioms and rules:
$$
\begin{array}{rl}
    {\bf AP} & \proves \announceA{\phi} \atomP \iff (\phi \implies \atomP)\\
    {\bf AN} & \proves \announceA{\phi} \lnot \psi \iff (\phi \implies \lnot \announceA{\phi} \psi)\\
    {\bf AC} & \proves \announceA{\phi} (\psi \land \chi) \iff (\announceA{\phi} \psi \land \announceA{\phi} \chi)\\
    {\bf AK} & \proves \announceA{\phi} \necessary[\agentA] \psi \iff (\phi \implies \necessary[\agentA] \announceA{\phi} \psi)\\
    {\bf AA} & \proves \announceA{\phi} \announceA{\psi} \chi \iff \announceA{\phi \land \announceA{\phi} \psi} \chi\\
    {\bf NecA} & \text{From } \proves \phi \text{ infer } \proves \announceA{\psi} \phi
\end{array}
$$
\end{definition}

\begin{proposition}
The axiomatisation \axiomPalS{} is sound and strongly complete with respect to the semantics of the logic \logicPalS{}.
\end{proposition}

\begin{proposition}
\logicPalS{} is expressively equivalent to \logicS{}.
\end{proposition}

\section{Action model logic}

We recall definitions and results from the action model logic of Baltag, Moss and Solecki~\cite{baltagetal:1998,baltagetal:2004}.

\subsection{Syntax and semantics}

\begin{definition}[Action models]
Let \lang{} be a logical language.
An {\em action model}, $\actionModelAndTuple$, with preconditions defined on \lang{}, consists of:
\begin{itemize}
    \item A {\em domain} $\actionStates$, which is a non-empty, finite set of action states.
    \item An indexed set of {\em accessibility relations} $\actionAccessibilityRel$, indexed on $\agents$, where for every $\agentA \in \agents$, $\actionAccessibility{\agentA} \subseteq \actionStates \times \actionStates$ is a binary relation on action states.
    \item A {\em precondition function} $\actionPrecondition : \actionStates \to \lang$, which is a function from action states to formulas of \lang{}.
\end{itemize}
A {\em pointed action model} $\pointedActionModelAndTuple{\actionStateS}$ consists of an action model $\actionModelAndTuple$ along with a designated action state $\actionStateS \in \actionStates$.
\end{definition}

\begin{definition}[Language of action model logic]
The {\em language of action model logic}, \langAml{}, is inductively defined inductively as:
$$
\phi ::= 
    \atomP \mid
    \lnot \phi \mid
    (\phi \land \phi) \mid
    \necessary[\agentA] \phi \mid
    \actionA{\pointedActionModel{\actionStateS}} \phi
$$
where $\atomP \in \atoms$, $\agentA \in \agents$ and $\pointedActionModel{\actionStateS} \in \classAM$ is an action model with preconditions defined on \langAml{}.
\end{definition}

\begin{definition}[Semantics of action model logic]
Let \classC{} be a class of Kripke models.

Let $\modelAndTuple \in \classC$ be a Kripke model and $\actionModelAndTuple \in \classAM$ be an action model with preconditions defined on \langAml{}.
We denote the result of executing the action model $\actionModel$ on the Kripke $\model$ as $\model \exec \actionModel$ and define it as $\model \exec \actionModel = \modelAndTuple[\prime]$ where:
\begin{eqnarray*}
    \states[\prime] &=& \{(\stateS, \actionStateS) \in \states \times \actionStates \mid \stateS \entails \actionPrecondition(\actionStateS)\}\\
    (\stateS, \actionStateS) \accessibility[\prime]{\agentA} (\stateT, \actionStateT) &\text{ iff }& \stateS \accessibility{\agentA} \stateT \text{ and } \actionStateS \actionAccessibility{\agentA} \actionStateT\\
    \valuation[\prime](\atomP) &=& \{(\stateS, \actionStateS) \in \states[\prime] \mid \stateS \in \valuation(\atomP)\}
\end{eqnarray*}
We denote the result of executing the multi-pointed action model $\pointedActionModel{\actionStatesT}$ on the multi-pointed Kripke $\pointedModel{\statesT}$ as $\pointedModel{\statesT} \exec \pointedActionModel{\actionStatesT}$ and define it as $\pointedModel{\statesT} \exec \pointedActionModel{\actionStatesT} = (\model[\prime], \actionStatesT[\prime])$ where $\modelAndTuple[\prime] = \model \exec \actionModel$ and $\statesT[\prime] = (\statesT \times \actionStatesT) \cap \states[\prime]$.

Let $\phi \in \langAml$ and let $\pointedModelAndTuple{\statesT} \in \classS$ be a multi-pointed Kripke model.
The interpretation of the formula $\phi$ in the logic \logicAmlS{} on the pointed Kripke model $\pointedModel{\statesT}$ is the same as its interpretation in modal logic, defined in Definition~\ref{modal-semantics}, with the additional inductive case:
$$
\begin{array}{lcl}
    \pointedModel{\statesT} \entails \actionA{\pointedActionModel{\actionStatesT}} \phi & \text { iff } & \pointedModel{\statesT} \entails \bigvee \actionPrecondition(\actionStatesT) \text{ and } \pointedModel{\statesT} \exec \pointedActionModel{\actionStatesT} \in \classC \text{ implies } \pointedModel{\statesT} \exec \pointedActionModel{\actionStatesT} \entails \phi
\end{array}
$$
\end{definition}

\subsection{Axiomatisation}
