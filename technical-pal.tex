\section{Public announcement logic}\label{pal}

We recall definitions and results from the public announcement logic of Plaza~\cite{plaza:1989}.
For an introductory text on public announcement logic we direct the reader to the book by van Ditmarsch, van der Hoek and Kooi~\cite{vanditmarsch:2007}.

\begin{definition}[Language of public announcement logic]
The {\em language of public announcement logic}, \langPal{}, is inductively defined as:
$$
\phi ::= 
    \atomP \mid
    \lnot \phi \mid
    \phi \land \phi \mid
    \necessaryA \phi \mid
    \announceA{\phi} \phi
$$
where $\atomP \in \atoms$ and $\agentA \in \agents$.
\end{definition}

We use all of the standard abbreviations from modal logic, in addition to the abbreviation $\announceE{\phi} \psi ::= \lnot \announceA{\phi} \lnot \psi$.

The formula $\announceA{\phi} \psi$ may be read as ``if $\phi$ is true then after publicly announcing that it is true, $\psi$ is true''.
The formula $\announceE{\phi} \psi$ may be read as ``$\phi$ is true and after publicly announcing that it is true, $\psi$ is true''.

As in modal logics, formulas of public announcement logic are interpreted over Kripke models.
The act of publicly announcing that a statement is true is modelled as an operation on Kripke models, a model restriction, that gives a new Kripke model representing the knowledge of the agents after witnessing the public announcement.

\begin{definition}[Model restriction]
Let $\kModelAndTuple$ be a Kripke model and let $\kStatesT \subseteq \kStates$.
We denote the {\em restriction of $\kModel$ to $\kStatesT$} by $\restrict{\kModel}{\kStatesT}$ and
define it as $\restrict{\kModel}{\kStatesT} = (\kStatesT, \restrict{\kAccessibilityRel}{\kStatesT}, \restrict{\kValuation}{\kStatesT})$ where:
\begin{eqnarray*}
    \restrict{\kAccessibilityA}{\kStatesT} &=& \kAccessibilityA \cap (\kStatesT \times \kStatesT)\\
    \restrict{\kValuation}{\kStatesT}(\atomP) &=& \kValuation(\atomP) \cap \kStatesT
\end{eqnarray*}

Let \lang{} be a logical language with an interpretation on $\kModel$, and let $\phi \in \lang$.
We denote the {\em restriction of $\kModel$ to $\phi$} by $\restrict{\kModel}{\phi}$ and define it as $\restrict{\kModel}{\phi} = \restrict{\kModel}{\interpretation[\kModel]{\phi}}$.
\end{definition}

We model the public announcement that a formula $\phi$ is true in an initial Kripke model $\kModel$ as a restriction $\restriction{\kModel}{\phi}$ of $\kModel$ to the states where $\phi$ was true in $\kModel$.
We thus define the semantics of public announcement logic.

\begin{definition}[Semantics of public announcement logic]\label{pal-semantics}
Let $\phi \in \langPal$ and let $\kPModelAndTuple{\kStateS} \in \classS$ be a pointed Kripke model.
The interpretation of the formula $\phi$ in the logic \logicPalS{} on the pointed Kripke model $\kPModel{\kStateS}$ is the same as its interpretation in modal logic, defined in Definition~\ref{ml-semantics}, with the additional inductive case:
$$
\begin{array}{lcl}
\kPModel{\kStateS} \entails \announceA{\phi} \psi & \text{ iff } & \kPModel{\kStateS} \entails \phi \text{ implies } \restrict{\kPModel{\kStateS}}{\phi} \entails \psi
\end{array}
$$
\end{definition}

We note that we only consider public announcement logic in the setting of \classS{}, as in the source material~\cite{plaza:1989}.

\begin{example}\label{example-pal-ml}
\begin{figure}
    \caption{An example of a Kripke model and the result of publicly announcing $\lnot \knowsB \atomP$ in that Kripke model.}\label{example-pal-ml-figure}
    \centering
    \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=7em,thick]

      \node[label=above left:{$\kStateS$}] (s) {\underline{$\{\atomP\}$}};
      \node[label=above left:{$\kStateT$}] (t) [above of=s] {$\{\}$};
      \node[label=above left:{$\kStateU$}] (u) [below of=s] {$\{\atomP\}$};
      \node[label=above:{$\kPModel{\kStateS}$},draw=black, fit=(s) (t) (u), inner sep=3.5em, dashed, rounded corners] {};

      \path[every node/.style={font=\sffamily\small},->]
        (s) edge [loop left] node {$\agentA, \agentB$} (s)
        (t) edge [loop left] node {$\agentA, \agentB$} (t)
        (u) edge [loop left] node {$\agentA, \agentB$} (u)
        (s) [<->] edge node {$\agentB$} (t)
        (s) edge node {$\agentA$} (u);

      \node[label=above right:{$\kStateS$}] (s') [right=11em of s]{\underline{$\{\atomP\}$}};
      \node[label=above right:{$\kStateT$}] (t') [above of=s'] {$\{\}$};
      \node[label=above:{$\kPModelP{\kStateS}$},draw=black, fit=(s') (t'), inner sep=3.5em, dashed, rounded corners] {};

      \path[every node/.style={font=\sffamily\small},->]
        (s') edge [loop right] node {$\agentA, \agentB$} (s')
        (t') edge [loop right] node {$\agentA, \agentB$} (t')
        (s') [<->] edge node {$\agentB$} (t');
    \end{tikzpicture}
\end{figure}
We recall the Kripke models $\kPModel{\kStateS}$ and $\kPModelP{\kStateS}$ given in Example~\ref{example-ml}.
The Kripke models $\kPModel{\kStateS}$ and $\kPModelP{\kStateS}$ are shown in Figure~\ref{example-pal-ml-figure}.

The Kripke model $\kPModelP{\kStateS}$ models the situation where Alice has looked at the coin, and considers it possible that Bob saw the coin.
Supposing that Bob were to publicly announce that he didn't see the coin, then $\kPModel{\kStateS}$ would model the result of this public announcement.
We can see this as $\interpretation[\kModelP]{\lnot \knowsB \atomP} = \{\kStateS, \kStateT\}$ and so $\kPModel{\kStateS} = \restrict{\kPModelP{\kStateS}}{\lnot \knowsB \atomP}$.
From Example~\ref{example-ml} we have that $\kPModelP{\kStateS} \entails \lnot \knowsA \lnot \knowsB \atomP$ and $\kPModel{\kStateS} \entails \knowsA \lnot \knowsB \atomP$.
Therefore we have that $\kPModelP{\kStateS} \entails \announceE{\lnot \knowsB \atomP} \knowsA \lnot \knowsB \atomP$.
So although initially Alice considers it possible that Bob saw the coin, after Bob publicly announces that he didn't, she knows that Bob didn't see the coin.
\end{example}

\begin{example}\label{example-pal}
\begin{figure}
    \caption{An example of a Kripke model and the result of publicly announcing $\knowsA \atomP$ in that Kripke model.}\label{example-pal-figure}
    \centering
    \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=7em,thick]

      \node[label=above right:{$\kStateS$}] (s) {\underline{$\{\atomP, \atomQ\}$}};
      \node[label=below right:{$\kStateT$}] (t) [below of=s] {$\{\atomP\}$};
      \node[label=above left:{$\kStateU$}] (u) [left of=s] {$\{\atomQ\}$};
      \node[label=below left:{$\kStateV$}] (v) [left of=t] {$\{\}$};
      \node[label=above:{$\kPModel{\kStateS}$},draw=black, fit=(s) (t) (u) (v), inner sep=3em, dashed, rounded corners] {};

      \path[every node/.style={font=\sffamily\small},->]
        (s) edge [loop above] node {$\agentA, \agentB$} (s)
        (t) edge [loop below] node {$\agentA, \agentB$} (t)
        (u) edge [loop above] node {$\agentA, \agentB$} (u)
        (v) edge [loop below] node {$\agentA, \agentB$} (v)
        (s) [<->] edge node {$\agentA$} (t)
        (u) [swap] edge node {$\agentA$} (v)
        (s) edge node {$\agentB$} (u)
        (t) [swap] edge node {$\agentB$} (v);

      \node[label=above left:{$\kStateS$}] (s') [right=9em of s]{\underline{$\{\atomP, \atomQ\}$}};
      \node[label=below left:{$\kStateT$}] (t') [below of=s'] {$\{\atomP\}$};
      \node[label=above:{$\restrict{\kPModel{\kStateS}}{\knowsA \atomP}$},draw=black, fit=(s') (t'), inner sep=3em, dashed, rounded corners] {};

      \path[every node/.style={font=\sffamily\small},->]
        (s') edge [loop above] node {$\agentA, \agentB$} (s')
        (t') edge [loop below] node {$\agentA, \agentB$} (t')
        (s') [<->] edge node {$\agentA$} (t');
    \end{tikzpicture}
\end{figure}
Let $\kPModelAndTuple{\kStateS}$ be a Kripke model where:

\begin{eqnarray*}
    \kStates &=& \{\kStateS, \kStateT, \kStateU, \kStateV\}\\
    \kAccessibilityA &=& \{(\kStateS, \kStateS), (\kStateS, \kStateT), (\kStateT, \kStateS), (\kStateT, \kStateT), (\kStateU, \kStateU), (\kStateU, \kStateV), (\kStateV, \kStateU), (\kStateV, \kStateV)\}\\
    \kAccessibilityB &=& \{(\kStateS, \kStateS), (\kStateS, \kStateU), (\kStateU, \kStateS), (\kStateU, \kStateU), (\kStateT, \kStateT), (\kStateT, \kStateV), (\kStateV, \kStateT), (\kStateV, \kStateV)\}\\
    \kValuation(\atomP) &=& \{\kStateS, \kStateT\}\\
    \kValuation(\atomQ) &=& \{\kStateU, \kStateV\}
\end{eqnarray*}

Then $\interpretation[\kModel]{\knowsA \atomP} = \{\kStateS, \kStateT\}$, and so $\kPModelP{\kStateS} = \restrict{\kPModel{\kStateS}}{\knowsA \atomP}$ is the model restriction of $\kPModel{\kStateS}$ to the states $\{\kStateS, \kStateT\}$, depicted in Figure~\ref{example-pal-figure}.  
In the resulting model restriction we have that $\kPModelP{\kStateS} \entails \knowsB \atomQ$, and so in the original model we therefore have $\kPModel{\kStateS} \entails \announceE{\knowsA \atomP} \knowsB \atomQ$.
That is, after it is publicly announced that $\agentA$ knows that $\atomP$ is true, then agent $\agentB$ knows that $\atomQ$ is true.

We also note that $\interpretation[\kModel]{\atomP \land \lnot \knowsB \atomP} = \{\kStateS, \kStateT\}$, and so $\kPModelP{\kStateS} = \restrict{\kPModel{\kStateS}}{\atomP \land \lnot \knowsB \atomP}$.
However in the resulting model restriction we have that $\kPModelP{\kStateS} \entails \lnot \knowsB (\atomP \land \lnot \knowsB \atomP)$, and so in the original model we therefore have $\kPModel{\kStateS} \entails \announceE{\atomP \land \lnot \knowsB \atomP} \lnot \knowsB (\atomP \land \lnot \knowsB \atomP)$.
That is, after it is publicly announced that $\atomP$ is true and agent $\agentB$ doesn't know that $\atomP$ is true, then $\agentB$ doesn't know this fact.
\end{example}

We provide an axiomatisation for the logic \logicPalS{}.

\begin{definition}[Axiomatisation \axiomPalS{}]
The axiomatisation \axiomPalS{} is a substitution schema consisting of the axioms and rules of \axiomS{} along with the following additional axioms and rules:
$$
\begin{array}{rl}
    {\bf AP} & \proves \announceA{\phi} \atomP \iff (\phi \implies \atomP)\\
    {\bf AN} & \proves \announceA{\phi} \lnot \psi \iff (\phi \implies \lnot \announceA{\phi} \psi)\\
    {\bf AC} & \proves \announceA{\phi} (\psi \land \chi) \iff (\announceA{\phi} \psi \land \announceA{\phi} \chi)\\
    {\bf AK} & \proves \announceA{\phi} \necessaryA \psi \iff (\phi \implies \necessaryA \announceA{\phi} \psi)\\
    {\bf AA} & \proves \announceA{\phi} \announceA{\psi} \chi \iff \announceA{\phi \land \announceA{\phi} \psi} \chi\\
    {\bf NecA} & \text{From } \proves \phi \text{ infer } \proves \announceA{\psi} \phi
\end{array}
$$
\end{definition}

We note that the axiomatisation \axiomPalS{} forms a set of reduction axioms, admitting a provably correct translation from the language \langPal{} of public announcement logic to the language \langMl{} of modal logic.
This works as the axioms {\bf AN}, {\bf AC}, {\bf AK}, and {\bf AA} may be applied to ``push'' the public announcement operators past negations, conjunctions, modalities and other public announcement operators, until they are applied only to propositional atoms, where the axiom {\bf AP} may be applied to replace the formula with a modal formula.
Therefore we have that \logicPalS{} is expressively equivalent to \logicS{} and so we get other results for the logic from the corresponding results for \logicS{}.

\begin{proposition}
The axiomatisation \axiomPalS{} is sound and strongly complete with respect to the semantics of the logic \logicPalS{}.
\end{proposition}

\begin{proposition}
The logic \logicPalS{} is expressively equivalent to the logic \logicS{}.
\end{proposition}

\begin{proposition}
The logic \logicPalS{} is bisimulation invariant.
\end{proposition}

\begin{proposition}
The logic \logicPalS{} is compact.
\end{proposition}

\begin{proposition}
The satisfiability problem for the logic \logicPalS{} is decidable.
\end{proposition}
