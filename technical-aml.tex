\section{Action model logic}\label{aml}

We recall definitions and results from the action model logic of Baltag, Moss and Solecki~\cite{baltag:1998,baltag:2004}.
For an introductory text on action model logic we direct the reader to the book by van Ditmarsch, van der Hoek and Kooi~\cite{vanditmarsch:2007}.
Many simple or well-known propositions are given without proof and left as an exercise for the curious reader.

We first introduce action models.

\begin{definition}[Action models]
Let \lang{} be a logical language.
An {\em action model with preconditions defined on \lang{}}, $\aModelAndTuple$ consists of an underlying Kripke frame $\aFrameAndTuple$ along with a {\em precondition function} $\aPrecondition : \aStates \to \lang$, which is a function from actions to formulas.

A {\em pointed action model} $\aPModelAndTuple{\aStateS}$ consists of an action model $\aModelAndTuple$ along with a designated action $\aStateS \in \aStates$.
A {\em multi-pointed action model} $\aPModelAndTuple{\aStatesT}$ consists of an action model $\aModelAndTuple$ along with a non-empty set of designated action $\aStatesT \subseteq \aStates$.
\end{definition}

We use similar notation and terminology to Kripke models when discussing action models.
Similar to Kripke models, when we ascribe relational properties or frame properties to an action model we actually ascribe those properties to its underlying Kripke frame.
When the language that an action model is defined on is clear from context we will simply refer to an {\em action model}, without explicit reference to the language.

As the action model logic will reason about the effects of specific action models, we need to represent action models in the language of action model logic.
However action models are defined with respect to a logical language which their preconditions are defined over.
To avoid a circular definition Baltag and Moss~\cite{baltag:2004} use the notion of an action signature.

\begin{definition}[Action signature]
An {\em action signature}, $\aSignatureAndTuple$ consists of an underlying Kripke frame $\aFrameAndTuple$ along with a non-repeating list of {\em non-trivial actions}, $\aStateS_1, \dots, \aStateS_n \in \aStates$.

Let $\lang$ be a logical language where $\top \in \lang$, and let $\phi_1, \dots, \phi_n \in \lang$ be a list of formulas.
Then we can obtain an action model $\aSignature(\phi_1, \dots, \phi_n) = \aModelTuple$ with preconditions defined on $\lang$, where $\aPrecondition(\aStateS_i) = \phi_i$ for $i = 1, \dots, n$ and $\aPrecondition(\aStateS) = \top$ otherwise.
The {\em trivial actions} are so named because their preconditions are always set to $\top$.
\end{definition}

When we ascribe relational or frame properties to an action model or signature we actually ascribe those properties to its underlying Kripke frame.
As we will often work with action models and signatures rather than Kripke frames we overload the notation for classes of Kripke frames to also refer to classes of action models or signatures.

In the language of action model logic we use action signatures instead of action models.
However the syntax allows for applying a list of formulas to an action signature, so we can construct an action model by combining the action signature with the list of formulas.

\begin{definition}[Language of action model logic]
Let \aSignatureFamily{} be a non-empty, countable set of action signatures.
The {\em language of action model logic} with action signatures \aSignatureFamily{}, $\langAml(\aSignatureFamily)$, is inductively defined as:
$$
\phi ::=
    \atomP \mid
    \lnot \phi \mid
    \phi \land \phi \mid
    \necessaryA \phi \mid
    \actionA{\aSignature \aStatesT, \phi, \dots, \phi} \phi
$$
where $\atomP \in \atoms$, $\agentA \in \agents$, $\aSignatureAndTuple \in \aSignatureFamily$, $\aStatesT \subseteq \aStates$, and the number of parameters to a given action signature $\aSignature$ is determined by the number of designated actions in the action signature.
\end{definition}

We use all of the standard abbreviations from modal logic, in addition to the abbreviations 
$\actionA{\aPModel{\aStatesT}} \phi ::= \actionA{\aSignature \aStatesT, \phi_1, \dots, \phi_n} \phi$ where $\aModel = \aSignature(\phi_1, \dots, \phi_n)$ and 
$\actionE{\aPModel{\aStatesT}} \phi ::= \lnot \actionA{\aPModel{\aStatesT}} \lnot \phi$.

\begin{definition}[Semantics of action model logic]\label{aml-semantics}
Let \classC{} be a class of Kripke models and let \aSignatureFamily{} be a non-empty, countable set of action signatures.
We define the semantics of action model logic and the notion of action model execution simultaneously.

Let $\kModelAndTuple \in \classC$ be a Kripke model and $\aModelAndTuple \in \classK$ be an action model with preconditions defined on $\langAml(\aSignatureFamily)$.
We denote the result of executing the action model $\aModel$ on the Kripke model $\kModel$ as $\kModel \exec \aModel$ and define it as $\kModel \exec \aModel = \kModelTupleP$ where:
\begin{eqnarray*}
    \kStatesP &=& \{(\kStateS, \aStateS) \in \kStates \times \aStates \mid \kPModel{\kStateS} \entails \aPrecondition(\aStateS)\}\\
    (\kStateS, \aStateS) \kAccessibilityPA (\kStateT, \aStateT) &\text{ iff }& \kStateS \kAccessibilityA \kStateT \text{ and } \aStateS \aAccessibilityA \aStateT\\
    \kValuationP(\atomP) &=& \{(\kStateS, \aStateS) \in \kStatesP \mid \kStateS \in \kValuation(\atomP)\}
\end{eqnarray*}
We denote the result of executing the pointed action model $\aPModel{\aStateS}$ on the pointed Kripke model $\kPModel{\kStateS}$ as $\kPModel{\kStateS} \exec \aPModel{\aStateS}$ and define it as $\kPModel{\kStateS} \exec \aPModel{\aStateS} = (\kModel \exec \aModel, (\kStateS, \aStateS))$. Note that $\kPModel{\kStateS} \exec \aPModel{\aStateS}$ is undefined if $\kPModel{\kStateS} \nentails \aPrecondition(\aStateS)$ as then $(\kStateS, \aStateS) \notin \kStatesP$.

Let $\phi \in \langAml(\aSignatureFamily)$ and let $\kPModelAndTuple{\kStateS} \in \classC$ be a pointed Kripke model.
The interpretation of the formula $\phi$ in the logic \logicAmlC{} on the pointed Kripke model $\kPModel{\kStateS}$ is the same as its interpretation in modal logic, defined in Definition~\ref{ml-semantics}, with the additional inductive cases:
$$
\begin{array}{lcl}
    \kPModel{\kStateS} \entails \actionA{\aPModel{\aStateS}} \phi & \text { iff } & \kPModel{\kStateS} \entails \aPrecondition(\aStateS) \text{ implies } \kPModel{\kStateS} \exec \aPModel{\aStateS} \entails \phi\\
    \kPModel{\kStateS} \entails \actionA{\aPModel{\aStatesT}} \phi & \text { iff } & \text{for every } \aStateS \in \aStatesT: \kPModel{\kStateS} \entails \actionA{\aPModel{\aStateS}} \phi
\end{array}
$$
\end{definition}

We are interested in the following variants of action model logic:
\begin{itemize}
    \item \logicAmlK{} interpreted over the class of \classK{} Kripke frames and the language of action model logic $\langAml(\classK)$ with action signatures defined on the class of finite \classK{} Kripke frames.
    \item \logicAmlKFF{} interpreted over the class of \classKFF{} Kripke frames and the language of action model logic $\langAml(\classKFF)$ with action signatures defined on the class of finite \classKFF{} Kripke frames.
    \item \logicAmlS{} interpreted over the class of \classS{} Kripke frames and the language of action model logic $\langAml(\classS)$ with action signatures defined on the class of finite \classS{} Kripke frames.
\end{itemize}

\begin{proposition}
    Let $\kModel \in \classKFF$ and $\aModel \in \classAmKFF$. Then $\kModel \exec \aModel \in \classKFF$.
\end{proposition}

\begin{proposition}
    Let $\kModel \in \classS$ and $\aModel \in \classAmS$. Then $\kModel \exec \aModel \in \classS$.
\end{proposition}

We give some examples of \logicAml{}.

\begin{example}\label{example-pal-ml}
\begin{figure}
    \caption{An example of a Kripke model and the result of publicly announcing $\lnot \knowsB \atomP$ in that Kripke model.}\label{example-pal-ml-figure}
    \centering
    \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=7em,thick]

      \node[label=above left:{$\kStateS$}] (s) {\underline{$\{\atomP\}$}};
      \node[label=above left:{$\kStateT$}] (t) [above of=s] {$\{\}$};
      \node[label=above left:{$\kStateU$}] (u) [below of=s] {$\{\atomP\}$};
      \node[label=above:{$\kPModelP{\kStateS}$},draw=black, fit=(s) (t) (u), inner sep=3.5em, dashed, rounded corners] {};

      \path[every node/.style={font=\sffamily\small},->]
        (s) edge [loop left] node {$\agentA, \agentB$} (s)
        (t) edge [loop left] node {$\agentA, \agentB$} (t)
        (u) edge [loop left] node {$\agentA, \agentB$} (u)
        (s) [<->] edge node {$\agentB$} (t)
        (s) edge node {$\agentA$} (u);

      \node [right=4em of s] (exec) {$\exec$};

      \node[label=above left:{$\aStateS$}] [right = 4em of exec] (as) {\underline{$\lnot \knowsB \atomP$}};
      \node[label=above:{$\aPModel{\aStateS}$},draw=black, fit=(as), inner sep=3.5em, dashed, rounded corners] {};

      \path[every node/.style={font=\sffamily\small},->]
        (as) edge [loop left] node {$\agentA, \agentB$} (as);

      \node [right=4em of as] (equals) {$=$};

      \node[label=above right:{$(\kStateS, \aStateS)$}] (s') [right=4em of equals]{\underline{$\{\atomP\}$}};
      \node[label=above right:{$(\kStateT, \aStateS)$}] (t') [above of=s'] {$\{\}$};
      \node[label=above:{$\kPModelP{(\kStateS, \aStateS)}$},draw=black, fit=(s') (t'), inner sep=3.5em, dashed, rounded corners] {};

      \path[every node/.style={font=\sffamily\small},->]
        (s') edge [loop right] node {$\agentA, \agentB$} (s')
        (t') edge [loop right] node {$\agentA, \agentB$} (t')
        (s') [<->] edge node {$\agentB$} (t');
    \end{tikzpicture}
\end{figure}
Let $\kPModelAndTupleP{\kStateS}$ be a Kripke model where:
\begin{eqnarray*}
    \kStatesP &=& \{\kStateS, \kStateT, \kStateU\}\\
    \kAccessibilityPA &=& \{(\kStateS, \kStateS), (\kStateT, \kStateT), (\kStateS, \kStateU), (\kStateU, \kStateS), (\kStateU, \kStateU)\}\\
    \kAccessibilityPB &=& \{(\kStateS, \kStateS), (\kStateS, \kStateT), (\kStateT, \kStateS), (\kStateT, \kStateT), (\kStateU, \kStateU)\}\\
    \kValuationP(\atomP) &=& \{\kStateS, \kStateU\}
\end{eqnarray*}
and let $\aPModelAndTuple{\aStateS}$ be an action model where:
\begin{eqnarray*}
    \aStates &=& \{\aStateS\}\\
    \aAccessibilityA = \aAccessibilityB &=& \{(\aStateS, \aStateS)\}\\\
    \aPrecondition(\aStateS) &=& \lnot \knowsB \atomP
\end{eqnarray*}
Then $\kPModelP{\kStateS} \exec \aPModel{\aStateS} = \kPModelAndTuple{(\kStateS, \aStateS)}$ where:
\begin{eqnarray*}
    \kStates &=& \{(\kStateS, \aStateS), (\kStateT, \aStateS)\}\\
    \kAccessibilityA &=& \{((\kStateS, \aStateS), (\kStateS, \aStateS)), ((\kStateT, \aStateS), (\kStateT, \aStateS))\}\\
    \kAccessibilityB &=& \{((\kStateS, \aStateS), (\kStateS, \aStateS)), ((\kStateS, \aStateS), (\kStateT, \aStateS)), ((\kStateT, \aStateS), (\kStateS, \aStateS)), ((\kStateT, \aStateS), (\kStateT, \aStateS))\}\\
    \kValuation(\atomP) &=& \{(\kStateS, \aStateS)\}
\end{eqnarray*}

The Kripke models $\kPModel{\kStateS}$ and $\kPModelP{\kStateS}$, and the action model $\aPModel{\aStateS}$ are shown in Figure~\ref{example-pal-ml-figure}.
We note that $\kPModel{\kStateS}$ and $\kPModelP{\kStateS}$ are essentially the same as the Kripke models from Example~\ref{example-ml}.
We also note that the action model $\aPModel{\aStateS}$ has essentially the same effect as a public announcement of $\lnot \knowsB \atomP$.

The Kripke model $\kPModelP{\kStateS}$ models the situation where Alice has looked at the coin, and considers it possible that Bob saw the coin.
Supposing that Bob were to publicly announce that he didn't see the coin, then $\kPModel{\kStateS}$ would model the result of this public announcement.
From Example~\ref{example-ml} we have that $\kPModelP{\kStateS} \entails_\logicAmlK \knowsA \lnot \knowsB \atomP$.
Therefore we have that $\kPModelP{\kStateS} \entails_\logicAmlK \actionE{\aPModel{\aStateS}} \knowsA \lnot \knowsB \atomP$.
So although initially Alice considers it possible that Bob saw the coin, after Bob publicly announces that he didn't, she knows that Bob didn't see the coin.
\end{example}

\begin{example}\label{example-pal-ml-reverse}
\begin{figure}
    \caption{An example of a Kripke model and the result of executing an action model in that Kripke model.}\label{example-pal-ml-reverse-figure}
    \centering
    \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=7em,thick]

      \node[label=above right:{$\kStateS$}] (s') {\underline{$\{\atomP\}$}};
      \node[label=above right:{$\kStateT$}] (t') [above of=s'] {$\{\}$};
      \node[label=above:{$\kPModel{\kStateS}$},draw=black, fit=(s') (t'), inner sep=3.5em, dashed, rounded corners] {};

      \path[every node/.style={font=\sffamily\small},->]
        (s') edge [loop right] node {$\agentA, \agentB$} (s')
        (t') edge [loop right] node {$\agentA, \agentB$} (t')
        (s') [<->] edge node {$\agentB$} (t');

      \node [right=4em of s] (exec) {$\exec$};

      \node[label=above left:{$\aStateS$}] [right = 4em of exec] (as) {\underline{$\top$}};
      \node[label=above left:{$\aStateT$}] [below of = as] (at) {$\atomP$};
      \node[label=above:{$\aPModel{\aStateS}$},draw=black, fit=(as) (at), inner sep=3.5em, dashed, rounded corners] {};

      \path[every node/.style={font=\sffamily\small},->]
        (as) edge [loop left] node {$\agentA, \agentB$} (as)
        (as) edge [<->] node {$\agentA$} (at)
        (at) edge [loop left] node {$\agentA, \agentB$} (at);

      \node [right=4em of as] (equals) {$=$};

      \node[label=above left:{$(\kStateS, \aStateS)$}] (s) [right=4em of equals] {\underline{$\{\atomP\}$}};
      \node[label=above left:{$(\kStateT, \aStateS)$}] (t) [above of=s] {$\{\}$};
      \node[label=above left:{$(\kStateS, \aStateT)$}] (u) [below of=s] {$\{\atomP\}$};
      \node[label=above:{$\kPModelP{(\kStateS, \aStateS)}$},draw=black, fit=(s) (t) (u), inner sep=3.5em, dashed, rounded corners] {};

      \path[every node/.style={font=\sffamily\small},->]
        (s) edge [loop left] node {$\agentA, \agentB$} (s)
        (t) edge [loop left] node {$\agentA, \agentB$} (t)
        (u) edge [loop left] node {$\agentA, \agentB$} (u)
        (s) [<->] edge node {$\agentB$} (t)
        (s) edge node {$\agentA$} (u);

    \end{tikzpicture}
\end{figure}
Let $\kPModelAndTuple{\kStateS}$ be a Kripke model where:
\begin{eqnarray*}
    \kStates &=& \{\kStateS, \kStateT\}\\
    \kAccessibilityA &=& \{(\kStateS, \kStateS), (\kStateT, \kStateT)\}\\
    \kAccessibilityB &=& \{(\kStateS, \kStateS), (\kStateS, \kStateT), (\kStateT, \kStateS), (\kStateT, \kStateT)\}\\
    \kValuation(\atomP) &=& \{\kStateS\}
\end{eqnarray*}
and let $\aPModelAndTuple{\aStateS}$ be an action model where:
\begin{eqnarray*}
    \aStates &=& \{\aStateS, \aStateT\}\\
    \aAccessibilityA &=& \{(\aStateS, \aStateS), (\aStateS, \aStateT), (\aStateT, \aStateS), (\aStateT, \aStateT)\}\\\
    \aAccessibilityB &=& \{(\aStateS, \aStateS), (\aStateT, \aStateT)\}\\\
    \aPrecondition(\aStateS) &=& \top\\
    \aPrecondition(\aStateT) &=& \atomP\\
\end{eqnarray*}
Then $\kPModel{\kStateS} \exec \aPModel{\aStateS} = \kPModelAndTupleP{(\kStateS, \aStateS)}$ where:
\begin{eqnarray*}
    \kStatesP &=& \{(\kStateS, \aStateS), (\kStateT, \aStateS), (\kStateU, \aStateT)\}\\
    \kAccessibilityPA &=& \{((\kStateS, \aStateS), (\kStateS, \aStateS)), ((\kStateT, \aStateS), (\kStateT, \aStateS)), ((\kStateS, \aStateS), (\kStateU, \aStateT)), ((\kStateU, \aStateT), (\kStateS, \aStateS)), ((\kStateU, \aStateT), (\kStateU, \aStateT))\}\\
    \kAccessibilityPB &=& \{((\kStateS, \aStateS), (\kStateS, \aStateS)), ((\kStateS, \aStateS), (\kStateT, \aStateS)), ((\kStateT, \aStateS), (\kStateS, \aStateS)), ((\kStateT, \aStateS), (\kStateT, \aStateS)), ((\kStateU, \aStateT), (\kStateU, \aStateT))\}\\
    \kValuationP(\atomP) &=& \{(\kStateS, \aStateS), (\kStateU, \aStateT)\}
\end{eqnarray*}

The Kripke models $\kPModel{\kStateS}$ and $\kPModelP{\kStateS}$, and the action model $\aPModel{\aStateS}$ are shown in Figure~\ref{example-pal-ml-reverse-figure}.
We note that $\kPModel{\kStateS}$ and $\kPModelP{\kStateS}$ are essentially the same as (are isomorphic to) the Kripke models from Example~\ref{example-ml}.

The Kripke model $\kPModel{\kStateS}$ models the situation where Alice has looked at the coin and is certain that Bob didn't see the coin.
Supposing that Alice were to leave the room with the coin in it, Alice would consider it possible that Bob looked at the coin.
From Example~\ref{example-ml} we have that $\kPModelP{\kStateS} \entails_\logicAmlK \possibleA \knowsB \atomP$.
Therefore we have that $\kPModel{\kStateS} \entails_\logicAmlK \actionE{\aPModel{\aStateS}} \possibleA \knowsB \atomP$.
So although initially Alice knew that Bob didn't see the coin, after leaving the room Alice considers it possible that Bob saw at the coin.

We note that $\kPModel{\kStateS}$ and $\kPModelP{\kStateS}$ are essentially the same as (are isomorphic to) the Kripke models from the previous example, Example~\ref{example-pal-ml}.
This demonstrates that in some situations the effects of an action model can be reversed by another action model. 
\end{example}

\begin{example}\label{example-pal}
\begin{figure}
    \caption{An example of a Kripke model and the result of publicly announcing $\knowsA \atomP$ in that Kripke model.}\label{example-pal-figure}
    \centering
    \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=7em,thick]

      \node[label=above right:{$\kStateS$}] (s) {\underline{$\{\atomP, \atomQ\}$}};
      \node[label=below right:{$\kStateT$}] (t) [below of=s] {$\{\atomP\}$};
      \node[label=above left:{$\kStateU$}] (u) [left of=s] {$\{\atomQ\}$};
      \node[label=below left:{$\kStateV$}] (v) [left of=t] {$\{\}$};
      \node[label=above:{$\kPModel{\kStateS}$},draw=black, fit=(s) (t) (u) (v), inner sep=3em, dashed, rounded corners] {};

      \path[every node/.style={font=\sffamily\small},->]
        (s) edge [loop above] node {$\agentA, \agentB$} (s)
        (t) edge [loop below] node {$\agentA, \agentB$} (t)
        (u) edge [loop above] node {$\agentA, \agentB$} (u)
        (v) edge [loop below] node {$\agentA, \agentB$} (v)
        (s) [<->] edge node {$\agentA$} (t)
        (u) [swap] edge node {$\agentA$} (v)
        (s) edge node {$\agentB$} (u)
        (t) [swap] edge node {$\agentB$} (v);

      \node[label=above left:{$(\kStateS, \aStateS)$}] (s') [right=9em of s]{\underline{$\{\atomP, \atomQ\}$}};
      \node[label=below left:{$(\kStateT, \aStateS)$}] (t') [below of=s'] {$\{\atomP\}$};
      \node[label=above:{$\kPModelP{(\kStateS, \aStateS)}$},draw=black, fit=(s') (t'), inner sep=3em, dashed, rounded corners] {};

      \path[every node/.style={font=\sffamily\small},->]
        (s') edge [loop above] node {$\agentA, \agentB$} (s')
        (t') edge [loop below] node {$\agentA, \agentB$} (t')
        (s') [<->] edge node {$\agentA$} (t');
    \end{tikzpicture}
\end{figure}
Let $\kPModelAndTuple{\kStateS}$ be a Kripke model where:
\begin{eqnarray*}
    \kStates &=& \{\kStateS, \kStateT, \kStateU, \kStateV\}\\
    \kAccessibilityA &=& \{(\kStateS, \kStateS), (\kStateS, \kStateT), (\kStateT, \kStateS), (\kStateT, \kStateT), (\kStateU, \kStateU), (\kStateU, \kStateV), (\kStateV, \kStateU), (\kStateV, \kStateV)\}\\
    \kAccessibilityB &=& \{(\kStateS, \kStateS), (\kStateS, \kStateU), (\kStateU, \kStateS), (\kStateU, \kStateU), (\kStateT, \kStateT), (\kStateT, \kStateV), (\kStateV, \kStateT), (\kStateV, \kStateV)\}\\
    \kValuation(\atomP) &=& \{\kStateS, \kStateT\}\\
    \kValuation(\atomQ) &=& \{\kStateS, \kStateU\}
\end{eqnarray*}
and let $\aPModelAndTuple{\aStateS}$ be an action model where:
\begin{eqnarray*}
    \aStates &=& \{\aStateS\}\\
    \aAccessibilityA = \aAccessibilityB &=& \{(\aStateS, \aStateS)\}\\\
    \aPrecondition(\aStateS) &=& \atomP \land \lnot \knowsB \atomP
\end{eqnarray*}
Then $\kPModel{\kStateS} \exec \aPModel{\aStateS} = \kPModelAndTupleP{(\kStateS, \aStateS)}$ where:
\begin{eqnarray*}
    \kStatesP &=& \{(\kStateS, \aStateS), (\kStateT, \aStateS)\}\\
    \kAccessibilityPA &=& \{((\kStateS, \aStateS), (\kStateS, \aStateS)), ((\kStateS, \aStateS), (\kStateT, \aStateS)), ((\kStateT, \aStateS), (\kStateS, \aStateS)), ((\kStateT, \aStateS), (\kStateT, \aStateS))\}\\
    \kAccessibilityPB &=& \{((\kStateS, \aStateS), (\kStateS, \aStateS)), ((\kStateT, \aStateS), (\kStateT, \aStateS))\}\\
    \kValuationP(\atomP) &=& \{(\kStateS, \aStateS), (\kStateT, \aStateS)\}\\
    \kValuationP(\atomQ) &=& \{(\kStateS, \aStateS)\}
\end{eqnarray*}
The Kripke models $\kPModel{\kStateS}$ and $\kPModelP{\kStateS}$ are shown in Figure~\ref{example-pal-figure}.
We note that the action model $\aPModel{\aStateS}$ has essentially the same effect as a public announcement of $\atomP \land \lnot \knowsB \atomP$.

In the resulting model we have that $\kPModelP{\kStateS} \entails_\logicAmlK \knowsB \atomQ$, so in the original model we have $\kPModel{\kStateS} \entails_\logicAmlK \actionE{\aPModel{\aStateS}} \knowsB \atomQ$.
That is, publicly announcing that $\atomP$ is true and agent $\agentB$ doesn't know that $\atomP$ is true results in agent $\agentB$ knowing that $\atomQ$ is true.

In the resulting model we also have that $\kPModelP{\kStateS} \entails_\logicAmlK \lnot (\atomP \land \lnot \knowsB \atomP)$, so in the original model we have $\kPModel{\kStateS} \entails_\logicAmlK \actionE{\aPModel{\aStateS}} \lnot (\atomP \land \lnot \knowsB \atomP)$.
That is, publicly announcing that $\atomP \land \lnot \knowsB \atomP$ is true results in $\atomP \land \lnot \knowsB \atomP$ becoming false.

Although we do not show it formally here, the effects of this action model cannot be reversed by another action model.
\end{example}

\begin{definition}[Skip and crash]
    We define the action models \aSkip{} and \aCrash{} as follows:
    \begin{eqnarray*}
        \aSkip &=& ((\{\aStateS\}, \{(\aStateS, \aStateS)\}, \{(\aStateS, \top)\}), \aStateS)\\
        \aCrash &=& ((\{\aStateS\}, \{(\aStateS, \aStateS)\}, \{(\aStateS, \bot)\}), \aStateS)
    \end{eqnarray*}
\end{definition}

The action model \aSkip{} is intended to represent an epistemic update that always succeeds and has no effect,
whereas the action model \aCrash{} is intended to represent an epistemic update that never succeeds.
Indeed we note that $\entails \actionE{\aSkip} \top$, $\entails \actionA{\aSkip} \phi \iff \phi$ and $\entails \lnot \actionE{\aCrash} \top$.

We note that as $\top$ and $\bot$ are in the language $\langAml(\aSignatureFamily)$ for any set of action signatures $\aSignatureFamily$, and so \aSkip{} and \aCrash{} are action models with preconditions defined on $\langAml(\aSignatureFamily)$.
However a given $\aSignatureFamily$ may not contain any action signature that would allow one to construct \aSkip{} or \aCrash{}, so statements about \aSkip{} and \aCrash{} may not be allowed by the language $\langAml(\aSignatureFamily)$.

\begin{definition}[Disjoint union]\label{aml-choice}
    Let $\aPModelAndTuple{\aStatesT}$ and $\aPModelAndTupleP{\aStatesTP}$ be action models such that $\aStates$ and $\aStatesP$ are disjoint.
    We denote the {\em disjoint union of $\aPModel{\aStatesT}$ and $\aPModelP{\aStatesTP}$} as $\aPModel{\aStatesT} \choice \aPModelP{\aStatesTP}$ and define it as $\aPModel{\aStatesT} \choice \aPModelP{\aStatesTP} = \aPModelAndTuplePP{\aStatesTPP}$ where:
    \begin{eqnarray*}
        \aStatesPP &=& \aStates \cup \aStatesP\\
        \aAccessibilityPPA &=& \aAccessibilityA \cup \aAccessibilityPA\\
        \aPreconditionPP &=& \aPrecondition \cup \aPreconditionP\\
        \aStatesTPP &=& \aStatesT \cup \aStatesTP
    \end{eqnarray*}
\end{definition}

The operation of disjoint union of action models is intended to represent the epistemic update that is formed by the non-deterministic choice between two epistemic updates.
Indeed we note that $\entails \actionA{\aPModel{\aStatesT} \choice \aPModelP{\aStatesTP}} \phi \iff (\actionA{\aPModel{\aStatesT}} \phi \land \actionA{\aPModelP{\aStatesTP}} \phi)$.

We will sometimes take the `disjoint' union of two action models that are not actually disjoint and we assume in this case that we implicitly rename the actions in each action model so that the domains become disjoint before taking the disjoint union.

\begin{definition}[Sequential composition]\label{aml-composition}
    Let $\aPModelAndTuple{\aStatesT}$ and $\aPModelAndTupleP{\aStatesTP}$ be action models.
    We denote the {\em sequential composition of $\aPModel{\aStatesT}$ and $\aPModelP{\aStatesTP}$} as $\aPModel{\aStatesT} \compose \aPModelP{\aStatesTP}$ and define it as $\aPModel{\aStatesT} \compose \aPModelP{\aStatesTP} = \aPModelAndTuplePP{\aStatesTPP}$ where:
    \begin{eqnarray*}
        \aStatesPP &=& \aStates \times \aStatesP\\
        (\aStateS, \aStateSP) \aAccessibilityPPA (\aStateT, \aStateTP) &\text{ iff }& \aStateS \aAccessibilityA \aStateT \text{ and } \aStateSP \aAccessibilityPA \aStateTP\\
        \aPreconditionPP((\aStateS, \aStateSP)) &=& \aPrecondition(\aStateS) \land \actionA{\aPModel{\aStateS}} \aPreconditionP(\aStateSP)\\
        \aStatesTPP &=& \aStatesT \times \aStatesTP
    \end{eqnarray*}
\end{definition}

The operation of sequential composition of action models is intended to represent the epistemic update that is formed by sequentially performing two epistemic updates.
Indeed we note that $\entails \actionA{\aPModel{\aStatesT} \compose \aPModelP{\aStatesTP}} \phi \iff \actionA{\aPModel{\aStatesT}} \actionA{\aPModelP{\aStatesTP}} \phi$.

Similar to Kripke models there is a notion of bisimilarity of action models.

\begin{definition}[Bisimulation of action models]
Let $\aModelAndTuple$ and $\aModelAndTupleP$ be action models.
A non-empty relation $\bisimulation \subseteq \aStates \times \aStatesP$ is a {\em bisimulation} if and only if for every $\agentA \in \agents$ and $(\aStateS, \aStateSP) \in \bisimulation$ the following conditions, {\bf pre}, {\bf forth-$\agentA$} and {\bf back-$\agentB$} holds:

\paragraph{pre}
$\entails \aPrecondition(\aStateS) \iff \aPrecondition(\aStateSP)$.

\paragraph{forth-$\agentA$}
For every $\aStateT \in \aSuccessorsA{\aStateS}$ there exists $\aStateTP \in \aSuccessorsPA{\aStateSP}$ such that $\aStateT \bisimulation \aStateTP$.

\paragraph{back-$\agentA$}
For every $\aStateTP \in \aSuccessorsPA{\aStateSP}$ there exists $\aStateT \in \aSuccessorsA{\aStateS}$ such that $\aStateT \bisimulation \aStateTP$.

If there exists a bisimulation $\bisimulation$ that is a total relation between $\aStates$ and $\aStatesP$ then we say that $\aModel$ and $\aModelP$ are {\em bisimilar} and we denote this by $\aModel \bisimilar \aModelP$.
If there exists a bisimulation $\bisimulation$ such that $\aStateS \bisimulation \aStateSP$ then we say that $\aPModel{\aStateS}$ and $\aPModelP{\aStateSP}$ are {\em bisimilar} and we denote this by $\aPModel{\aStateS} \bisimilar \aPModelP{\aStateSP}$.
\end{definition}

\begin{proposition}
The relation $\bisimilar$ is an equivalence relation on action models.
\end{proposition}

Bisimilar action models have bisimilar results on bisimilar Kripke models.

\begin{proposition}\label{action-bisimulation-results}
Let $\kModel$ and $\kModelP$ be pointed Kripke models such that $\kModel \bisimilar \kModelP$ and
let $\aModel$ and $\aModelP$ be pointed action models such that $\aModel \bisimilar \aModelP$.
Then $\kModel \exec \aModel \bisimilar \kModelP \exec \aModelP$.
\end{proposition}

In particular, due to Proposition~\ref{modal-bisimulation-invariance} and Proposition~\ref{action-bisimulation-results} we have:

\begin{proposition}\label{aml-bisimilar-actions}
Let $\kPModel{\kStateS}$ and $\kPModelP{\kStateSP}$ be pointed Kripke models such that $\kPModel{\kStateS} \bisimilar \kPModelP{\kStateSP}$ and
let $\aPModel{\aStateS}$ and $\aPModelP{\aStateSP}$ be pointed action models such that $\aPModel{\aStateS} \bisimilar \aPModelP{\aStateSP}$.
Then for every $\phi \in \langAml$: $\kPModel{\kStateS} \entails \actionA{\aPModel{\aStateS}} \phi$ if and only if $\kPModelP{\kStateSP} \entails \actionA{\aPModelP{\aStateSP}} \phi$.
\end{proposition}

\begin{proposition}\label{aml-bisimulation-invariance}
Let $\kPModel{\kStateS}$ and $\kPModelP{\kStateSP}$ be pointed Kripke models such that $\kPModel{\kStateS} \bisimilar \kPModelP{\kStateSP}$.
Then for every $\phi \in \langAml$: $\kPModel{\kStateS} \entails \phi$ if and only if $\kPModelP{\kStateSP} \entails \phi$.
\end{proposition}

We also have a notion of depth-limited bisimilarity of action models.

\begin{definition}[$n$-bisimulation]
Let $\aModelAndTuple$ and $\aModelAndTupleP$ be Kripke models and let $n \in \naturals$.
A list of non-empty relations $\bisimulation_0, \dots, \bisimulation_n$, where for $i = 0, \dots, n$ $\bisimulation_i \subseteq \aStates \times \aStatesP$, is an {\em $n$-bisimulation} if and only if for every $i = 0, \dots, n$, $\atomP \in \atoms$, $\agentA \in \agents$ and $(\aStateS, \aStateSP) \in \bisimulation_i$ the following conditions, {\bf pre-$i$-$\atomP$}, {\bf forth-$i$-$\agentA$} and {\bf back-$i$-$\agentB$} holds:

\paragraph{pre-$i$}
If $i = 0$ then $\entails \aPrecondition(\aStateS) \iff \aPreconditionP(\aStateSP)$.
If $i > 0$ then $\aPModel{\aStateS} \bisimulation_{i-1} \aPModelP{\aStateSP}$.

\paragraph{forth-$i$-$\agentA$}
For every $\aStateT \in \aSuccessorsA{\aStateS}$ there exists $\aStateTP \in \aSuccessorsPA{\aStateSP}$ such that $\aStateT \bisimulation_i \aStateTP$.

\paragraph{back-$i$-$\agentA$}
For every $\aStateTP \in \aSuccessorsPA{\aStateSP}$ there exists $\aStateT \in \aSuccessorsA{\aStateS}$ such that $\aStateT \bisimulation_i \aStateTP$.

If there exists an $n$-bisimulation $\bisimulation_0, \dots, \bisimulation_n$ that is a total relation between $\aStates$ and $\aStatesP$ then we say that $\aModel$ and $\aModelP$ are {\em $n$-bisimilar} and we denote this by $\aModel \bisimilar[n] \aModelP$.
If there exists an $n$-bisimulation $\bisimulation_0, \dots, \bisimulation_n$ such that $\aStateS \bisimulation_n \aStateSP$ then we say that $\aPModel{\aStateS}$ and $\aPModelP{\aStateSP}$ are {\em $n$-bisimilar} and we denote this by $\aPModel{\aStateS} \bisimilar[n] \aPModelP{\aStateSP}$.
\end{definition}

\begin{proposition}
Let $n \in \naturals$,
let $\kPModel{\kStateS}$ and $\kPModelP{\kStateSP}$ be pointed Kripke models such that $\kPModel{\kStateS} \bisimilar[n] \kPModelP{\kStateSP}$ and
let $\aPModel{\aStateS}$ and $\aPModelP{\aStateSP}$ be pointed action models such that $\aPModel{\aStateS} \bisimilar[n] \aPModelP{\aStateSP}$.
Then $\kPModel{\kStateS} \exec \aPModel{\aStateS} \bisimilar[n] \kPModelP{\kStateSP} \exec \aPModelP{\aStateSP}$.
\end{proposition}

\begin{proposition}
Let $n \in \naturals$,
let $\kPModel{\kStateS}$ and $\kPModelP{\kStateSP}$ be pointed Kripke models such that $\kPModel{\kStateS} \bisimilar[n] \kPModelP{\kStateSP}$ and
let $\aPModel{\aStateS}$ be a pointed action model.
Then for every $\phi \in \langMl$ such that $d(\phi) \leq n$: $\kPModel{\kStateS} \entails \phi$ if and only if $\kPModelP{\kStateSP} \entails \phi$.
\end{proposition}

\begin{proposition}
Let $n \in \naturals$,
let $\kPModel{\kStateS}$ be a pointed Kripke model and
let $\aPModel{\aStateS}, \aPModelP{\aStateSP}$ be pointed action models such that $\aPModel{\aStateS} \bisimilar[n] \aPModelP{\aStateSP}$.
Then for every $\phi \in \langMl$ such that $d(\phi) \leq n$: $\kPModel{\kStateS} \entails \actionA{\aPModel{\aStateS}} \phi$ if and only if $\kPModel{\kStateS} \entails \actionA{\aPModelP{\aStateSP}} \phi$.
\end{proposition}

We note that for the sake of simplicity we give the previous two propositions in terms of \langMl{} formulas rather than \langAml{} formulas.
This is so that we need not introduce a separate definition of modal depth for \langAml{} formulas, which would have to take into account the modal depth of preconditions in action models appearing in subformulas of the form $\actionA{\aPModel{\aStateS}} \phi$.
We note that in the settings we consider \logicAml{} is expressively equivalent to modal logic, so we can get the same results for \langAml{} formulas by first converting to an equivalent \langMl{} formula and using the notion of modal depth for \langMl{} for the converted formula.

\begin{definition}[Axiomatisations \axiomAmlK{}, \axiomAmlKFF{}, and \axiomAmlS{}]
The axiomatisations \axiomAmlK{}, \axiomAmlKFF{}, and \axiomAmlS{} are substitution schemas consisting of the respective axioms and rules of \axiomK{}, \axiomKFF{}, and \axiomS{} along with the following additional axioms and rules:
$$
\begin{array}{rl}
    {\bf AP} & \proves \actionA{\aPModel{\aStateS}} \atomP \iff (\aPrecondition(\aStateS) \implies \atomP)\\
    {\bf AN} & \proves \actionA{\aPModel{\aStateS}} \lnot \phi \iff (\aPrecondition(\aStateS) \implies \lnot \actionA{\aPModel{\aStateS}} \phi)\\
    {\bf AC} & \proves \actionA{\aPModel{\aStateS}} (\phi \land \psi) \iff (\actionA{\aPModel{\aStateS}} \phi \land \actionA{\aPModel{\aStateS}} \psi)\\
    {\bf AK} & \proves \actionA{\aPModel{\aStateS}} \necessaryA \phi \iff (\aPrecondition(\aStateS) \implies \necessaryA \bigwedge_{\aStateT \in \aSuccessorsA{\aStateS}} \actionA{\aPModel{\aStateT}} \phi)\\
    {\bf AU} & \proves \actionA{\aPModel{\aStatesT}} \phi \iff \bigwedge_{\aStateT \in \aStatesT} \actionA{\aPModel{\aStateT}} \phi\\
    {\bf NecA} & \text{From } \proves \phi \text{ infer } \proves \actionA{\aPModel{\aStatesT}} \phi
\end{array}
$$
where $\phi, \psi \in \langAml$, $\aPModel{\aStateS} \in \classAmK$, $\atomP \in \atoms$, and $\agentA \in \agents$.
\end{definition}

We note that the axiomatisations \axiomAmlK{}, \axiomAmlKFF{}, and \axiomAmlS{} form sets of reduction axioms, admitting a provably correct translation from the language \langAml{} of action model logic to the language \langMl{} of modal logic.

This works as the axioms {\bf AN}, {\bf AC}, {\bf AK}, and {\bf AU} may be applied to ``push'' the action model operators past negations, conjunctions, and modalities, until they are applied only to propositional atoms, where the axiom {\bf AP} may be applied to replace the formula with a modal formula.
Assuming that the axioms are sound we then have that \logicAmlK{}, \logicAmlKFF{}, and \logicAmlS{} are expressively equivalent to \logicK{}, \logicKFF{}, and \logicS{} respectively, so we get other results for the logic from the corresponding results for \logicK{}, \logicKFF{}, and \logicS{}.

\begin{proposition}
The axiomatisations \axiomAmlK{}, \axiomAmlKFF{}, and \axiomAmlS{} are sound and strongly complete with respect to the semantics of the respective logics \logicAmlK{}, \logicAmlKFF{}, and \logicAmlS{}.
\end{proposition}

\begin{proposition}\label{aml-expressive-equivalence}
The logics \logicAmlK{}, \logicAmlKFF{}, and \logicAmlS{} are expressively equivalent to the respective logics \logicK{}, \logicKFF{}, and \logicS{}.
\end{proposition}

\begin{proposition}
The logics \logicAmlK{}, \logicAmlKFF{}, and \logicAmlS{} are compact.
\end{proposition}

\begin{proposition}
The satisfiability problems for the logics \logicAmlK{}, \logicAmlKFF{}, and \logicAmlS{} are decidable.
\end{proposition}
