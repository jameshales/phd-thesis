\section{Syntax and semantics}\label{rml-semantics}

In this section we introduce the syntax and semantics of the refinement modal logics.
Compared to previous treatments of \logicRml{}, which considered \logicRml{} specifically in the setting of \classK{}, our treatment considers \logicRml{} in different settings, including \classK{}, \classKFF{}, \classKD{}, \classS{}, and \classKF{}.
The definitions that we give here generalise to these different settings, and the semantic results that we give here are common to all or most of the settings that we consider.
In the following chapters we consider these settings in more detail, providing results specific to each setting.

We begin with a definition of the syntax of \logicRml{}.

\begin{definition}[Language of refinement modal logic]
The {\em language of refinement modal logic}, \langRml{}, is inductively defined as:
$$
\phi ::= 
    \atomP \mid
    \lnot \phi \mid
    \phi \land \phi \mid
    \necessaryA \phi \mid
    \allrefsBs \phi
$$
where $\atomP \in \atoms$, $\agentA \in \agents$ and $\agentsB \subseteq \agents$.
\end{definition}

We use all of the standard abbreviations from modal logic, in addition to the abbreviation $\somerefsBs \phi ::= \lnot \allrefsBs \lnot \phi$.

The formula $\allrefsBs \phi$ may be read as ``in every $\agentsB$-refinement $\phi$ is true'' and the formula $\somerefsBs \phi$ may be read as ``in some $\agentsB$-refinement $\phi$ is true''.

We define the semantics of \logicRml{}.
As in modal logic, the semantics are defined in terms of a parameterised class of Kripke frames, \classC{}.

\begin{definition}[Semantics of refinement modal logic]
Let $\classC$ be a class of Kripke frames, let $\phi \in \langRml$, and let $\kPModelAndTuple{\kStateS} \in \classC$ be a pointed Kripke model.
The interpretation of the formula $\phi$ in the logic \logicRmlC{} on the pointed Kripke model $\kPModel{\kStateS}$ is the same as its interpretation in modal logic, defined in Definition~\ref{ml-semantics}, with the additional inductive case:
$$
\begin{array}{lcl}
    \kPModel{\kStateS} \entails \allrefsBs \phi & \text{ iff } & \text{for every } \kPModelP{\kStateSP} \in \classC \text{ if } \kPModel{\kStateS} \simulatesBs \kPModelP{\kStateSP} \text{ then } \kPModelP{\kStateSP} \entails \phi
\end{array}
$$
\end{definition}

Whereas in modal logic the parameterised class of Kripke frames restricts the Kripke models that modal formulas are interpeted on, in \logicRml{} the parameterised class of Kripke frames also restricts the refinements that are considered by the refinement quantifiers.
The motivation for this can be understood in the epistemic setting, where we consider refinements to correspond to the results of epistemic updates.
In the epistemic logic \logicS{}, the frame conditions of \classS{} correspond to rules about knowledge, such as the truth of knowledge, and positive and negative introspection of knowledge.
Intuitively we'd expect that epistemic updates should be able to change knowledge, but not the rules about knowledge itself, so we'd expect that epistemic updates should take us from \classS{} Kripke models to \classS{} Kripke models.
In the refinement modal logic \logicRmlS{}, the restriction on refinement quantifiers ensures that the only refinements that are considered are \classS{} refinements, satisfying our intuition about epistemic updates.

We now show some semantic properties of \logicRml{} that hold regardless of setting.

\begin{proposition}\label{rml-validities}
Let $\classC$ be a class of Kripke frames. Then:
\begin{eqnarray}
    &&\entails_\logicRmlC \allrefsBs (\phi \implies \psi) \implies (\allrefsBs \phi \implies \allrefsBs \psi) \label{rml-validity-r}\\
    &&\entails_\logicRmlC \phi \text{ implies } \entails_\logicRmlC \allrefsBs \phi \label{rml-validity-necr}\\
    &&\entails_\logicRmlC \allrefsBs \phi \implies \phi \label{rml-validity-t}\\
    &&\entails_\logicRmlC \allrefsBs \phi \implies \allrefsBs \allrefsBs \phi \label{rml-validity-4}\\
    &&\entails_\logicRmlC \phi^+ \implies \allrefsBs \phi^+ \label{rml-validity-rp}
\end{eqnarray}
where $\agentsB \subseteq \agents$, $\phi, \psi \in \langRml$ and $\phi^+ \in \langMlPlus$.
\end{proposition}

First some remarks on these properties:
(\ref{rml-validity-r}) corresponds to the modal axiom {\bf K};
(\ref{rml-validity-necr}) corresponds to the modal rule {\bf NecK};
(\ref{rml-validity-t}) corresponds to the modal rule {\bf T}; and
(\ref{rml-validity-4}) corresponds to the modal rule {\bf 4}.
This gives the $\allrefsBs$ all of the appearances of a modal operator, however we note that it is not a normal modal operator, due to validity (\ref{rml-validity-rp}), which corresponds to the notion that refinements preserve positive formulas.

\begin{proof}
Let $\kPModel{\kStateS}, \kPModelP{\kStateSP}, \kPModelPP{\kStateSPP} \in \classC$ be pointed Kripke models such that $\kPModel{\kStateS} \simulatesBs \kPModelP{\kStateSP}$ and $\kPModelP{\kStateSP} \simulatesBs \kPModelPP{\kStateSPP}$.
\begin{itemize}
    \item 
        Suppose that $\kPModel{\kStateS} \entails \allrefsBs (\phi \implies \psi)$ and $\kPModel{\kStateS} \entails \allrefsBs \phi$.
        Then $\kPModelP{\kStateSP} \entails \phi \implies \psi$
        and $\kPModelP{\kStateSP} \entails \phi$,
        so by modus ponens $\kPModelP{\kStateSP} \entails \psi$.
        Therefore $\kPModel{\kStateS} \entails \allrefsBs \psi$
        and $\kPModel{\kStateS} \entails \allrefsBs (\phi \implies \psi) \implies (\allrefsBs \phi \implies \allrefsBs \psi)$.
    \item
        Suppose that $\entails \phi$. 
        Then $\kPModelP{\kStateSP} \entails \phi$ and so $\kPModel{\kStateS} \entails \allrefsBs \phi$.
        Therefore $\entails \allrefsBs \phi$
    \item
        Suppose that $\kPModel{\kStateS} \entails \allrefsBs \phi$.
        By Proposition~\ref{refinements-preorder} we have that $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS}$ and so $\kPModel{\kStateS} \entails \phi$.
        Therefore $\kPModel{\kStateS} \entails \allrefsBs \phi \implies \phi$.
    \item
        Suppose that $\kPModel{\kStateS} \entails \allrefsBs \phi$.
        By Proposition~\ref{refinements-preorder} we have that $\kPModel{\kStateS} \simulatesBs \kPModelPP{\kStateSPP}$ and so $\kPModelPP{\kStateSPP} \entails \phi$ and $\kPModel{\kStateS} \entails \allrefsBs \allrefsBs \phi$.
        Therefore $\kPModel{\kStateS} \entails \allrefsBs \phi \implies \allrefsBs \allrefsBs \phi$.
    \item
        Suppose that $\kPModel{\kStateS} \entails \phi^+$.
        By Proposition~\ref{refinements-preserve-positive} we have that $\kPModelP{\kStateSP} \entails \phi^+$ and so $\kPModel{\kStateS} \entails \allrefsBs \phi^+$.
        Therefore $\kPModel{\kStateS} \entails \phi^+ \implies \allrefsBs \phi^+$.
\end{itemize}
\end{proof}

\begin{proposition}\label{rml-mckinsey}
Let $\classC \in \{\classK, \classKF, \classKFF, \classKD, \classSF, \classS\}$. Then:
$$
\begin{array}{l}
    \entails_\logicRmlC \allrefsBs \somerefsBs \phi \implies \somerefsBs \allrefsBs \phi\\
    \entails_\logicRmlC (\allrefsBs \somerefsBs \phi \land \allrefsBs \somerefsBs \psi) \implies \somerefsBs (\phi \land \psi)
\end{array}
$$
where $\agentsB \subseteq \agents$ and $\phi, \psi \in \langRml$.
\end{proposition}

\begin{proof}
Let $\classC \in \{\classK, \classKF, \classKFF\}$, let $\kPModel{\kStateS} \in \classC$ such that $\kPModel{\kStateS} \entails \allrefsBs \somerefsBs \phi$ and let $\kPModelAndTupleP{\kStateS}$ where:
\begin{eqnarray*}
    \kStatesP &=& \kStates\\
    \kAccessibilityPA &=& \emptyset \text{ where } \agentA \in \agentsB\\
    \kAccessibilityPA &=& \kAccessibilityA \text{ where } \agentA \notin \agentsB\\
    \kValuationP(\atomP) &=& \kValuation(\atomP)
\end{eqnarray*}
Then $\kPModelP{\kStateS} \in \classC$, $\kPModel{\kStateS} \simulatesBs \kPModelP{\kStateS}$ and $\kPModelP{\kStateS} \entails \somerefsBs \phi$.
We note that as there are no $\agentsB$-edges in $\kModelP$ then every refinement of $\kPModelP{\kStateS}$ is bisimilar to $\kPModelP{\kStateS}$.
Therefore $\kPModelP{\kStateS} \entails \phi$ and $\kPModelP{\kStateS} \entails \allrefsBs \phi$ and so $\kPModel{\kStateS} \entails \somerefsBs \allrefsBs \phi$.

A similar argument holds for $\classC \in \{\classSF, \classS\}$ by constructing a refinement where the only $\agentsB$-edges are the reflexive edges,
and for $\classKD$ by constructing a refinement where each state and each $\agentB \in \agentsB$ has only a single $\agentsB$-successor.

A similar argument shows that $\entails_\logicRmlC (\allrefsBs \somerefsBs \phi \land \allrefsBs \somerefsBs \psi) \implies \somerefsBs (\phi \land \psi)$ for $\classC \in \{\classK, \classKF, \classKFF, \classKD, \classSF, \classS\}$.
\end{proof}

\begin{proposition}\label{rml-church-rosser}
Let $\classC \in \{\classK, \classKF, \classKFF, \classSF, \classS\}$. Then:
$$
\begin{array}{l}
    \entails_\logicRmlC \somerefsBs \allrefsBs \phi \implies \allrefsBs \somerefsBs \phi
\end{array}
$$
where $\agentsB \subseteq \agents$ and $\phi \in \langRml$.
\end{proposition}

\begin{proof}
Let $\classC \in \{\classK, \classKF, \classKFF\}$, let $\kPModel{\kStateS} \in \classC$ such that $\kPModel{\kStateS} \entails \somerefsBs \allrefsBs \phi$.
There exists $\kPModelP{\kStateSP} \in \classC$ such that $\kPModel{\kStateS} \simulatesBs \kPModelP{\kStateSP}$ and $\kPModel{\kStateS} \entails \allrefsBs \phi$.
From Proposition~\ref{rml-validities} we have that $\kPModelP{\kStateSP} \entails \allrefsBs \allrefsBs \phi$.
Let $\kPModelAndTuplePP{\kStateSP}$ where:
\begin{eqnarray*}
    \kStatesPP &=& \kStatesP\\
    \kAccessibilityPPA &=& \emptyset \text{ where } \agentA \in \agentsB\\
    \kAccessibilityPPA &=& \kAccessibilityPA \text{ where } \agentA \notin \agentsB\\
    \kValuationPP(\atomP) &=& \kValuationP(\atomP)
\end{eqnarray*}
Then $\kPModelPP{\kStateSP} \in \classC$, $\kPModelP{\kStateSP} \simulatesBs \kPModelPP{\kStateSP}$ and $\kPModelPP{\kStateSP} \entails \allrefsBs \phi$.
From Proposition~\ref{rml-validities} we have that $\kPModelPP{\kStateSPP} \entails \phi$ and therefore $\kPModelP{\kStateSP} \entails \somerefsBs \phi$.
We note that as there are no $\agentsB$-edges in $\kModelP$ then every refinement of $\kPModelP{\kStateS}$ is bisimilar to $\kPModelP{\kStateS}$.
Therefore $\kPModelP{\kStateS} \entails \phi$ and $\kPModelP{\kStateS} \entails \allrefsBs \phi$ and so $\kPModel{\kStateS} \entails \somerefsBs \allrefsBs \phi$.

A similar argument holds for $\classC \in \{\classSF, \classS\}$ by constructing a refinement where the only $\agentsB$-edges are the reflexive edges.
\end{proof}

\todo[inline]{Note on why this doesn't hold for \classKD{}}

\begin{proposition}\label{rml-bisimulation-invariance}
Let $\classC$ be a class of Kripke frames and
let $\kPModel{\kStateS}, \kPModelP{\kStateSP} \in \classC$ be pointed Kripke models such that $\kPModel{\kStateS} \bisimilar \kPModelP{\kStateSP}$.
Then for every $\phi \in \langRml$:
$\kPModel{\kStateS} \entails_\logicRmlC \phi$ if and only if $\kPModelP{\kStateSP} \entails_\logicRmlC \phi$.
\end{proposition}

\begin{proof}
We proceed by induction on the structure of the formula $\phi \in \langRml$.
Let $\bisimulation \subseteq \kStates \times \kStatesP$ be a bisimulation between $\kPModel{\kStateS}$ and $\kPModelP{\kStateSP}$ and let $(\kStateT, \kStateTP) \in \bisimulation$.

Suppose that $\phi = \atomP$ where $\atomP \in \atoms$.
Then $\kPModel{\kStateT} \entails \atomP$ if and only if $\kStateT \in \kValuation(\atomP)$.
By {\bf atoms-$\atomP$}, $\kStateT \in \kValuation(\atomP)$ if and only if $\kStateTP \in \kValuationP(\atomP)$.
Finally $\kStateTP \in \kValuationP(\atomP)$ if and only if $\kPModelP{\kStateTP} \entails \atomP$.
Therefore $\kPModel{\kStateT} \entails \atomP$ if and only if $\kPModelP{\kStateTP} \entails \atomP$.

Suppose that $\phi = \lnot \psi$ or $\phi = \psi \land \chi$ where $\psi, \chi \in \langRml$. These follow directly from the induction hypothesis.

Suppose that $\phi = \possibleA \psi$ where $\psi \in \langRml$.
Suppose that $\kPModel{\kStateT} \entails \possible \psi$. 
Then there exists $\kStateU \in \kSuccessorsA{\kStateT}$ such that $\kPModel{\kStateU} \entails \psi$.
As $(\kStateT, \kStateTP) \in \bisimulation$ by {\bf forth-$\agentA$} there exists $\kStateUP \in \kSuccessorsPA{\kStateTP}$ such that $(\kStateU, \kStateUP) \in \bisimulation$.
By the induction hypothesis $\kPModelP{\kStateUP} \entails \psi$.
Therefore $\kPModelP{\kStateTP} \entails \possibleA \psi$.
The converse follows a similar argument.
Therefore $\kPModel{\kStateT} \entails \possibleA \psi$ if and only if $\kPModelP{\kStateTP} \entails \possibleA \psi$.

Suppose that $\phi = \somerefsBs \psi$ where $\psi \in \langRml$.
Then $\kPModel{\kStateT} \entails \somerefsBs \psi$ if and only if there exists $\kPModelPP{\kStateTPP} \in \classC$ such that $\kPModel{\kStateT} \simulatesBs \kPModelPP{\kStateTPP}$ and $\kPModelPP{\kStateTPP} \entails \psi$.
As $\kPModel{\kStateT} \bisimilar \kPModelP{\kStateTP}$, from Proposition~\ref{bisimulation-refinement} and Proposition~\ref{refinements-preorder} we have that $\kPModel{\kStateT} \simulatesBs \kPModelPP{\kStateTPP}$ if and only if $\kPModelP{\kStateTP} \simulatesBs \kPModelPP{\kStateTPP}$.
Therefore $\kPModel{\kStateT} \entails \somerefsBs \psi$ if and only if $\kPModelP{\kStateTP} \entails \somerefsBs \psi$.

Therefore $\kPModel{\kStateS} \entails \phi$ if and only if $\kPModelP{\kStateSP} \entails \phi$.
\end{proof}

\begin{proposition}
The logics \logicRmlK{}, \logicRmlKF{}, \logicRmlKFF{}, \logicRmlKD{}, \logicRmlSF{} and \logicRmlS{} do not have uniform substitution.
\end{proposition}

\begin{proof}
From Proposition~\ref{rml-validities} we have that $\entails \atomP \implies \allrefs \atomP$ but we do not have in general that $\entails \possibleB \atomP \implies \allrefs \possible \atomP$, as the successor state where $\atomP$ is valid may be removed in a refinement.
\todo[inline]{Diagram of example}
\end{proof}

\begin{proposition}
The logic \logicRmlK{} is not a sublogic of \logicRmlKF{}, \logicRmlKFF{}, \logicRmlKD{}, \logicRmlSF{} or \logicRmlS{}.
\end{proposition}

\begin{proof}
In \logicRmlK{} we have that $\entails \possible (\lnot \atomP \land \possible \atomP) \implies \somerefs (\possible \possible \atomP \land \lnot \possible \atomP)$. 
That is, a refinement in \logicRmlK{} need not be transitive.
However in \logicRmlKF{}, \logicRmlKFF{}, \logicRmlKD{}, \logicRmlSF{} or \logicRmlS{} we have that $\entails \allrefs (\possible \possible \atomP \implies \possible \atomP)$, as refinements in these settings must be transitive.
\end{proof}
