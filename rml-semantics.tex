\section{Syntax and semantics}\label{rml-semantics}

In this section we introduce the syntax and semantics of the refinement modal logics.
Compared to previous treatments of \logicRml{}, which considered \logicRml{} specifically in the setting of \classK{}, our treatment considers \logicRml{} in different settings, including \classK{}, \classKFF{}, \classKD{}, \classS{}, and \classKF{}.
The definitions that we give here generalise to these different settings, and the semantic results that we give here are common to all or most of the settings that we consider.
In the following chapters we consider these settings in more detail, providing results specific to each setting.

\pagebreak

We begin with a definition of the syntax of \logicRml{}.

\begin{definition}[Language of refinement modal logic]
The {\em language of refinement modal logic}, \langRml{}, is inductively defined as:
$$
\phi ::= 
    \atomP \mid
    \lnot \phi \mid
    (\phi \land \phi) \mid
    \necessaryA \phi \mid
    \allrefsBs \phi
$$
where $\atomP \in \atoms$, $\agentA \in \agents$ and $\agentsB \subseteq \agents$.
\end{definition}

We use all of the standard abbreviations from modal logic, in addition to the abbreviations $\somerefsBs \phi ::= \lnot \allrefsBs \lnot \phi$, $\allrefs \phi ::= \allrefsAs \phi$, and $\allrefsA \phi ::= \allrefs[\{\agentA\}] \phi$.

The formula $\allrefsBs \phi$ may be read as ``in every $\agentsB$-refinement $\phi$ is true'' and the formula $\somerefsBs \phi$ may be read as ``in some $\agentsB$-refinement $\phi$ is true''.

We define the semantics of \logicRml{}.
As in modal logic, the semantics are defined in terms of a parameterised class of Kripke frames, \classC{}.

\begin{definition}[Semantics of refinement modal logic]
Let $\classC$ be a class of Kripke frames, let $\phi \in \langRml$, and let $\kPModelAndTuple{\kStateS} \in \classC$ be a pointed Kripke model.
The interpretation of the formula $\phi$ in the logic \logicRmlC{} on the pointed Kripke model $\kPModel{\kStateS}$ is the same as its interpretation in modal logic, defined in Definition~\ref{ml-semantics}, with the additional inductive case:
$$
\begin{array}{lcl}
    \kPModel{\kStateS} \entails \allrefsBs \phi & \text{ iff } & \text{for every } \kPModelP{\kStateSP} \in \classC \text{ if } \kPModel{\kStateS} \simulatesBs \kPModelP{\kStateSP} \text{ then } \kPModelP{\kStateSP} \entails \phi
\end{array}
$$
\end{definition}

We provide some examples of reasoning in \logicRmlK{}.
We use the notation $\kPModel{\kStateS} \entails_\logicRmlC{}$ to denote entailment in the logic \logicRmlC{}.

\begin{example}\label{example-rml-pal}
\begin{figure}
    \caption{An example of a Kripke model and refinement.}\label{example-rml-pal-figure}
    \centering
    \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=7em,thick]

      \node[label=above right:{$\kStateS$}] (s) {\underline{$\{\atomP, \atomQ\}$}};
      \node[label=below right:{$\kStateT$}] (t) [below of=s] {$\{\atomP\}$};
      \node[label=above left:{$\kStateU$}] (u) [left of=s] {$\{\atomQ\}$};
      \node[label=below left:{$\kStateV$}] (v) [left of=t] {$\{\}$};
      \node[label=above:{$\kPModel{\kStateS}$},draw=black, fit=(s) (t) (u) (v), inner sep=3em, dashed, rounded corners] {};

      \path[every node/.style={font=\sffamily\small},->]
        (s) edge [loop above] node {$\agentA, \agentB$} (s)
        (t) edge [loop below] node {$\agentA, \agentB$} (t)
        (u) edge [loop above] node {$\agentA, \agentB$} (u)
        (v) edge [loop below] node {$\agentA, \agentB$} (v)
        (s) [<->] edge node {$\agentA$} (t)
        (u) [swap] edge node {$\agentA$} (v)
        (s) edge node {$\agentB$} (u)
        (t) [swap] edge node {$\agentB$} (v);

      \node[label=above left:{$\kStateS$}] (s') [right=9em of s]{\underline{$\{\atomP, \atomQ\}$}};
      \node[label=below left:{$\kStateT$}] (t') [below of=s'] {$\{\atomP\}$};
      \node[label=above:{$\kPModelP{\kStateS}$},draw=black, fit=(s') (t'), inner sep=3em, dashed, rounded corners] {};

      \path[every node/.style={font=\sffamily\small},->]
        (s') edge [loop above] node {$\agentA, \agentB$} (s')
        (t') edge [loop below] node {$\agentA, \agentB$} (t')
        (s') [<->] edge node {$\agentA$} (t');
      
      \path[every node/.style={font=\sffamily\small},->,dotted]
        (s) edge node {$\simulatesB$} (s')
        (t) edge node {$\simulatesB$} (t');
    \end{tikzpicture}
\end{figure}

We recall the Kripke model $\kPModel{\kStateS}$ given in Example~\ref{example-ml}, and the result of a public announcement of $\knowsA \atomP$ in this Kripke model, $\kPModelP{\kStateS}$, given in Example~\ref{example-pal}.
The Kripke models $\kPModel{\kStateS}$ and $\kPModelP{\kStateS}$ are shown in Figure~\ref{example-rml-pal-figure}.
We note that $\kPModel{\kStateS}, \kPModelP{\kStateS} \in \classS$.

In Example~\ref{example-pal} we showed that $\kPModelP{\kStateS} \entails_\logicRmlK \knowsB \atomQ$ and in Example~\ref{example-refinement-pal} we showed that $\kPModel{\kStateS} \simulatesB \kPModelP{\kStateS}$.
Therefore we have that $\kPModel{\kStateS} \entails_\logicRmlK \somerefsB \knowsB \atomQ$.

In Example~\ref{example-ml} we showed that $\kPModel{\kStateS} \entails_\logicRmlK \knowsA \atomP$.
Let $\kPModelPP{\kStateSPP} \in \classS$ such that $\kPModel{\kStateS} \simulatesA \kPModelPP{\kStateSPP}$.
As $\knowsA \atomP$ is a $\agentB$-positive formula then by Proposition~\ref{refinements-preserve-positive} we have that $\kPModelPP{\kStateSPP} \entails_\logicRmlK \knowsA \atomP$.
Therefore $\kPModel{\kStateS} \entails_\logicRmlK \allrefsB \knowsA \atomP$.
\end{example}

\begin{example}
\begin{figure}
    \caption{An example of two Kripke models that are refinements of each other.}\label{example-rml-aml-figure}
    \centering
    \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=7em,thick]

      \node[label=above left:{$\kStateS$}] (s) {\underline{$\{\atomP\}$}};
      \node[label=above left:{$\kStateT$}] (t) [above of=s] {$\{\}$};
      \node[label=above left:{$\kStateU$}] (u) [below of=s] {$\{\atomP\}$};
      \node[label=above:{$\kPModel{\kStateS}$},draw=black, fit=(s) (t) (u), inner sep=3.5em, dashed, rounded corners] {};

      \path[every node/.style={font=\sffamily\small},->]
        (s) edge [loop left] node {$\agentA, \agentB$} (s)
        (t) edge [loop left] node {$\agentA, \agentB$} (t)
        (u) edge [loop left] node {$\agentA, \agentB$} (u)
        (s) [<->] edge node {$\agentB$} (t)
        (s) edge node {$\agentA$} (u);

      \node[label=above right:{$\kStateS$}] (s') [right=11em of s]{\underline{$\{\atomP\}$}};
      \node[label=above right:{$\kStateT$}] (t') [above of=s'] {$\{\}$};
      \node[label=above:{$\kPModelP{\kStateS}$},draw=black, fit=(s') (t'), inner sep=3.5em, dashed, rounded corners] {};

      \path[every node/.style={font=\sffamily\small},->]
        (s') edge [loop right] node {$\agentA, \agentB$} (s')
        (t') edge [loop right] node {$\agentA, \agentB$} (t')
        (s') [<->] edge node {$\agentB$} (t');
      
      \path[every node/.style={font=\sffamily\small},<->,dotted]
        (s') edge node {$\simulatesA$} (s)
        (t') edge node {$\simulatesA$} (t)
        (s') edge [->,bend left] node {$\simulatesA$} (u);
    \end{tikzpicture}
\end{figure}

We recall the Kripke models $\kPModel{\kStateS}$ and $\kPModelP{\kStateS}$ given in Example~\ref{example-refinement-aml}.
The Kripke models $\kPModel{\kStateS}$ and $\kPModelP{\kStateS}$ are shown in Figure~\ref{example-rml-aml-figure}.

We note that $\kPModelP{\kStateS} \entails_\logicRmlK \knowsA \lnot \knowsB \atomP$ and in Example~\ref{example-refinement-aml} we showed that $\kPModel{\kStateS} \simulatesA \kPModelP{\kStateS}$.
Let $\kPModelPP{\kStateSPP} \in \classK$ such that $\kPModelP{\kStateS} \simulatesA \kPModelPP{\kStateSPP}$.
As $\knowsA \lnot \knowsB \atomP$ is a $\agentA$-positive formula, $\kPModelP{\kStateS} \entails_\logicRmlK \knowsA \lnot \knowsB \atomP$, and $\kPModelP{\kStateS} \simulatesA \kPModelPP{\kStateSPP}$, then by Proposition~\ref{refinements-preserve-positive} we have $\kPModelPP{\kStateSPP} \entails_\logicRmlK \knowsA \lnot \knowsB \atomP$.
Then $\kPModelP{\kStateS} \entails \allrefsA \knowsA \lnot \knowsB \atomP$.
As $\kPModel{\kStateS} \simulatesA \kPModelP{\kStateS}$ then $\kPModel{\kStateS} \entails \somerefsA \allrefsA \knowsA \lnot \knowsB \atomP$.

Therefore we have that $\kPModel{\kStateS} \entails_\logicRmlK{} \somerefsA \knowsA \lnot \knowsB \atomP$.

We note that $\kPModel{\kStateS} \entails_\logicRmlK \lnot \knowsA \lnot \knowsB \atomP$ and in Example~\ref{example-refinement-aml} we showed that $\kPModelP{\kStateS} \simulatesA \kPModel{\kStateS}$.
Therefore we have that $\kPModelP{\kStateS} \entails_\logicRmlK{} \somerefsA (\knowsA \lnot \knowsB \atomP \land \somerefsA \lnot \knowsA \lnot \knowsB \atomP)$.
\end{example}

\pagebreak

Whereas in modal logic the parameterised class of Kripke frames restricts the Kripke models that modal formulas are interpreted on, in \logicRml{} the parameterised class of Kripke frames also restricts the refinements that are considered by the refinement quantifiers.
The motivation for this can be understood in the epistemic setting, where we consider refinements to correspond to the results of epistemic updates.
In the epistemic logic \logicS{}, the frame conditions of \classS{} correspond to rules about knowledge, such as the truth of knowledge, and positive and negative introspection of knowledge.
Intuitively we'd expect that epistemic updates should be able to change knowledge, but not the rules about knowledge itself, so we'd expect that epistemic updates should take us from \classS{} Kripke models to \classS{} Kripke models.
This is the behaviour we experience in logics such as public announcement logic or action model logic.
In the logic \logicRmlS{}, the restriction on refinement quantifiers ensures that the only refinements that are considered are \classS{} refinements, satisfying our intuition about epistemic updates.

Previous treatments of \logicRml{} didn't make this additional restriction in the semantics, as these treatments specifically considered \logicRmlK{}, where restricting refinements to \classK{} would be redundant~\cite{vanditmarsch:2009,vanditmarsch:2010}.
van Ditmarsch, French and Pinchinat~\cite{vanditmarsch:2010} suggested the semantics presented here in order to generalise \logicRml{} to other modal settings, such as \classS{} and \classKF{}.   

Previous treatments of \logicRml{} also didn't use the more general notion of refinements that we use here.
van Ditmarsch and French~\cite{vanditmarsch:2009} considered a notion of refinements corresponding to our notion of $\agents$-refinements, with the corresponding formulation of \logicRml{} introducing $\allrefs$ quantifiers which quantify over $\agents$-refinements.
van Ditmarsch, French and Pinchinat~\cite{vanditmarsch:2010} subsequently considered a notion of refinements corresponding to our notion of $\agentA$-refinements, with the corresponding formulation of \logicRml{} introducing $\allrefsA$ quantifiers which quantify over $\agentA$-refinements.
We note that our formulation of \logicRml{} is at least as expressive as previous formulations, the previous logics being syntactic restrictions of the logic presented here.
We will later show that \logicRml{} is expressively equivalent to modal logic in the settings of \classK{}, \classKFF{}, \classKD{}, and \classS{}, so in these settings our formulation is expressively equivalent to the previous formulations.
We prefer to formulate \logicRml{} in terms of $\agentsB$-refinements rather than $\agents$-refinements or $\agentA$-refinements because it gives a more direct indication of the capabilities of the logic, which is important for a logic that in many settings we consider is expressively equivalent to modal logic, and because many results for $\agents$-refinements and $\agentA$-refinements generalise to results about $\agentsB$-refinements.

As an aside we note that van Ditmarsch, French and Pinchinat~\cite{vanditmarsch:2010} were able to reason about $\agents$-refinements using $\agentA$-refinement quantifiers by introducing the syntactic abbreviation $\allrefsAs \phi ::= \allrefs[\agentA_1] \allrefs[\agentA_2] \cdots \allrefs[\agentA_n] \phi$ where $\agents = \{\agentA_1, \agentA_2, \dots, \agentA_n\}$.
We can generalise this notion with the following results.

\begin{proposition}\label{rml-agent-decomposition}
Let $\agentsB, \agentsC \subseteq \agents$ be sets of agents, let $\phi \in \langRml$ be a formula and let $\kPModel{\kStateS}$ be a pointed Kripke model.
Then $\kPModel{\kStateS} \entails_\logicRmlK \somerefs[(\agentsB \cup \agentsC)] \phi$ if and only if $\kPModel{\kStateS} \entails_\logicRmlK \somerefsBs \somerefsCs \phi$.
\end{proposition}

\begin{proof}
From the semantics $\kPModel{\kStateS} \entails_\logicRmlK \somerefs[(\agentsB \cup \agentsC)] \phi$ if and only if there exists $\kPModelPP{\kStateSPP} \in \classK$ such that $\kPModel{\kStateS} \simulates[(\agentsB \cup \agentsC)] \kPModelPP{\kStateSPP}$ and $\kPModelPP{\kStateSPP} \entails_\logicRmlK \phi$.
By Proposition~\ref{refinement-agent-decomposition} we have $\kPModel{\kStateS} \simulates[(\agentsB \cup \agentsC)] \kPModelPP{\kStateSPP}$ if and only if there exists a pointed Kripke model $\kPModelP{\kStateSP}$ such that $\kPModel{\kStateS} \simulatesBs \kPModelP{\kStateSP} \simulatesCs \kPModelPP{\kStateSPP}$.
Then there exists $\kPModelPP{\kStateSPP} \in \classK$ such that $\kPModel{\kStateS} \simulates[(\agentsB \cup \agentsC)] \kPModelPP{\kStateSPP}$ and $\kPModelPP{\kStateSPP} \entails_\logicRmlK \phi$
if and only if
there exists $\kPModelP{\kStateSP}, \kPModelPP{\kStateSPP} \in \classK$ such that $\kPModel{\kStateS} \simulatesBs \kPModelP{\kStateSP} \simulatesCs \kPModelPP{\kStateSPP}$ and $\kPModelPP{\kStateSPP} \entails_\logicRmlK \phi$.
From the semantics $\kPModel{\kStateS} \entails_\logicRmlK \somerefsBs \somerefsCs \phi$ if and only if there exists $\kPModelP{\kStateSP}, \kPModelPP{\kStateSPP} \in \classK$ such that $\kPModel{\kStateS} \simulatesBs \kPModelP{\kStateSP} \simulatesCs \kPModelPP{\kStateSPP}$ and $\kPModelPP{\kStateSPP} \entails_\logicRmlK \phi$.
\end{proof}

\begin{corollary}
Let $\agentsB = \{\agentB_1, \agentB_2, \dots, \agentB_n\}$ be a set of two or more agents, let $\phi \in \langRml$ and let $\kPModel{\kStateS}$ be a pointed Kripke model.
Then $\kPModel{\kStateS} \entails_\logicRmlK \somerefsBs \phi$ if and only if $\kPModel{\kStateS} \entails_\logicRmlK \somerefs[\agentB_1] \somerefs[\agentB_2] \cdots \somerefs[\agentB_n] \phi$.
\end{corollary}

These results are specific to \logicRmlK{} and are not general to \logicRmlC{} for any class of Kripke frames \classC{}.
In order to generalise these results to settings other than \classK{} we require a modification of Proposition~\ref{refinement-decomposition} that gives us intermediate refinements that belong to the appropriate class.
For many classes of Kripke models this is a simple matter to do, and we note that for \classKF{}, \classKFF{}, and \classS{}, if the original Kripke model and its refinement belong to the appropriate class then the intermediate refinement given in the proof of Proposition~\ref{refinement-agent-decomposition} already gives intermediate refinements from the appropriate class.

We now show some semantic properties of \logicRml{} that hold regardless of setting.

\begin{proposition}\label{rml-validities}
Let $\classC$ be a class of Kripke frames. Then:
\begin{eqnarray}
    &&\entails_\logicRmlC \allrefsBs (\phi \implies \psi) \implies (\allrefsBs \phi \implies \allrefsBs \psi) \label{rml-validity-r}\\
    &&\entails_\logicRmlC \phi \text{ implies } \entails_\logicRmlC \allrefsBs \phi \label{rml-validity-necr}\\
    &&\entails_\logicRmlC \allrefsBs \phi \implies \phi \label{rml-validity-rt}\\
    &&\entails_\logicRmlC \allrefsBs \phi \implies \allrefsBs \allrefsBs \phi \label{rml-validity-r4}\\
    &&\entails_\logicRmlC \phi^+ \implies \allrefsBs \phi^+ \label{rml-validity-rp}
\end{eqnarray}
where $\agentsB \subseteq \agents$, $\phi, \psi \in \langRml$ and $\phi^+ \in \langMlPlusBs$.
\end{proposition}

\begin{proof}
Let $\kPModel{\kStateS}, \kPModelP{\kStateSP}, \kPModelPP{\kStateSPP} \in \classC$ be pointed Kripke models such that $\kPModel{\kStateS} \simulatesBs \kPModelP{\kStateSP}$ and $\kPModelP{\kStateSP} \simulatesBs \kPModelPP{\kStateSPP}$.
\begin{description}
    \item[(\ref{rml-validity-r})]  \hfill \\
        We show that $\entails_\logicRmlC \allrefsBs (\phi \implies \psi) \implies (\allrefsBs \phi \implies \allrefsBs \psi)$.

        Suppose that $\kPModel{\kStateS} \entails \allrefsBs (\phi \implies \psi)$ and $\kPModel{\kStateS} \entails \allrefsBs \phi$.
        Then $\kPModelP{\kStateSP} \entails \phi \implies \psi$
        and $\kPModelP{\kStateSP} \entails \phi$,
        so by modus ponens $\kPModelP{\kStateSP} \entails \psi$.
        Therefore $\kPModel{\kStateS} \entails \allrefsBs \psi$
        and $\kPModel{\kStateS} \entails \allrefsBs (\phi \implies \psi) \implies (\allrefsBs \phi \implies \allrefsBs \psi)$.
\pagebreak
    \item[(\ref{rml-validity-necr})] \hfill \\
        We show that $\entails_\logicRmlC \phi$ implies $\entails_\logicRmlC \allrefsBs \phi$.

        Suppose that $\entails \phi$. 
        Then $\kPModelP{\kStateSP} \entails \phi$ and so $\kPModel{\kStateS} \entails \allrefsBs \phi$.
        Therefore $\entails \allrefsBs \phi$
    \item[(\ref{rml-validity-rt})] \hfill \\
        We show that $\entails_\logicRmlC \allrefsBs \phi \implies \phi$.

        Suppose that $\kPModel{\kStateS} \entails \allrefsBs \phi$.
        By Proposition~\ref{refinements-preorder} we have that $\kPModel{\kStateS} \simulatesBs \kPModel{\kStateS}$ and so $\kPModel{\kStateS} \entails \phi$.
        Therefore $\kPModel{\kStateS} \entails \allrefsBs \phi \implies \phi$.
    \item[(\ref{rml-validity-r4})] \hfill \\
        We show that $\entails_\logicRmlC \allrefsBs \phi \implies \allrefsBs \allrefsBs \phi$.

        Suppose that $\kPModel{\kStateS} \entails \allrefsBs \phi$.
        By Proposition~\ref{refinements-preorder} we have that $\kPModel{\kStateS} \simulatesBs \kPModelPP{\kStateSPP}$ and so $\kPModelPP{\kStateSPP} \entails \phi$ and $\kPModel{\kStateS} \entails \allrefsBs \allrefsBs \phi$.
        Therefore $\kPModel{\kStateS} \entails \allrefsBs \phi \implies \allrefsBs \allrefsBs \phi$.
    \item[(\ref{rml-validity-rp})] \hfill \\
        We show that $\entails_\logicRmlC \phi^+ \implies \allrefsBs \phi^+$ where $\phi^+ \in \langMlPlus$.

        Suppose that $\kPModel{\kStateS} \entails \phi^+$.
        By Proposition~\ref{refinements-preserve-positive} we have that $\kPModelP{\kStateSP} \entails \phi^+$ and so $\kPModel{\kStateS} \entails \allrefsBs \phi^+$.
        Therefore $\kPModel{\kStateS} \entails \phi^+ \implies \allrefsBs \phi^+$.
\end{description}
\end{proof}

These properties resemble well-known modal axioms and rules, specifically:
(\ref{rml-validity-r}) corresponds to the modal axiom {\bf K};
(\ref{rml-validity-necr}) corresponds to the modal rule {\bf NecK};
(\ref{rml-validity-rt}) corresponds to the modal rule {\bf T}; and
(\ref{rml-validity-r4}) corresponds to the modal rule {\bf 4}.
This gives the $\allrefsBs$ operator all of the appearances of a modal operator, however we note that in general $\allrefsBs$ is not a {\em normal} modal operator.
The validity (\ref{rml-validity-rp}) corresponds to the property that refinements preserve positive formulas.
This validity prevents the logic from being closed under uniform substitution in many settings, meaning that the $\allrefsBs$ operator is not a normal modal operator.

We give an example to demonstrate the failure of closure under uniform substitution in \logicRmlK{}.

\begin{example}\label{example-uniform-substitution}
By (\ref{rml-validity-rp}) from Proposition~\ref{rml-validities} we have that $\entails_\logicRmlK{} \atomP \implies \allrefsA \atomP$.
The formula $\possibleA \atomP \implies \allrefsA \possibleA \atomP$ is a uniform substitution of $\atomP \implies \allrefs \atomP$, substituting $\possibleA \atomP$ for $\atomP$.
However we note that $\nentails_\logicRmlK{} \possibleA \atomP \implies \allrefsA \possibleA \atomP$, as the following counterexample demonstrates.
Let $\kPModelAndTuple{\kStateS}$ and $\kPModelP{\kStateS} = ((\kStates, \kAccessibilityP{}, \kValuation), \kStateS)$ be pointed Kripke models where:
\begin{eqnarray*}
    \kStates &=& \{\kStateS, \kStateT\}\\
    \kAccessibilityA &=& \{(\kStateS, \kStateS), (\kStateS, \kStateT), (\kStateT, \kStateS), (\kStateT, \kStateT)\}\\
    \kValuation(\atomP) &=& \{\kStateT\}\\
    \kAccessibilityPA &=& \{(\kStateS, \kStateS), (\kStateT, \kStateT)\}
\end{eqnarray*}
Then $\kPModel{\kStateS} \entails_\logicRmlK{} \possibleA \atomP$, $\kPModel{\kStateS} \simulatesA \kPModelP{\kStateS}$, and $\kPModelP{\kStateS} \nentails_\logicRmlK{} \possibleA \atomP$.\\
Therefore $\kPModel{\kStateS} \nentails_\logicRmlK{} \possibleA \atomP \implies \allrefsA \possibleA \atomP$.
\end{example}

The same counterexample applies to many other settings, including \classKF{}, \classKFF{}, \classKD{}, and \classS{}.
We can easily imagine settings where \logicRml{} is closed under uniform substitution, such as in a singleton class of Kripke frames, where the only refinement of a Kripke model is itself.
However settings where \logicRml{} is closed uniform substitution are of no interest at all.
Supposing that \logicRmlC{} is closed under uniform substitution then for every $\phi \in \langRml$, by (\ref{rml-validity-rt}) and a uniform substitution of (\ref{rml-validity-rp}) from Proposition~\ref{rml-validities} we would have $\entails_\logicRmlC \phi \iff \allrefsBs \phi$, making the $\allrefsBs$ operator redundant.

We next show that \logicRml{} is bisimulation invariant, regardless of the setting.

\begin{proposition}\label{rml-bisimulation-invariance}
Let $\classC$ be a class of Kripke frames and let $\kPModel{\kStateS}, \kPModelP{\kStateSP} \in \classC$ be pointed Kripke models such that $\kPModel{\kStateS} \bisimilar \kPModelP{\kStateSP}$.
Then for every $\phi \in \langRml$:
$\kPModel{\kStateS} \entails_\logicRmlC \phi$ if and only if $\kPModelP{\kStateSP} \entails_\logicRmlC \phi$.
\end{proposition}

\begin{proof}
We proceed by induction on the structure of the formula $\phi \in \langRml$.
Let $\bisimulation \subseteq \kStates \times \kStatesP$ be a bisimulation between $\kPModel{\kStateS}$ and $\kPModelP{\kStateSP}$ and let $(\kStateT, \kStateTP) \in \bisimulation$.

Suppose that $\phi = \atomP$ where $\atomP \in \atoms$.
Then $\kPModel{\kStateT} \entails \atomP$ if and only if $\kStateT \in \kValuation(\atomP)$.
By {\bf atoms-$\atomP$}, $\kStateT \in \kValuation(\atomP)$ if and only if $\kStateTP \in \kValuationP(\atomP)$.
Finally $\kStateTP \in \kValuationP(\atomP)$ if and only if $\kPModelP{\kStateTP} \entails \atomP$.
Therefore $\kPModel{\kStateT} \entails \atomP$ if and only if $\kPModelP{\kStateTP} \entails \atomP$.

Suppose that $\phi = \lnot \psi$ or $\phi = \psi \land \chi$ where $\psi, \chi \in \langRml$. These follow directly from the induction hypothesis.

Suppose that $\phi = \possibleA \psi$ where $\psi \in \langRml$.
Suppose that $\kPModel{\kStateT} \entails \possible \psi$. 
Then there exists $\kStateU \in \kSuccessorsA{\kStateT}$ such that $\kPModel{\kStateU} \entails \psi$.
As $(\kStateT, \kStateTP) \in \bisimulation$ by {\bf forth-$\agentA$} there exists $\kStateUP \in \kSuccessorsPA{\kStateTP}$ such that $(\kStateU, \kStateUP) \in \bisimulation$.
By the induction hypothesis $\kPModelP{\kStateUP} \entails \psi$.
Therefore $\kPModelP{\kStateTP} \entails \possibleA \psi$.
The converse follows a similar argument.
Therefore $\kPModel{\kStateT} \entails \possibleA \psi$ if and only if $\kPModelP{\kStateTP} \entails \possibleA \psi$.

Suppose that $\phi = \somerefsBs \psi$ where $\psi \in \langRml$.
Then $\kPModel{\kStateT} \entails \somerefsBs \psi$ if and only if there exists $\kPModelPP{\kStateTPP} \in \classC$ such that $\kPModel{\kStateT} \simulatesBs \kPModelPP{\kStateTPP}$ and $\kPModelPP{\kStateTPP} \entails \psi$.
As $\kPModel{\kStateT} \bisimilar \kPModelP{\kStateTP}$, from Proposition~\ref{bisimulation-refinement} and Proposition~\ref{refinements-preorder} we have that $\kPModel{\kStateT} \simulatesBs \kPModelPP{\kStateTPP}$ if and only if $\kPModelP{\kStateTP} \simulatesBs \kPModelPP{\kStateTPP}$.
Therefore $\kPModel{\kStateT} \entails \somerefsBs \psi$ if and only if $\kPModelP{\kStateTP} \entails \somerefsBs \psi$.

Therefore $\kPModel{\kStateS} \entails \phi$ if and only if $\kPModelP{\kStateSP} \entails \phi$.
\end{proof}

Similar to modal logic, the converse holds in \logicRml{} for modally saturated Kripke models.
However this is a trivial result, as refinement modal equivalence implies modal equivalence, which by Proposition~\ref{modal-hennessy-milner} implies bisimilarity on modally saturated Kripke models.

In the following chapters we consider \logicRml{} in a variety of modal settings, specifically \classK{}, \classKF{}, \classKFF{}, \classKD{}, and \classS{}.
We now give a few properties that are common to some or all of these settings.

We show that refinement quantifiers satisfy the Church-Rosser, McKinsey and finality properties in the settings of \classK{}, \classKF{}, \classKFF{}, \classKD{}, and \classS{}.
To do so we first introduce the notion of minimal and least refinements.

\begin{definition}[Minimal and least refinements]\label{minimal-refinement}
Let $\classC$ be a class of Kripke frames, let $\agentsB \subseteq \agents$ be a set of agents, and let $\kPModel{\kStateS}, \kPModelP{\kStateSP} \in \classC$ be Kripke models such that $\kPModel{\kStateS} \simulatesBs \kPModelP{\kStateSP}$.
Then $\kPModelP{\kStateSP}$ is a {\em minimal $\agentsB$-refinement} of $\kPModel{\kStateS}$ in \classC{} if and only if for every $\kPModelPP{\kStateSPP} \in \classC$ if $\kPModelP{\kStateSP} \simulatesBs \kPModelPP{\kStateSPP}$ then $\kPModelP{\kStateSP} \bisimilar \kPModelPP{\kStateSPP}$.
Also $\kPModelP{\kStateSP}$ is a {\em least $\agentsB$-refinement} of $\kPModel{\kStateS}$ in \classC{} if and only if for every $\kPModelPP{\kStateSPP} \in \classC$ we have $\kPModelPP{\kStateSP} \simulatesBs \kPModelP{\kStateSP}$.
\end{definition}

Minimal and least refinements are of interest to us here as refinement quantifiers collapse trivially in minimal refinements.

\begin{proposition}\label{minimal-refinement-collapse}
Let $\classC$ be a class of Kripke frames, let $\agentsB \subseteq \agents$ be a set of agents, and let $\kPModel{\kStateS}, \kPModelP{\kStateSP} \in \classC$ be Kripke models such that $\kPModelP{\kStateSP}$ is a minimal $\agentsB$-refinement of $\kPModel{\kStateS}$ in \classC{}.
Then $\kPModelP{\kStateSP} \entails_\logicRmlC \phi$ if and only if $\kPModelP{\kStateSP} \entails_\logicRmlC \allrefsBs \phi$ if and only if $\kPModelP{\kStateSP} \entails_\logicRmlC \somerefsBs \phi$.
\end{proposition}

\begin{proof}
Suppose that $\kPModelP{\kStateSP} \entails \phi$.
Let $\kPModelPP{\kStateSPP} \in \classC$ such that $\kPModelP{\kStateSP} \simulatesBs \kPModelPP{\kStateSPP}$.
As $\kPModelP{\kStateSP}$ is a minimal $\agentsB$-refinement in \classC{} then $\kPModelP{\kStateSP} \bisimilar \kPModelPP{\kStateSPP}$ and by bisimulation invariance we have $\kPModelPP{\kStateSPP} \entails \phi$.
Therefore $\kPModelP{\kStateSP} \entails \allrefsBs \phi$.

Suppose that $\kPModelP{\kStateSP} \entails \allrefsBs \phi$.
By (\ref{rml-validity-rt}) from Proposition~\ref{rml-validities} we have $\kPModelP{\kStateSP} \entails \phi$ and by its dual we have $\kPModelP{\kStateSP} \entails \somerefsBs \phi$.

Suppose that $\kPModelP{\kStateSP} \entails \somerefsBs \phi$.
Then there exists $\kPModelPP{\kStateSPP} \in \classC$ such that $\kPModelP{\kStateSP} \simulatesBs \kPModelPP{\kStateSPP}$ and $\kPModelPP{\kStateSPP} \entails \phi$.
As $\kPModelP{\kStateSP}$ is a minimal $\agentsB$-refinement in \classC{} then $\kPModelP{\kStateSP} \bisimilar \kPModelPP{\kStateSPP}$ and by bisimulation invariance we have $\kPModelP{\kStateSP} \entails \phi$.
\end{proof}

We show that every Kripke model in \classK{}, \classKF{}, \classKFF{}, \classKD{}, and \classS{} has a minimal refinement.
In all but \classKD{} this minimal refinement is also a least refinement.

\pagebreak

\begin{proposition}\label{minimal-refinement-k-k4-k45}
Every Kripke model in \classK{}, \classKF{}, and \classKFF{} has a least $\agentsB$-refinement.
\end{proposition}

\begin{proof}
Let $\classC \in \{\classK, \classKF, \classKFF\}$ and let $\kPModelAndTuple{\kStateS} \in \classC$.
We define $\kPModelP{\kStateS} = ((\kStates, \kAccessibilityP{}, \kValuation), \kStateS)$ where for every $\agentA \in \agents$, $\kStateT \in \kStates$ if $\agentA \in \agentsB$ then $\kSuccessorsPA{\kStateT} = \emptyset$ and if $\agentA \notin \agentsB$ then $\kSuccessorsPA{\kStateT} = \kSuccessorsA{\kStateT}$.
We note that $\kPModelP{\kStateS} \in \classC$.
By Proposition~\ref{subrelations-refinement} we have that $\kPModel{\kStateS} \simulatesBs \kPModelP{\kStateS}$.

Let $\kPModelPP{\kStateSPP} \in \classC$ such that $\kPModelP{\kStateS} \simulatesBs \kPModelPP{\kStateSPP}$, via some $\agentsB$-refinement $\refinement$.
We show that $\refinement$ is a bisimulation between $\kPModelP{\kStateS}$ and $\kPModelPP{\kStateSPP}$.
We already have that $(\kStateS, \kStateSPP) \in \refinement$, and {\bf atoms-$\atomP$}, {\bf forth-$\agentC$}, and {\bf back-$\agentA$} for every $\atomP \in \atoms$, $\agentC \in \agents \setminus \agentsB$, and $\agentA \in \agents$, so we need only show {\bf forth-$\agentB$} for $\agentB \in \agentsB$.
Let $(\kStateT, \kStateTPP) \in \refinement$, and $\agentB \in \agentsB$.
By construction $\kSuccessorsPB{\kStateT} = \emptyset$, so {\bf forth-$\agentB$} is satisfied trivially.
So $\refinement$ is a bisimulation between $\kPModelP{\kStateS}$ and $\kPModelPP{\kStateSPP}$ and $\kPModelP{\kStateS} \bisimilar \kPModelPP{\kStateSPP}$.
Therefore $\kPModelP{\kStateS}$ is a minimal $\agentsB$-refinement of $\kPModel{\kStateS}$ in \classC{}.


Let $\kPModelPP{\kStateSPP} \in \classC$ such that $\kPModel{\kStateS} \simulatesBs \kPModelPP{\kStateSPP}$.
From above there exists a minimal $\agentsB$-refinement, $\kPModelPPP{\kStateSPPP}$, of $\kPModelPP{\kStateSPP}$ in \classC{}.
We note that if there exists $\agentB \in \agentsB$, $\kStateTPPP \in \kStatesPPP$ such that $\kSuccessorsPPPB{\kStateTPPP} \neq \emptyset$ then $\kPModelPPP{\kStateSPPP}$ is not a minimal $\agentsB$-refinement in \classC{}, as we can form a non-bisimilar $\agentsB$-refinement by setting $\kSuccessorsPPPB{\kStateTPPP} = \emptyset$ for every $\agentB \in \agentsB$, $\kStateTPPP \in \kStatesPPP$.
By contrapositive as $\kPModelPPP{\kStateSPPP}$ is a minimal $\agentsB$-refinement in \classC{} then for every $\agentB \in \agentsB$, $\kStateTPPP \in \kStatesPPP$ we must have $\kSuccessorsPPPB{\kStateTPPP} = \emptyset$.

Suppose that $\kPModel{\kStateS} \simulatesBs \kPModelPPP{\kStateSPPP}$ via a $\agentsB$-refinement $\refinement$ from $\kPModel{\kStateS}$ to $\kPModelPPP{\kStateSPPP}$.
We show that $\refinement$ is a $\agentsB$-refinement from $\kPModelP{\kStateS}$ to $\kPModelPPP{\kStateSPPP}$.
Let $(\kStateT, \kStateTPPP) \in \refinement$, $\atomP \in \atoms$, $\agentC \in \agents \setminus \agentsB$, $\agentA \in \agentA$.

\paragraph{atoms-$\atomP$}
Follows trivially from {\bf atoms-$\atomP$} for $\refinement$ from $\kPModel{\kStateS}$ to $\kPModelPPP{\kStateSPPP}$.

\paragraph{forth-$\agentC$}
Let $\kStateU \in \kSuccessorsPC{\kStateT}$.
As $\agentC \notin \agentsB$, by construction $\kSuccessorsPC{\kStateT} = \kSuccessorsC{\kStateT}$.
By {\bf forth-$\agentC$} for $\refinement$  from $\kPModel{\kStateS}$ to $\kPModelPPP{\kStateSPPP}$ there exists $\kStateUPPP \in \kSuccessorsC{\kStateTPPP}$ such that $(\kStateU, \kStateUPPP) \in \refinement$.

\paragraph{back-$\agentA$}
Suppose that $\agentA \in \agentsB$.
From above $\kSuccessorsPPPB{\kStateTPPP} = \emptyset$ so {\bf back-$\agentA$} holds trivially.
Suppose that $\agentA \notin \agentsB$.
Let $\kStateUPPP \in \kSuccessorsPPA{\kStateTPPP}$.
By {\bf back-$\agentA$} for $\refinement$ from $\kPModel{\kStateS}$ to $\kPModelPPP{\kStateSPPP}$ there exists $\kStateU \in \kSuccessorsC{\kStateT}$ such that $(\kStateU, \kStateUPPP) \in \refinement$.
By construction $\kSuccessorsPC{\kStateT} = \kSuccessorsC{\kStateT}$ so $\kStateU \in \kSuccessorsPC{\kStateT}$.

So $\refinement$ is a $\agentsB$-refinement from $\kPModelP{\kStateS}$ to $\kPModelPPP{\kStateSPPP}$ and $\kPModelP{\kStateS} \simulatesBs \kPModelPPP{\kStateSPPP}$.
As $\kPModelP{\kStateS}$ is a minimal $\agentsB$-refinement in \classC{} then $\kPModelP{\kStateS} \bisimilar \kPModelPPP{\kStateSPPP}$ so by Proposition~\ref{bisimilar-refinement} we have $\kPModelPPP{\kStateSPPP} \simulatesBs \kPModelP{\kStateS}$.
As $\kPModelPP{\kStateSPP} \simulatesBs \kPModelPPP{\kStateSPPP}$ by transitivity we have $\kPModelPP{\kStateSPP} \simulatesBs \kPModelP{\kStateS}$.

Therefore $\kPModelP{\kStateS}$ is a least $\agentsB$-refinement of $\kPModel{\kStateS}$.
\end{proof}

\begin{proposition}\label{minimal-refinement-s4-s5}
Every Kripke model in \classS{} has a minimal $\agentsB$-refinement that is unique up to bisimulation.
\end{proposition}

\begin{proof}
Let $\kPModelAndTuple{\kStateS} \in \classS$.
We define $\kPModelP{\kStateS} = ((\kStates, \kAccessibilityP{}, \kValuation), \kStateS)$ where for every $\agentA \in \agents$, $\kStateT \in \kStates$, if $\agentA \in \agentsB$ then $\kSuccessorsPA{\kStateT} = \{\kStateT\}$ and if $\agentA \notin \agentsB$ then $\kSuccessorsPA{\kStateT} = \kSuccessorsA{\kStateT}$.
We note that $\kPModelP{\kStateS} \in \classS$.
By Proposition~\ref{subrelations-refinement} we have that $\kPModel{\kStateS} \simulatesBs \kPModelP{\kStateS}$.

Let $\kPModelPP{\kStateSPP} \in \classS$ such that $\kPModelP{\kStateS} \simulatesBs \kPModelPP{\kStateSPP}$, via some $\agentsB$-refinement $\refinement$.
We show that $\refinement$ is a bisimulation between $\kPModelP{\kStateS}$ and $\kPModelPP{\kStateSPP}$.
We already have that $(\kStateS, \kStateSPP) \in \refinement$, and {\bf atoms-$\atomP$}, {\bf forth-$\agentC$}, and {\bf back-$\agentA$} for every $\atomP \in \atoms$, $\agentC \in \agents \setminus \agentsB$, and $\agentA \in \agents$, so we need only show {\bf forth-$\agentB$} for $\agentB \in \agentsB$.
Let $(\kStateT, \kStateTPP) \in \refinement$, $\agentB \in \agentsB$, and $\kStateU \in \kSuccessorsPB{\kStateT}$.
By construction $\kSuccessorsPB{\kStateT} = \{\kStateT\}$ so $\kStateU = \kStateT$.
As $\kPModelPP \in \classS$ by reflexivity we have that $\kStateTPP \in \kSuccessorsPPB{\kStateTPP}$ and by hypothesis we have $(\kStateT, \kStateTPP) \in \refinement$, so {\bf forth-$\agentB$} holds.
So $\refinement$ is a bisimulation between $\kPModelP{\kStateS}$ and $\kPModelPP{\kStateSPP}$ and $\kPModelP{\kStateS} \bisimilar \kPModelPP{\kStateSPP}$.
Therefore $\kPModelP{\kStateS}$ is a minimal $\agentsB$-refinement of $\kPModel{\kStateS}$ in \classS{}.

Let $\kPModelPP{\kStateSPP} \in \classS$ such that $\kPModel{\kStateS} \simulatesBs \kPModelPP{\kStateSPP}$.
From above there exists a minimal $\agentsB$-refinement, $\kPModelPPP{\kStateSPPP}$, of $\kPModelPP{\kStateSPP}$ in \classS{}.
We note that if there exists $\agentB \in \agentsB$, $\kStateTPPP \in \kStatesPPP$ such that $\kSuccessorsPPB{\kStateTPPP} \neq \{\kStateTPPP\}$ then $\kPModelPPP{\kStateSPPP}$ is not a minimal $\agentsB$-refinement in \classS{}, as we can form a non-bisimilar $\agentsB$-refinement by setting $\kSuccessorsPPB{\kStateTPPP} = \{\kStateTPPP\}$ for every $\agentB \in \agentsB$, $\kStateTPPP \in \kStatesPPP$.
By contrapositive as $\kPModelPPP{\kStateSPPP}$ is a minimal $\agentsB$-refinement in \classS{} then for every $\agentB \in \agentsB$, $\kStateTPPP \in \kStatesPPP$ we must have $\kSuccessorsPPB{\kStateTPPP} = \{\kStateTPPP\}$.

Suppose that $\kPModel{\kStateS} \simulatesBs \kPModelPPP{\kStateSPPP}$ via a $\agentsB$-refinement $\refinement$ from $\kPModel{\kStateS}$ to $\kPModelPPP{\kStateSPPP}$.
We show that $\refinement$ is a $\agentsB$-refinement from $\kPModelP{\kStateS}$ to $\kPModelPPP{\kStateSPPP}$.
Let $(\kStateT, \kStateTPPP) \in \refinement$, $\atomP \in \atoms$, $\agentC \in \agents \setminus \agentsB$, $\agentA \in \agentA$.

\paragraph{atoms-$\atomP$}
Follows trivially from {\bf atoms-$\atomP$} for $\refinement$ from $\kPModel{\kStateS}$ to $\kPModelPPP{\kStateSPPP}$.

\paragraph{forth-$\agentC$}
Let $\kStateU \in \kSuccessorsPC{\kStateT}$.
As $\agentC \notin \agentsB$, by construction $\kSuccessorsPC{\kStateT} = \kSuccessorsC{\kStateT}$.
By {\bf forth-$\agentC$} for $\refinement$  from $\kPModel{\kStateS}$ to $\kPModelPPP{\kStateSPPP}$ there exists $\kStateUPPP \in \kSuccessorsC{\kStateTPPP}$ such that $(\kStateU, \kStateUPPP) \in \refinement$.

\paragraph{back-$\agentA$}
Suppose that $\agentA \in \agentsB$.
From above $\kSuccessorsPPA{\kStateTPPP} = \{\kStateTPPP\}$.
As $\kPModelP \in \classC$ (where \classC{} requires reflexivity) by reflexivity we have that $\kStateT \in \kSuccessorsPB{\kStateT}$ and by hypothesis we have $(\kStateT, \kStateTPPP) \in \refinement$.
Suppose that $\agentA \notin \agentsB$.
Let $\kStateUPPP \in \kSuccessorsPPA{\kStateTPPP}$.
By {\bf back-$\agentA$} for $\refinement$ from $\kPModel{\kStateS}$ to $\kPModelPPP{\kStateSPPP}$ there exists $\kStateU \in \kSuccessorsC{\kStateT}$ such that $(\kStateU, \kStateUPPP) \in \refinement$.
By construction $\kSuccessorsPC{\kStateT} = \kSuccessorsC{\kStateT}$ so $\kStateU \in \kSuccessorsPC{\kStateT}$.

So $\refinement$ is a $\agentsB$-refinement from $\kPModelP{\kStateS}$ to $\kPModelPPP{\kStateSPPP}$ and $\kPModelP{\kStateS} \simulatesBs \kPModelPPP{\kStateSPPP}$.
As $\kPModelP{\kStateS}$ is a minimal $\agentsB$-refinement in \classC{} then $\kPModelP{\kStateS} \bisimilar \kPModelPPP{\kStateSPPP}$.
As $\kPModelPP{\kStateSPP} \simulatesBs \kPModelPPP{\kStateSPPP}$ by transitivity we have $\kPModelPP{\kStateSPP} \simulatesBs \kPModelP{\kStateS}$.

Therefore $\kPModelP{\kStateS}$ is a least $\agentsB$-refinement of $\kPModel{\kStateS}$.
\end{proof}

\begin{proposition}\label{minimal-refinement-kd45}
Every Kripke model in \classKD{} has a minimal $\agentsB$-refinement.
\end{proposition}

\begin{proof}
Let $\kPModelAndTuple{\kStateS} \in \classKD$.
We define $\kPModelP{\kStateS} = ((\kStates, \kAccessibilityP{}, \kValuation), \kStateS)$ where for every $\agentA \in \agents$, $\kStateT \in \kStates$, if $\agentA \in \agentsB$ then $\kSuccessorsPA{\kStateT} = \{\kStateU\}$ for some $\kStateU \in \kSuccessorsA{\kStateT}$, and if $\agentA \notin \agentsB$ then $\kSuccessorsPA{\kStateT} = \kSuccessorsA{\kStateT}$.
We note that $\kPModelP{\kStateS} \in \classC$.
By Proposition~\ref{subrelations-refinement} we have that $\kPModel{\kStateS} \simulatesBs \kPModelP{\kStateS}$.

Let $\kPModelPP{\kStateSPP} \in \classC$ such that $\kPModelP{\kStateS} \simulatesBs \kPModelPP{\kStateSPP}$, via some $\agentsB$-refinement $\refinement$.
We show that $\refinement$ is a bisimulation between $\kPModelP{\kStateS}$ and $\kPModelPP{\kStateSPP}$.
We already have that $(\kStateS, \kStateSPP) \in \refinement$, and {\bf atoms-$\atomP$}, {\bf forth-$\agentC$}, and {\bf back-$\agentA$} for every $\atomP \in \atoms$, $\agentC \in \agents \setminus \agentsB$, and $\agentA \in \agents$, so we need only show {\bf forth-$\agentB$} for $\agentB \in \agentsB$.
Let $(\kStateT, \kStateTPP) \in \refinement$, $\agentB \in \agentsB$, and $\kStateU \in \kSuccessorsPB{\kStateT} = \{\kStateU\}$.
As $\kPModelPP \in \classKD$ by seriality there exists $\kStateUPP \in \kSuccessorsPPB{\kStateTPP}$ and by {\bf back-$\agentB$} for $\refinement$ we there exists $\kStateU \in \kSuccessorsPB{\kStateT} = \{\kStateU\}$ such that $(\kStateU, \kStateUPP) \in \refinement$, so {\bf forth-$\agentB$} holds.
Therefore $\kPModelP{\kStateS} \bisimilar \kPModelPP{\kStateSPP}$ and $\kPModelP{\kStateS}$ is a minimal $\agentsB$-refinement in \classC{} of $\kPModel{\kStateS}$.
\end{proof}

We note that in \classKD{} not every Kripke model has a least $\agentsB$-refinement.

We show that refinement quantifiers satisfy the McKinsey and finality properties in the settings of \classK{}, \classKF{}, \classKFF{}, \classKD{}, and \classS{}.

\begin{proposition}\label{rml-mckinsey}
Let $\classC \in \{\classK, \classKF, \classKFF, \classKD, \classS\}$. Then:
$$
\begin{array}{l}
    \entails_\logicRmlC \allrefsBs \somerefsBs \phi \implies \somerefsBs \allrefsBs \phi\\
    \entails_\logicRmlC (\allrefsBs \somerefsBs \phi \land \allrefsBs \somerefsBs \psi) \implies \somerefsBs (\phi \land \psi)
\end{array}
$$
where $\agentsB \subseteq \agents$ and $\phi, \psi \in \langRml$.
\end{proposition}

\begin{proof}
Let $\classC \in \{\classK, \classKF, \classKFF, \classKD, \classS\}$, let $\kPModel{\kStateS} \in \classC$ such that $\kPModel{\kStateS} \entails_\logicRmlC \allrefsBs \somerefsBs \phi$.
By Proposition~\ref{minimal-refinement-k-k4-k45}, Proposition~\ref{minimal-refinement-s4-s5}, and Proposition~\ref{minimal-refinement-kd45} there exists $\kPModelP{\kStateSP} \in \classC$ such that $\kPModelP{\kStateSP}$ is a minimal $\agentsB$-refinement in \classC{} of $\kPModel{\kStateS}$.
As $\kPModel{\kStateS} \simulatesBs \kPModelP{\kStateSP}$ then $\kPModelP{\kStateSP} \entails_\logicRmlC \somerefsBs \phi$.
By Proposition~\ref{minimal-refinement-collapse} we have $\kPModelP{\kStateSP} \entails_\logicRmlC \allrefsBs \phi$.
As $\kPModel{\kStateS} \simulatesBs \kPModelP{\kStateSP}$ then $\kPModel{\kStateS} \entails_\logicRmlC \somerefsBs \allrefsBs \phi$.

Let $\classC \in \{\classK, \classKF, \classKFF, \classKD, \classS\}$, let $\kPModel{\kStateS} \in \classC$ such that $\kPModel{\kStateS} \entails_\logicRmlC \allrefsBs \somerefsBs \phi \land \allrefsBs \somerefsBs \psi$.
By Proposition~\ref{minimal-refinement-k-k4-k45}, Proposition~\ref{minimal-refinement-s4-s5}, and Proposition~\ref{minimal-refinement-kd45} there exists $\kPModelP{\kStateSP} \in \classC$ such that $\kPModelP{\kStateSP}$ is a minimal $\agentsB$-refinement in \classC{} of $\kPModel{\kStateS}$.
As $\kPModel{\kStateS} \simulatesBs \kPModelP{\kStateSP}$ then $\kPModelP{\kStateSP} \entails_\logicRmlC \somerefsBs \phi$ and $\kPModelP{\kStateSP} \entails_\logicRmlC \somerefsBs \psi$.
By Proposition~\ref{minimal-refinement-collapse} we have $\kPModelP{\kStateSP} \entails_\logicRmlC \phi$ and $\kPModelP{\kStateSP} \entails_\logicRmlC \psi$.
As $\kPModel{\kStateS} \simulatesBs \kPModelP{\kStateSP}$ then $\kPModel{\kStateS} \entails_\logicRmlC \somerefsBs (\phi \land \psi)$.
\end{proof}

The converse of the McKinsey property, the Church-Rosser property, also holds in the settings of \classK{}, \classKF{}, \classKFF{}, and \classS{}.

\begin{proposition}\label{rml-church-rosser}
Let $\classC \in \{\classK, \classKF, \classKFF, \classS\}$. Then:
$$
\begin{array}{l}
    \entails_\logicRmlC \somerefsBs \allrefsBs \phi \implies \allrefsBs \somerefsBs \phi
\end{array}
$$
where $\agentsB \subseteq \agents$ and $\phi \in \langRml$.
\end{proposition}

\begin{proof}
Let $\classC \in \{\classK, \classKF, \classKFF, \classS\}$, let $\kPModel{\kStateS} \in \classC$ such that $\kPModel{\kStateS} \entails_\logicRmlC \somerefsBs \allrefsBs \phi$.
There exists $\kPModelP{\kStateS} \in \classC$ such that $\kPModel{\kStateS} \simulatesBs \kPModelP{\kStateSP}$ and $\kPModelP{\kStateSP} \entails \allrefsBs \phi$.
By Proposition~\ref{minimal-refinement-k-k4-k45}, and Proposition~\ref{minimal-refinement-s4-s5} there exists a least $\agentsB$-refinement, $\kPModelPP{\kStateSPP}$ of $\kPModel{\kStateS}$ in \classS{}.
As $\kPModelPP{\kStateSPP}$ is a least $\agentsB$-refinement of $\kPModel{\kStateS}$ and $\kPModel{\kStateS} \simulatesBs \kPModelP{\kStateS}$ then $\kPModelP{\kStateSP} \simulatesBs \kPModelPP{\kStateSPP}$.
Then $\kPModelPP{\kStateSPP} \entails \phi$.
Let $\kPModelP{\kStateS} \in \classC$ such that $\kPModel{\kStateS} \simulatesBs \kPModelP{\kStateSP}$.
As $\kPModelPP{\kStateSPP}$ is a least $\agentsB$-refinement of $\kPModel{\kStateS}$ and $\kPModel{\kStateS} \simulatesBs \kPModelP{\kStateS}$ then $\kPModelP{\kStateSP} \simulatesBs \kPModelPP{\kStateSPP}$.
Then $\kPModelP{\kStateSP} \entails \somerefsBs \phi$.
Therefore $\kPModel{\kStateS} \entails \allrefsBs \somerefsBs \phi$.
\end{proof}

The proof that \logicRml{} has the McKinsey and finality properties in the above settings relies on the fact that every Kripke model has a minimal refinement in the corresponding classes of Kripke frames.
The proof that \logicRml{} has the Church-Rosser property on the other hand relies on the fact that every Kripke model has a {\em least} refinement in the corresponding class of Kripke frames.
For \classK{}, \classKF{}, and \classKFF{} the least refinement is the refinement where each state has no $\agentsB$-successors.
For \classS{} the least refinement is the refinement where each state only has the reflexive $\agentsB$-successor.
However in the setting of \classKD{} the minimal refinements are the refinements where each state has a single $\agentsB$-successor, and there may be multiple such refinements that are distinct with respect to bisimulation.
This is why not every \classKD{} Kripke model has a least refinement, and why \logicRmlKD{} does not have the McKinsey property.

We provide an example of the failure of the Church-Rosser property in \logicRmlKD{}.

\begin{example}
\begin{figure}
    \caption{An example of a \classKD{} Kripke model and two minimal refinements.}\label{example-kd45-mckinsey}
    \centering
    \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=7em,thick]

      \node[label=above right:{$\kStateS$}] (s) {\underline{$\{\atomP\}$}};
      \node[label=below left:{$\kStateT$}] (t) [below left of=s] {$\{\atomP\}$};
      \node[label=below right:{$\kStateU$}] (u) [below right of=s] {$\{\}$};
      \node[label=above:{$\kPModel{\kStateS}$},draw=black, fit=(s) (t) (u), inner sep=3em, dashed, rounded corners] {};

      \path[every node/.style={font=\sffamily\small},->]
        (s) edge [loop above] node {$\agentA$} (s)
        (t) edge [loop below] node {$\agentA$} (t)
        (u) edge [loop below] node {$\agentA$} (u)
        (s) edge node {$\agentA$} (t)
        (s) edge node {$\agentA$} (u)
        (t) [<->] edge node {$\agentA$} (u);

      \node[label=above right:{$\kStateS$}] (s') [left=12em of s] {\underline{$\{\atomP\}$}};
      \node[label=below right:{$\kStateT$}] (t') [below of=s'] {$\{\atomP\}$};
      \node[label=above:{$\kPModelP{\kStateS}$},draw=black, fit=(s') (t'), inner sep=3em, dashed, rounded corners] {};

      \path[every node/.style={font=\sffamily\small},->]
        (s') edge [loop above] node {$\agentA$} (s')
        (t') edge [loop below] node {$\agentA$} (t')
        (s') edge node {$\agentA$} (t');

      \node[label=above right:{$\kStateS$}] (s'') [right=12em of s] {\underline{$\{\atomP\}$}};
      \node[label=below right:{$\kStateU$}] (u'') [below of=s''] {$\{\}$};
      \node[label=above:{$\kPModelPP{\kStateS}$},draw=black, fit=(s'') (u''), inner sep=3em, dashed, rounded corners] {};

      \path[every node/.style={font=\sffamily\small},->]
        (s'') edge [loop above] node {$\agentA$} (s'')
        (u'') edge [loop below] node {$\agentA$} (u'')
        (s'') edge node {$\agentA$} (u'');
    \end{tikzpicture}
\end{figure}
Consider the pointed Kripke models $\kPModel{\kStateS}$, $\kPModelP{\kStateS}$ and $\kPModelPP{\kStateS}$, shown in Figure~\ref{example-kd45-mckinsey}.

We note that $\kPModel{\kStateS} \simulatesA \kPModelP{\kStateS}$ and $\kPModel{\kStateS} \simulatesA \kPModelPP{\kStateS}$.
We note that $\kPModelP{\kStateS}$ and $\kPModelPP{\kStateS}$ are minimal $\agentA$-refinements of $\kPModel{\kStateS}$ in \classKD{}.
We also note that $\kPModelP{\kStateS} \not\simulatesA \kPModelPP{\kStateS}$ and $\kPModelPP{\kStateS} \not\simulatesA \kPModelP{\kStateS}$, so neither are least refinements.

We note that $\kPModelP{\kStateS} \entails_\logicRmlKD\necessaryA \atomP$ and $\kPModelPP{\kStateSP} \entails_\logicRmlKD\necessaryA \lnot \atomP$.
As $\necessaryA \atomP$ and $\necessaryA \lnot \atomP$ are $\agentA$-positive formulas then by (\ref{rml-validity-rp}) from Proposition~\ref{rml-validities} we have that $\kPModelP{\kStateS} \entails_\logicRmlKD\allrefsA \necessaryA \atomP$ and $\kPModelPP{\kStateSP} \entails_\logicRmlKD\allrefsA \necessaryA \lnot \atomP$.
Then $\kPModel{\kStateS} \entails_\logicRmlKD\somerefsA \allrefsA \necessaryA \atomP$.
However in \classKD{} due to seriality we have that $\entails_\logicRmlKD\necessaryA \lnot \atomP \implies \lnot \necessaryA \atomP$ so as $\kPModelPP{\kStateSP} \entails_\logicRmlKD\allrefsA \necessaryA \lnot \atomP$ we have that $\kPModelPP{\kStateSP} \entails_\logicRmlKD\allrefsA \lnot \necessaryA \atomP$ and so we have that $\kPModelPP{\kStateS} \nentails_\logicRmlKD\somerefsA \necessaryA \atomP$.
Therefore $\kPModel{\kStateS} \entails_\logicRmlKD\somerefsA \lnot \somerefsA \necessaryA \atomP$ and so $\kPModel{\kStateS} \nentails_\logicRmlKD\allrefsA \somerefsA \necessaryA \atomP$.
\end{example}

We finish with some meta-logical results for the modal settings that we will consider in the following chapters.

We show that \logicRml{} is not closed under uniform substitution for each of these settings.

\begin{proposition}
The logics \logicRmlK{}, \logicRmlKF{}, \logicRmlKFF{}, \logicRmlKD{}, and \logicRmlS{} are not closed under uniform substitution.
\end{proposition}

\begin{proof}
Example~\ref{example-uniform-substitution} gives a counter-example for closure under uniform substitution for all of these settings, showing that whilst we have that $\entails_\logicRmlC{} \atomP \implies \allrefs \atomP$ we do not have that $\entails_\logicRmlC{} \possibleB \atomP \implies \allrefs \possible \atomP$, as the successor state where $\atomP$ is valid may be removed in a refinement.
\end{proof}

As mentioned previously, settings where \logicRml{} is closed under uniform substitutions are of no interest, as in such settings we would have $\entails_\logicRmlC \phi \iff \allrefsBs \phi$, making the $\allrefsBs$ operator redundant.

Finally we remark on the sublogic hierarchy in the settings of \logicRml{} that we will consider, which is to say that there generally isn't one.
A modal logic defined over a given class of Kripke frames will be a sublogic of modal logics defined over subclasses of the given class of Kripke frames.
This is because the given class of Kripke frames only restricts which Kripke models the modal logic is interpreted over, but otherwise leaves the meaning of the modal operators unchanged, so any property that holds for a given class of Kripke frames must hold for subclasses of the given class of Kripke frames.
However in \logicRml{} the class of Kripke frames also restricts the refinements that the refinement quantifiers consider, so between different settings of \logicRml{} the meaning of the refinement quantifier changes.
This means that a property that holds for \logicRml{} in a given class of Kripke frames does not necessarily hold for \logicRml{} in a subclass of the given class of Kripke frames.

\begin{proposition}\label{rml-not-sublogics}
The logic \logicRmlK{} is not a sublogic of \logicRmlKF{}, \logicRmlKFF{}, \logicRmlKD{}, or \logicRmlS{}.
\end{proposition}

\begin{proof}
In \logicRmlK{} we have that $\entails \possibleA (\lnot \atomP \land \possibleA \atomP) \implies \somerefsA (\possibleA \possibleA \atomP \land \lnot \possibleA \atomP)$.
That is, refinements in \logicRmlK{} need not be transitive.
If we start from a Kripke model $\kPModel{\kStateS} \in \classK$, such that $\kPModel{\kStateS} \entails \possibleA (\lnot \atomP \land \possibleA \atomP)$, we can find a refinement $\kPModelP{\kStateSP} \in \classK$ such that 
$\kPModelP{\kStateSP} \somerefs (\possibleA \possibleA \atomP \land \lnot \possibleA \atomP)$ simply by removing the transitive $\agentA$-edges from $\kPModelP{\kStateS}$.
This is permissible as the frame conditions for \classK{} do not require that Kripke models be transitive.
However the logics \logicRmlKF{}, \logicRmlKFF{}, \logicRmlKD{}, or \logicRmlS{} do require that Kripke models be transitive.
In these settings we have that $\entails (\possibleA \possibleA \atomP \implies \possibleA \atomP)$ and by (\ref{rml-validity-necr}) from Proposition~\ref{rml-validities} we have that $\entails \allrefs (\possibleA \possibleA \atomP \implies \possibleA \atomP)$.
\end{proof}

We note that we can show that no distinct pair of the above logics are sublogics of one another.
This can be shown simply by focussing on the differences in frame conditions between the different logics.

In the following chapters we consider \logicRml{} in a variety of specific settings in greater detail.
In Chapter~\ref{rml-k} we consider \logicRmlK{} in the setting of \classK{}, in Chapter~\ref{rml-kd45} we consider \logicRmlKFF{} and \logicRmlKD{} in the settings of \classKFF{} and \classKD{}, in Chapter~\ref{rml-s5} we consider \logicRmlS{} in the setting of \classS{}, and in Chapter~\ref{rml-k4} we consider \logicRmlKF{} in the setting of \classKF{}.
In the settings of \classK{}, \classKFF{}, \classKD{} and, \classS{} we provide sound and complete axiomatisations for \logicRml{}, we show that \logicRml{} is decidable, and that \logicRml{} is expressively equivalent to modal logic.
In the setting of \classKF{} we show that \logicRml{} is decidable, and that its expressivity lies strictly between that of modal logic and the modal $\mu$-calculus.
