\chapter{Technical preliminaries}\label{technical}

In this chapter we recall technical definitions and results used in the following chapters.
In Section~\ref{ml} we introduce modal logic, along with logical notation and terminology applicable to the other logics we will be working with.
All of the logics that we will be considering are modal logics or extensions of modal logics, and the definitions and results of this section will be used throughout the dissertation. 
In Section~\ref{pal} we introduce public announcement logic, a logic for reasoning about the effects of specific epistemic updates, then in Section~\ref{apal} we introduce arbitrary public announcement logic, a logic for also reasoning about the effects of arbitrary epistemic updates.
As a simple form of epistemic update we often use public announcements in examples and motivation, and we consider public announcements more closely in Chapter~\ref{papal} on arbitrary positive announcement logic.
In Section~\ref{aml} we introduce action model logic, a logic for reasoning about the effects of specific epistemic updates of a more general kind than just public announcements.
As a very general form of epistemic update we use action models in motivating the investigation of refinement modal logic in Chapter~\ref{rml}, and we consider action models more closely in Chapter~\ref{aafl} on arbitrary action formula logic.
Finally in Section~\ref{mu} we introduce the modal $\mu$-calculus, a very expressive extension of modal logic that we use as a point of comparison for the expressivity of refinement modal logics in Chapter~\ref{rml}.

\section{Modal logic}\label{ml}

We recall standard definitions and results from modal logic.
For a comprehensive introduction to modal logic we direct the reader to the books by Blackburn, de~Rijke and Venema~\cite{blackburn:2001}, and Hughes and Cresswell~\cite{hughes:1996}.

Let $\atoms$ be a non-empty, countable set of propositional atoms, and
let $\agents$ be a non-empty, finite set of agents.

\begin{definition}[Language of modal logic]
The {\em language of modal logic}, \langMl{}, is inductively defined as:
$$
\phi ::= 
    \atomP \mid
    \lnot \phi \mid
    \phi \land \phi \mid
    \necessaryA \phi
$$
where $\atomP \in \atoms$ and $\agentA \in \agents$.
\end{definition}

We use all of the standard abbreviations from propositional logic:
$\bot ::= \atomP \land \lnot \atomP$;
$\top ::= \lnot \bot$;
$\phi \lor \psi ::= \lnot (\lnot \phi \land \lnot \psi)$;
$\phi \implies \psi ::= \lnot \phi \lor \psi$; and
$\phi \iff \psi ::= (\phi \implies \psi) \land (\psi \implies \phi)$.
We also use the abbreviation $\possibleA \phi ::= \lnot \necessaryA \lnot \phi$.
When we are working in a single-agent setting we will write $\necessary$ and $\possible$ instead of $\necessaryA$ and $\possibleA$.

The formula $\necessaryA \phi$ may be read as ``agent $\agentA$ {\em knows} that $\phi$ is true'', or ``agent $\agentA$ {\em believes} that $\phi$ is true'', depending on which terminology is appropriate for the setting we are working in.
The formula $\possibleA \phi$ may be read as ``agent $\agentA$ considers it possible that $\phi$ is true''.
This reading can be understood with respect to the definition of the $\possibleA$ operator as the dual of the $\necessaryA$ operator: if an agent doesn't know or believe that a statement is false, then the agent must be open to the possibility that the statement is true (and vice versa).

\begin{example}\label{example-ml-formula}
Suppose that Alice (agent $\agentA$) has flipped a coin and, being careful that Bob (agent $\agentB$) can't see it, she looks at the coin and sees that it has landed heads up (atom $\atomP$).
Then the formula $\atomP$ may be read as ``the coin landed heads up'',
the formula $\knowsA \atomP$ may be read as ``Alice knows that the coin landed heads up'',
the formula $\lnot \knowsB \atomP$ may be read as ``Bob doesn't know that the coin landed heads up'',
and the formula $\knowsA \lnot \knowsB \atomP$ may be read as ``Alice knows that Bob doesn't know that the coin landed heads up''.
If Alice was not as careful when she looked at the coin we might write the formula $\possibleA \knowsB \atomP$, which may be read as ``Alice considers it possible that Bob knows that the coin landed heads up'', 
or equivalently $\lnot \knowsA \lnot \knowsB \atomP$, which may be read as ``Alice doesn't know that Bob doesn't know that the coin landed heads up''.
\end{example}

Under the standard Kripke semantics for modal logics, modal formulas are interpreted over relational structures known as Kripke models~\cite{tarski:1941,kripke:1959,hintikka:1962}.
In epistemic and doxastic logics, Kripke models are thought of as abstract models of the knowledge or beliefs of a set of agents.

We first define Kripke frames, the relational components of Kripke models.

\begin{definition}[Kripke frames]
A {\em Kripke frame}, $\kFrameAndTuple$ consists of:
a {\em domain} $\kStates$, which is a non-empty set of states; and
an indexed set of {\em accessibility relations} $\kAccessibilityRel$, indexed on $\agents$, where for every $\agentA \in \agents$, $\kAccessibilityA \subseteq \kStates \times \kStates$ is a binary relation on states.
\end{definition}

We write $\kStateS \kAccessibilityA \kStateT$ to denote that $(\kStateS, \kStateT) \in \kAccessibilityA$.
We write $\kSuccessorsA{\kStateS}$ to denote the set of successor states $\kSuccessorsA{\kStateS} = \{\kStateT \in \kStates \mid \kStateS \kAccessibilityA \kStateT\}$ and
we write $\kPredecessorsA{\kStateT}$ to denote the set of predecessor states $\kPredecessorsA{\kStateT} = \{\kStateS \in \kStates \mid \kStateS \kAccessibilityA \kStateT\}$.

We will be working with a variety of modal logics that are defined by relational properties on Kripke frames.
We define those relational properties here.

\begin{definition}[Relational properties]
Let $\kStates$ be a set and let $\kAccessibilityRel \subseteq \kStates \times \kStates$ be a binary relation on $\kStates$. 
Then we say that $\kAccessibilityRel$ is \ldots
\begin{itemize}
    \item \ldots {\em serial} if and only if for every $\kStateS \in \kStates$ there exists $\kStateT \in \kStates$ such that $\kStateS \kAccessibility{} \kStateT$.
    \item \ldots {\em reflexive} if and only if for every $\kStateS \in \kStates$: $\kStateS \kAccessibility{} \kStateS$.
    \item \ldots {\em transitive} if and only if for every $\kStateS, \kStateT, \kStateU \in \kStates$: if $\kStateS \kAccessibility{} \kStateT$ and $\kStateT \kAccessibility{} \kStateU$ then $\kStateS \kAccessibility{} \kStateU$.
    \item \ldots {\em symmetric} if and only if for every $\kStateS, \kStateT \in \kStates$: if $\kStateS \kAccessibility{} \kStateT$ then $\kStateT \kAccessibility{} \kStateS$.
    \item \ldots {\em Euclidean} if and only if for every $\kStateS, \kStateT, \kStateU \in \kStates$: if $\kStateS \kAccessibility{} \kStateT$ and $\kStateS \kAccessibility{} \kStateU$ then $\kStateT \kAccessibility{} \kStateU$.
\end{itemize}
\end{definition}

When we ascribe relational properties to Kripke frames we actually ascribe those properties to each of the accessibility relations of the Kripke frame.
So we say that a Kripke frame $\kFrameAndTuple$ is \{serial, reflexive, etc.\} if and only if for every $\agentA \in \agents$ the binary relation $\kAccessibilityA$ is \{serial, reflexive, etc.\}.

We use these relational properties to define the classes of Kripke frames that we will be working with.

\begin{definition}[Classes of Kripke frames]
We define the following classes of Kripke frames:
\begin{itemize}
    \item The class \classK{} of all Kripke frames.
    \item The class \classKF{} of all transitive Kripke frames.
    \item The class \classKFF{} of all transitive and Euclidean Kripke frames.
    \item The class \classKD{} of all serial, transitive and Euclidean Kripke frames.
    \item The class \classSF{} of all reflexive and transitive Kripke frames.
    \item The class \classS{} of all reflexive, transitive and Euclidean Kripke frames.
\end{itemize}
\end{definition}

In order to interpret the validity of modal formulas containing propositional atoms we augment Kripke frames with valuations of propositional atoms.

\begin{definition}[Kripke models]
A {\em Kripke model}, $\kModelAndTuple$ consists of an underlying Kripke frame $\kFrameAndTuple$ along with a {\em valuation function} $\kValuation : \atoms \to \powerset(\kStates)$, which is a function from propositional atoms to sets of states.

A {\em pointed Kripke model} $\kPModelAndTuple{\kStateS}$ consists of a Kripke model $\kModelAndTuple$ along with a designated state (the {\em real world}), $\kStateS \in \kStates$.
A {\em multi-pointed Kripke model} $\kPModelAndTuple{\kStatesT}$ consists of a Kripke model $\kModelAndTuple$ along with a non-empty set of designated states, $\kStatesT \subseteq \kStates$.
\end{definition}

As we will usually work with Kripke models rather than frames we overload the notation for classes of Kripke frames to also refer to classes of Kripke models.
When we ascribe relational properties or frame properties to a Kripke model we actually ascribe those properties to its underlying Kripke frame.
We will sometimes treat a (single-)pointed Kripke model as though it were a multi-pointed Kripke model and we assume in this case that $\kPModel{\kStateS}$ is an abbreviation for $\kPModel{\{\kStateS\}}$.

We now define the semantics of modal logic.
We define the semantics in terms of a parameterised class of Kripke frames, \classC{}, which could stand for \classK{}, \classKF{}, \classKFF{}, etc. or for any other class of Kripke frames so defined.

\begin{definition}[Semantics of modal logic]\label{ml-semantics}
Let $\classC$ be a class of Kripke frames, let $\phi \in \langMl$, and let $\kPModelAndTuple{\kStateS} \in \classC$ be a pointed Kripke model.
The interpretation of the formula $\phi$ in the logic \logicC{} on the pointed Kripke model $\kPModel{\kStateS}$ is defined inductively as:
$$
\begin{array}{lcl}
\kPModel{\kStateS} \entails \atomP & \text{ iff } & \kStateS \in \kValuation(\atomP)\\
\kPModel{\kStateS} \entails \lnot \phi & \text{ iff } & \kPModel{\kStateS} \nentails \phi\\
\kPModel{\kStateS} \entails \phi \land \psi & \text{ iff } & \kPModel{\kStateS} \entails \phi \text{ and } \kPModel{\kStateS} \entails \psi\\
\kPModel{\kStateS} \entails \necessaryA \phi & \text{ iff } & \text{for every } \kStateT \in \kSuccessorsA{\kStateS} : \kPModel{\kStateT} \entails \phi
\end{array}
$$
\end{definition}

In particular we are interested in the modal logics \logicK{}, \logicKF{}, \logicKFF{}, \logicKD{}, \logicSF{} and \logicS{} for the respective classes of Kripke frames \classK{}, \classKF{}, \classKFF{}, \classKD{}, \classSF{} and \classS{}.

Let $\kPModel{\kStateS} \in \classC$ be a pointed Kripke model,
let $\kFrame \in \classC$ be a Kripke frame.
If $\kPModel{\kStateS} \entails \phi$ then we say that $\phi$ is {\em valid} on $\kPModel{\kStateS}$.
Let $\Phi \subseteq \langMl$ be a (possibly infinite) set of formulas.
If $\kPModel{\kStateS} \entails \phi$ for every $\phi \in \Phi$ then we say that $\Phi$ is {\em valid} on $\kPModel{\kStateS}$ and we write $\kPModel{\kStateS} \entails \Phi$.
If $\kPModel{\kStateS} \entails \Phi$ for every $\kStateS \in \kStates$ then we say that $\Phi$ is valid on $\kModel$ and we denote this by $\kModel \entails \Phi$.
If $\kModel \entails \Phi$ for every $\kModel$ with the underlying Kripke frame $\kFrame$ then we say that $\Phi$ is valid on $\kFrame$ and we denote this by $\kFrame \entails \Phi$.
If $\kFrame \entails \Phi$ for every $\kFrame \in \classC$ then we say that $\Phi$ is valid on \classC{} and we denote this by $\classC \entails \Phi$.
When \classC{} is clear from context we may simply write $\entails \Phi$ instead of $\classC \entails \Phi$.
If $\kStatesT \subseteq \kStates$ and there exists $\kStateS \in \kStatesT$ such that $\kPModel{\kStateS} \entails \Phi$ then we say that $\Phi$ is {\em satisfiable} in $\kPModel{\kStatesT}$.
If $\Phi$ is satisfiable in $\kPModel{\kStates}$ then we say that $\Phi$ is satisfiable in $\kModel$.
If $\Phi$ is satisfiable in $\kModel$ with the underlying Kripke frame $\kFrame$ then we say that $\Phi$ is satisfiable in $\kFrame$.
If there exists $\kFrame \in \classC$ such that $\Phi$ is satisfiable in $\kFrame$ then we say that $\Phi$ is satisfiable in \classC{}.
If every finite subset of $\Phi$ is satisfiable in \{$\kPModel{\kStatesT}$, $\kModel$, $\kFrame$, \classC{}\} then we say that $\Phi$ is {\em finitely satisfiable} in \{$\kPModel{\kStatesT}$, $\kModel$, $\kFrame$, \classC{}\}.

We write $\interpretation[\kModel]{\phi}$ to denote the set of states where $\phi$ is valid, $\interpretation[\kModel]{\phi} = \{\kStateS \in \kStates \mid \kPModel{\kStateS} \entails \phi\}$.

\begin{example}
\begin{figure}
    \caption{An example of a Kripke model.}\label{example-kripke-model}
    \centering
    \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=7em,thick]

        \node[label=above left:{$\kStateS$}] (s) {\underline{$\{\atomP\}$}};
        \node[label=above right:{$\kStateT$}] (t) [right of=s] {$\{\}$};

      \path[every node/.style={font=\sffamily\small},<->]
        (s) edge node {$\agentA$} (t)
            edge [loop above] node {$\agentA, \agentB$} (s)
        (t) edge [loop above] node {$\agentA, \agentB$} (t);
    \end{tikzpicture}
\end{figure}

Let $\kPModelAndTuple{\kStateS}$ be a Kripke model where:
\begin{eqnarray*}
    \kStates &=& \{\kStateS, \kStateT, \kStateU, \kStateV\}\\
    \kAccessibilityA &=& \{(\kStateS, \kStateS), (\kStateT, \kStateT)\}\\
    \kAccessibilityB &=& \{(\kStateS, \kStateS), (\kStateS, \kStateT), (\kStateT, \kStateS), (\kStateT, \kStateT)\}\\
    \kValuation(\atomP) &=& \{\kStateS\}
\end{eqnarray*}
This model is represented in Figure~\ref{example-kripke-model}, and can be thought of as a model for the situation described in Example~\ref{example-ml-formula}.

As $\kStateS \in \kValuation(\atomP)$ then $\kPModel{\kStateS} \entails \atomP$.
As $\kSuccessorsA{\kStateS} = \{\kStateS\}$ then $\kPModel{\kStateS} \entails \necessaryA \atomP$.
However as $\kStateT \notin \kValuation(\atomP)$ then $\kPModel{\kStateT} \nentails \atomP$,
and as $\kStateT \in \kSuccessorsB{\kStateS}$ then $\kPModel{\kStateS} \nentails \necessaryB \atomP$.
Therefore we have $\kPModel{\kStateS} \entails \lnot \necessaryB \atomP$ and also $\kPModel{\kStateS} \entails \necessaryA \lnot \necessaryB \atomP$.

\end{example}

Next we recall definitions and results related to bisimilarity of Kripke models.
Bisimilarity is an important concept in modal logics.
Notably the modal logic \logicK{} corresponds to the bisimulation-invariant fragment of first-order logic~\cite{vanbenthem:1984}, and there is a partial correspondence between bisimilarity and equivalence under modal validity~\cite{goranko:2006}.

\begin{definition}[Bisimulation]
Let $\kModelAndTuple$ and $\kModelAndTupleP$ be Kripke models.
A non-empty relation $\bisimulation \subseteq \kStates \times \kStatesP$ is a {\em bisimulation} if and only if for every $\atomP \in \atoms$, $\agentA \in \agents$ and $(\kStateS, \kStateSP) \in \bisimulation$ the following conditions, {\bf atoms-$\atomP$}, {\bf forth-$\agentA$} and {\bf back-$\agentA$} holds:

\paragraph{atoms-$\atomP$}
$\kStateS \in \kValuation(\atomP)$ if and only if $\kStateSP \in \kValuationP(\atomP)$.

\paragraph{forth-$\agentA$}
For every $\kStateT \in \kSuccessorsA{\kStateS}$ there exists $\kStateTP \in \kSuccessorsPA{\kStateSP}$ such that $(\kStateT, \kStateTP) \in \bisimulation$.

\paragraph{back-$\agentA$}
For every $\kStateTP \in \kSuccessorsPA{\kStateSP}$ there exists $\kStateT \in \kSuccessorsA{\kStateS}$ such that $(\kStateT, \kStateTP) \in \bisimulation$.

If there exists a bisimulation $\bisimulation$ such that $(\kStateS, \kStateSP) \in \bisimulation$ then we say that $\kPModel{\kStateS}$ and $\kPModelP{\kStateSP}$ are {\em bisimilar} and we denote this by $\kPModel{\kStateS} \bisimilar \kPModelP{\kStateSP}$.
\end{definition}

Bisimulations were first developed by Milner~\cite{milner:1980} and Park~\cite{park:1981} to capture a notion of process equivalence in the process algebra for concurrent systems, and have appeared in the context of modal logics since van Benthem~\cite{vanbenthem:1984}.

We first note that the bisimilarity relation forms an equivalence relation.

\begin{proposition}\label{bisimulation-equivalence-relation}
The relation $\bisimilar$ is an equivalence relation (reflexive, transitive and symmetric) on Kripke models.
\end{proposition}

Bisimilar Kripke models are equivalent under modal validity.

\begin{proposition}\label{modal-bisimulation-invariance}
Let $\kPModel{\kStateS}$ and $\kPModelP{\kStateSP}$ be pointed Kripke models such that $\kPModel{\kStateS} \bisimilar \kPModelP{\kStateSP}$.
Then for every $\phi \in \langMl$:
$\kPModel{\kStateS} \entails \phi$ if and only if $\kPModelP{\kStateSP} \entails \phi$.
\end{proposition}

Not all modally equivalent Kripke models are bisimilar.
However we can define a property of Kripke models that guarantees that modal equivalence implies bisimilarity.

\begin{definition}
Let $\kModelAndTuple$ be a Kripke model.
We say that $\kModel$ is {\em modally saturated} if and only if for every $\agentA \in \agents$, $\kStateS \in \kStates$ and $\Phi \subseteq \langMl$: if $\Phi$ is finitely satisfiable in $\kPModel{\kSuccessorsA{\kStateS}}$ then $\Phi$ is satisfiable in $\kPModel{\kSuccessorsA{\kStateS}}$.
\end{definition}

For modally saturated Kripke models, modal equivalence implies bisimilarity.

\begin{proposition}\label{modal-hennessy-milner}
Let $\kModel$ and $\kModelP$ be modally saturated Kripke models such that for every $\phi \in \langMl$: $\kPModel{\kStateS} \entails \phi$ if and only if $\kPModelP{\kStateSP} \entails \phi$.
Then $\kPModel{\kStateS} \bisimilar \kPModelP{\kStateSP}$.
\end{proposition}

A notable class of modally saturated Kripke models are the finite and image-finite Kripke models.

\begin{definition}[Finite Kripke models]
Let $\kModelAndTuple$ be a Kripke model.
We say that $\kModel$ is {\em finite} if and only if $\kStates$ is finite.
\end{definition}

\begin{definition}[Image-finiteness]
Let $\kModelAndTuple$ be a Kripke model.
We say that $\kModel$ is {\em image-finite} if and only if for every $\agentA \in \agents$ and $\kStateS \in \kStates$: $\kSuccessorsA{\kStateS}$ is finite.
\end{definition}

\begin{proposition}
Every finite Kripke model is image-finite.
\end{proposition}

\begin{proposition}
Every image-finite Kripke model is modally saturated.
\end{proposition}

Thus for image-finite Kripke models it is also the case that modal equivalence implies bisimilarity.

Bisimulations can be computed in polynomial time for finite Kripke models.

\begin{proposition}
Let $\kModel$ and $\kModelP$ be Kripke models such that $\kModel \bisimilar \kModelP$.
There is a unique, maximal bisimulation between $\kModel$ and $\kModelP$.
\end{proposition}

\begin{proposition}
Let $\kModel$ and $\kModelP$ be finite Kripke models defined on a finite set of propositional atoms such that $\kModel \bisimilar \kModelP$.
The maximal bisimulation between $\kModel$ and $\kModelP$ can be computed in polynomial time.
\end{proposition}

These results are shown by Goranko and Otto~\cite{goranko:2006}.

We can define a bisimulation-minimal version of a Kripke model by `merging' bisimilar states as in the bisimulation contraction.

\begin{definition}[Bisimulation contraction]
Let $\kModelAndTuple$ be a Kripke model,
let $\bisimulation \subseteq \kStates \times \kStates$ be the maximal bisimulation between $\kModel$ and itself,
and let ${[\kStateS]} = \{\kStateT \in \kStates \mid (\kStateT, \kStateS\}) \in \bisimulation$.
The {\em bisimulation contraction} of $\kModel$ is the quotient model $\kModelAndTupleP$ where:
\begin{eqnarray*}
    \kStatesP &=& \{{[\kStateS]} \mid \kStateS \in \kStates\}\\
    {[\kStateS]} \kAccessibilityPA {[\kStateT]} &\text{ iff }& \text{there exists } \kStateSP \in {[\kStateS]}, \kStateTP \in {[\kStateT]} \text{ such that } \kStateS \kAccessibilityA \kStateT\\
    \kValuationP(\atomP) &=& \{{[\kStateS]} \mid \kStateS \in \kValuation(\atomP)\}
\end{eqnarray*}
\end{definition}

\begin{proposition}
Let $\kModelAndTuple$ be a Kripke model and let $\kModelP$ be the bisimulation contraction of $\kModel$.
Then for every $\kStateS, \kStateT \in \kStates$: $\kPModelP{[\kStateS]} \bisimilar \kPModelP{[\kStateT]}$ if and only if $[\kStateS] = [\kStateT]$.
\end{proposition}

\begin{proposition}
Let $\kModelAndTuple$ be a Kripke model and let $\kModelP$ be the bisimulation contraction of $\kModel$.
Then for every $\kStateS \in \kStates$: $\kPModel{\kStateS} \bisimilar \kPModelP{[\kStateS]}$.
\end{proposition}

We also consider a depth-limited notion of bisimulation.

\begin{definition}[$n$-bisimulation]
Let $\kModelAndTuple$ and $\kModelAndTupleP$ be Kripke models and let $n \in \naturals$.
A list of non-empty relations $\bisimulation_0, \dots, \bisimulation_n$, where for $i = 0, \dots, n$ $\bisimulation_i \subseteq \kStates \times \kStatesP$, is an {\em $n$-bisimulation} if and only if for every $i = 0, \dots, n$, $\atomP \in \atoms$, $\agentA \in \agents$ and $(\kStateS, \kStateSP) \in \bisimulation_i$ the following conditions, {\bf atoms-$i$-$\atomP$}, {\bf forth-$i$-$\agentA$} and {\bf back-$i$-$\agentB$} holds:

\paragraph{atoms-$i$-$\atomP$}
If $i = 0$ then $\kStateS \in \kValuation(\atomP)$ if and only if $\kStateSP \in \kValuationP(\atomP)$.
If $i > 0$ then $\kPModel{\kStateS} \bisimulation_{i-1} \kPModelP{\kStateSP}$.

\paragraph{forth-$i$-$\agentA$}
For every $\kStateT \in \kSuccessorsA{\kStateS}$ there exists $\kStateTP \in \kSuccessorsPA{\kStateSP}$ such that $(\kStateT, \kStateTP) \in \bisimulation_i$.

\paragraph{back-$i$-$\agentA$}
For every $\kStateTP \in \kSuccessorsPA{\kStateSP}$ there exists $\kStateT \in \kSuccessorsA{\kStateS}$ such that $(\kStateT, \kStateTP) \in \bisimulation_i$.

If there exists an $n$-bisimulation $\bisimulation_0, \dots, \bisimulation_n$ such that $(\kStateS, \kStateSP) \in \bisimulation_n$ then we say that $\kPModel{\kStateS}$ and $\kPModelP{\kStateSP}$ are {\em $n$-bisimilar} and we denote this by $\kPModel{\kStateS} \bisimilar[n] \kPModelP{\kStateSP}$.
\end{definition}

Similar to bisimilarity, there is a partial correspondence between $n$-bisimilarity and equivalence under depth-limited modal equivalence.

\begin{proposition}
The relation $\bisimilar[n]$ is an equivalence relation on Kripke models.
\end{proposition}

\begin{definition}[Modal depth]
Let $\phi \in \langMl$.
We denote the {\em modal depth of $\phi$} by $d(\phi)$ and define it inductively as:
\begin{eqnarray*}
    d(\atomP) &=& 0\\
    d(\lnot \phi) &=& d(\phi)\\
    d(\phi \land \psi) &=& max(d(\phi), d(\psi))\\
    d(\necessaryA \phi) &=& d(\phi) + 1
\end{eqnarray*}
\end{definition}

\begin{proposition}
Let $n \in \naturals$ and let $\kPModel{\kStateS}$ and $\kPModelP{\kStateSP}$ be pointed Kripke models such that $\kPModel{\kStateS} \bisimilar[n] \kPModelP{\kStateSP}$.
Then for every $\phi \in \langMl$ such that $d(\phi) \leq n$:
$\kPModel{\kStateS} \entails \phi$ if and only if $\kPModelP{\kStateSP} \entails \phi$.
\end{proposition}

\begin{proposition}
Let $n \in \naturals$ and let $\kModel$ and $\kModelP$ be modally saturated Kripke models such that for every $\phi \in \langMl$ such that $d(\phi) \leq n$: $\kPModel{\kStateS} \entails \phi$ if and only if $\kPModelP{\kStateSP} \entails \phi$.
Then $\kPModel{\kStateS} \bisimilar[n] \kPModelP{\kStateSP}$.
\end{proposition}

We now introduce the proof theory for modal logics, first providing an axiomatisations for the logic \logicK{}.

\begin{definition}[Axiomatisation \axiomK{}]
The axiomatisation \axiomK{} is a substitution schema consisting of the following axioms and rules:
$$
\begin{array}{rl}
    {\bf P}     & \text{All propositional tautologies}\\
    {\bf K}     & \proves \necessaryA (\phi \implies \psi) \implies (\necessaryA \phi \implies \necessaryA \psi)\\
    {\bf MP}    & \text{From } \proves \phi \implies \psi \text{ and } \proves \phi \text{ infer } \proves \psi\\
    {\bf NecK}  & \text{From } \proves \phi \text{ infer } \proves \necessaryA \phi
\end{array}
$$
\end{definition}

If $\proves \phi$ is in the least set containing the axioms and closed under the rules of an axiomatisation then we say that $\phi$ is a {\em theorem} of the axiomatisation.
Let $\Phi \subseteq \langMl$ be a (possibly infinite) set of formulas.
If there exists $\phi_1, \dots, \phi_n \in \Phi$ such that $\proves (\phi_1 \land \cdots \land \phi_n) \implies \phi$ then we say that $\phi$ is {\em deducible} from $\Phi$ and we write $\Phi \proves \phi$.
If $\Phi \proves \bot$ then we say that $\Phi$ is {\em inconsistent}, and if $\Phi \nproves \bot$ then we say that $\Phi$ is {\em consistent}.

We also provide axiomatisations for the logics \logicKF{}, \logicKFF{}, \logicKD{}, \logicSF{}, and \logicS{}, by extending the axiomatisation \axiomK{} with additional axioms.

\begin{definition}[Axiomatisations \axiomKF{}, \axiomKFF{}, \axiomKD{}, \axiomSF{}, and \axiomS{}]
We define the following axioms:
$$
\begin{array}{rl}
    {\bf D}     & \proves \necessaryA \phi \implies \possibleA \phi\\
    {\bf T}     & \proves \necessaryA \phi \implies \phi\\
    {\bf 4}     & \proves \necessaryA \phi \implies \necessaryA \necessaryA \phi\\
    {\bf 5}     & \proves \possibleA \phi \implies \necessaryA \possibleA \phi
\end{array}
$$

Then the axiomatisations \axiomKF{}, \axiomKFF{}, \axiomKD{}, \axiomSF{}, and \axiomS{} consist of the axioms and rules of \axiomK{} along with the following respective additional axioms:
\begin{itemize}
    \item \axiomKF{}: {\bf 4}
    \item \axiomKFF{}: {\bf 4} and {\bf 5}
    \item \axiomKD{}: {\bf D}, {\bf 4} and {\bf 5}
    \item \axiomSF{}: {\bf T} and {\bf 4}
    \item \axiomS{}: {\bf T} and {\bf 5}
\end{itemize}
\end{definition}

\todo[inline]{Citation}

We are interested in properties of the proof theories of the logics we consider.

\begin{definition}[Soundness and completeness]
If every theorem of an axiomatisation is valid in the corresponding semantics then we say that the axiomatisation is {\em sound} with respect to the logic.
If every formula valid in a semantics is a theorem of the corresponding axiomatisation then we say that the axiomatisation is {\em (weakly) complete} with respect to the semantics.
If every set of formulas that is consistent according to an axiomatisation is satisfiable in the corresponding semantics then we say that the axiomatisation is {\em strongly complete} with respect to the semantics.
\end{definition}

\begin{proposition}
The axiomatisations \axiomK{}, \axiomKF{}, \axiomKFF{}, \axiomKD{}, \axiomSF{}, and \axiomS{} are sound and strongly complete with respect to the semantics of the respective logics \logicK{}, \logicKF{}, \logicKFF{}, \logicKD{}, \logicSF{}, and \logicS{}.
\end{proposition}

\todo[inline]{Citation}

\begin{definition}[Substitution of equivalents]
Let $\lang$ be a logical language defined on the propositional atoms $\atoms$.
An axiomatisation allows {\em substitution of equivalents} if and only if for every $\phi, \psi, \psi' \in \lang$, and $\atomP \in \atoms$: $\proves \psi \iff \psi'$ implies $\proves \phi[\psi/\atomP] \iff \phi[\psi'/\atomP]$.
\end{definition}

\begin{proposition}
The axiomatisations \axiomK{}, \axiomKF{}, \axiomKFF{}, \axiomKD{}, \axiomSF{}, and \axiomS{} allow substitution of equivalents.
\end{proposition}

We are also interested in properties of the logics themselves.

\begin{definition}[Compactness]
If every (possibly infinite) set of formulas that is finitely satisfiable according to the semantics of a logic is satisfiable then we say that the logic is {\em compact}.
\end{definition}

\begin{proposition}
The logics \logicK{}, \logicKF{}, \logicKFF{}, \logicKD{}, \logicSF{}, and \logicS{} are compact.
\end{proposition}

\todo[inline]{Citation}

\begin{definition}[Model-checking problem]
The {\em model-checking problem} for a logic is to determine for a given formula and a given finite pointed Kripke model whether the formula is valid on the pointed Kripke model.
\end{definition}

\begin{proposition}
The model-checking problems for the logics \logicK{}, \logicKF{}, \logicKFF{}, \logicKD{} and \logicS{} are decidable in polynomial time.
\end{proposition}

\todo[inline]{Citation}

\begin{definition}[Satisfiability and provability problems]
The {\em satisfiability problem} for a logic is to determine for a given formula whether the formula is satisfiable according to the semantics of the logic.
The {\em provability problem} for a proof system such as an axiomatisation is to determine for a given formula whether the formula is provable according to the proof system.
\end{definition}

We note that for sound and complete proof systems the satisfiability and provability problems are dual problems (a formula is satisfiable if and only if its negation is not provable).

\begin{proposition}
The satisfiability problems for the logics \logicK{}, \logicKF{}, \logicKFF{}, \logicKD{} and \logicS{} are decidable.
For the logics \logicK{}, \logicKFF{}, \logicKD{} and \logicS{} the problem is PSPACE-complete.\todo{Double-check complexity} 
\end{proposition}

\todo[inline]{Citation}

In the following sections and chapters we will compare the expressive power of the logics that we consider to other logics, often to an underlying modal logic.

\begin{definition}[Expressivity]
If a logic can express all of the semantic properties that another logic can then we say that the logic is {\em at least as expressive} as the other logic.
If two logics are at least as expressive as each other then we say that the two logics are {\em expressively equivalent}.
If a logic is at least as expressive as but not expressively equivalent to another logic then we say that the logic is {\em strictly less expressive} than the other logic.
If two logics are neither at least as expressive as the other logic then we say that the two logics are {\em incomparable} in expressivity.
\end{definition}

\section{Public announcement logic}\label{pal}

We recall definitions and results from the public announcement logic of Plaza~\cite{plaza:1989}.

\begin{definition}[Language of public announcement logic]
The {\em language of public announcement logic}, \langPal{}, is inductively defined as:
$$
\phi ::= 
    \atomP \mid
    \lnot \phi \mid
    \phi \land \phi \mid
    \necessaryA \phi \mid
    \announceA{\phi} \phi
$$
where $\atomP \in \atoms$ and $\agentA \in \agents$.
\end{definition}

We use all of the standard abbreviations from modal logic, in addition to the abbreviation $\announceE{\phi} \psi ::= \lnot \announceA{\phi} \lnot \psi$.

The formula $\announceA{\phi} \psi$ may be read as ``if $\phi$ is true then after publicly announcing that it is true, $\psi$ is true''.
The formula $\announceE{\phi} \psi$ may be read as ``$\phi$ is true and after publicly announcing that it is true, $\psi$ is true''.

As in modal logics, formulas of public announcement logic are interpreted over Kripke models.
The act of publicly announcing that a statement is true is modelled as an operation on Kripke models, a model restriction, that gives a new Kripke model representing the knowledge of the agents after witnessing the public announcement.

\begin{definition}[Model restriction]
Let $\kModelAndTuple$ be a Kripke model and let $\kStatesT \subseteq \kStates$.
We denote the {\em restriction of $\kModel$ to $\kStatesT$} by $\restrict{\kModel}{\kStatesT}$ and
define it as $\restrict{\kModel}{\kStatesT} = (\kStatesT, \restrict{\kAccessibilityRel}{\kStatesT}, \restrict{\kValuation}{\kStatesT})$ where:
\begin{eqnarray*}
    \restrict{\kAccessibilityA}{\kStatesT} &=& \kAccessibilityA \cap (\kStatesT \times \kStatesT)\\
    \restrict{\kValuation}{\kStatesT}(\atomP) &=& \kValuation(\atomP) \cap \kStatesT
\end{eqnarray*}

Let \lang{} be a logical language with an interpretation on $\kModel$, and let $\phi \in \lang$.
We denote the {\em restriction of $\kModel$ to $\phi$} by $\restrict{\kModel}{\phi}$ and define it as $\restrict{\kModel}{\phi} = \restrict{\kModel}{\interpretation[\kModel]{\phi}}$.
\end{definition}

\todo[inline]{Explanation of public announcements and model restrictions}

We thus define the semantics of public announcement logic using the notion of a model restriction.

\begin{definition}[Semantics of public announcement logic]\label{pal-semantics}
Let $\phi \in \langPal$ and let $\kPModelAndTuple{\kStateS} \in \classS$ be a pointed Kripke model.
The interpretation of the formula $\phi$ in the logic \logicPalS{} on the pointed Kripke model $\kPModel{\kStateS}$ is the same as its interpretation in modal logic, defined in Definition~\ref{ml-semantics}, with the additional inductive case:
$$
\begin{array}{lcl}
\kPModel{\kStateS} \entails \announceA{\phi} \psi & \text{ iff } & \kPModel{\kStateS} \entails \phi \text{ implies } \restrict{\kPModel{\kStateS}}{\phi} \entails \psi
\end{array}
$$
\end{definition}

\todo[inline]{Remark on \classS{} specific semantics.}

\begin{definition}[Axiomatisation \axiomPalS{}]
The axiomatisation \axiomPalS{} is a substitution schema consisting of the axioms and rules of \axiomS{} along with the following additional axioms and rules:
$$
\begin{array}{rl}
    {\bf AP} & \proves \announceA{\phi} \atomP \iff (\phi \implies \atomP)\\
    {\bf AN} & \proves \announceA{\phi} \lnot \psi \iff (\phi \implies \lnot \announceA{\phi} \psi)\\
    {\bf AC} & \proves \announceA{\phi} (\psi \land \chi) \iff (\announceA{\phi} \psi \land \announceA{\phi} \chi)\\
    {\bf AK} & \proves \announceA{\phi} \necessaryA \psi \iff (\phi \implies \necessaryA \announceA{\phi} \psi)\\
    {\bf AA} & \proves \announceA{\phi} \announceA{\psi} \chi \iff \announceA{\phi \land \announceA{\phi} \psi} \chi\\
    {\bf NecA} & \text{From } \proves \phi \text{ infer } \proves \announceA{\psi} \phi
\end{array}
$$
\end{definition}

\begin{proposition}
The axiomatisation \axiomPalS{} is sound and strongly complete with respect to the semantics of the logic \logicPalS{}.
\end{proposition}

\begin{proposition}
The logic \logicPalS{} is expressively equivalent to the logic \logicS{}.
\end{proposition}

\begin{proposition}
The logic \logicPalS{} is bisimulation invariant.
\end{proposition}

\begin{proposition}
The logic \logicPalS{} is compact.
\end{proposition}

\begin{proposition}
The satisfiability problem for the logic \logicPalS{} is decidable.
\end{proposition}

\section{Arbitrary public announcement logic}\label{apal}

We recall definitions and results from the public announcement logic of Balbiani, et al~\cite{balbiani:2008}.

\begin{definition}[Language of arbitrary public announcement logic]
The {\em language of arbitrary public announcement logic}, \langApal{}, is inductively defined as:
$$
\phi ::= 
    \atomP \mid
    \lnot \phi \mid
    \phi \land \phi \mid
    \necessaryA \phi \mid
    \announceA{\phi} \phi \mid
    \allpas \phi
$$
where $\atomP \in \atoms$ and $\agentA \in \agents$.
\end{definition}

We use all of the standard abbreviations from public announcement logic, in addition to the abbreviation $\somepas \phi ::= \lnot \allpas \lnot \phi$.

The formula $\allpas \phi$ may be read as ``after any public announcement $\phi$ is true''.
The formula $\somepas \phi$ may be read as ``after some public announcement $\phi$ is true''.

\begin{definition}[Semantics of arbitrary public announcement logic]
Let $\phi \in \langApal$ and let $\kPModelAndTuple{\kStateS} \in \classS$ be a pointed Kripke model.
The interpretation of the formula $\phi$ in the logic \logicApalS{} on the pointed Kripke model $\kPModel{\kStateS}$ is the same as its interpretation in public announcement logic, defined in Definition~\ref{pal-semantics}, with the additional inductive case:
$$
\begin{array}{lcl}
    \kPModel{\kStateS} \entails \allpas \psi & \text{ iff } & \text{for every } \psi \in \langMl : \kPModel{\kStateS} \entails \announceA{\psi} \phi
\end{array}
$$
\end{definition}

\begin{definition}[Necessity and possibility forms]
Consider a new symbol $\sharp$. The {\em necessity forms} are defined inductively as:
$$\psi(\sharp) ::= \sharp \mid (\phi \implies \psi(\sharp)) \mid \announceA{\phi} \psi(\sharp) \mid \knows[\agentA] \psi(\sharp)$$
where $\phi \in \langPapal$ and $\agentA \in \agents$.

The {\em possibility forms} are defined inductively as:
$$\psi(\sharp) ::= \sharp \mid (\phi \land \psi(\sharp)) \mid \announceE{\phi} \psi(\sharp) \mid \suspects[\agentA] \psi(\sharp)$$
where $\phi \in \langPapal$ and $\agentA \in \agents$.
\end{definition}

A possibility form is the dual of a necessity form.
Necessity and possibility forms contain a unique occurrence of the symbol $\sharp$.
If $\psi(\sharp)$ is a necessity or possibility form and $\phi \in \langApal$ then $\psi(\phi) ::= \psi(\sharp)[\phi/\sharp]$, where $\psi(\sharp)[\phi/\sharp]$ is $\psi(\sharp)$ with the symbol $\sharp$ replaced with the formula $\phi$, and $\psi(\phi) \in \langApal$.

\begin{definition}[Axiomatisation \axiomApalS{}]
The axiomatisation \axiomApalS{} is a substitution schema consisting of the axioms and rules of \axiomPalS{} along with the following additional axioms and rules:
$$
\begin{array}{rl}
    {\bf A+} & \proves \allpas \phi \implies \announceA{\psi} \phi \text{ where } \psi  \in \langMl\\
    {\bf R+^\omega} & \text{From } \proves \nu(\announceA{\psi} \phi) \text{ for every } \psi \in \langMl \text{ infer } \nu(\allpas \phi)
\end{array}
$$
where $\nu(\sharp)$ is a necessity form.
\end{definition}

\begin{proposition}
The axiomatisation \axiomApalS{} is sound and strongly complete with respect to the semantics of the logic \logicApalS{}.
\end{proposition}

We note that the axiomatisation \axiomApalS{} is an infinitary axiomatisation, as the rule ${\bf R+^\omega}$ requires an infinite number of premises.
As a consequence the axiomatisation is not recursively enumerable.
The rule ${\bf R+^\omega}$ can be replaced with a finitary rule of the form:
$$
\begin{array}{rl}
    {\bf R+^1} & \text{From } \proves \nu(\announceA{\atomP} \phi) \text{ infer } \nu(\allpas \phi)
\end{array}
$$
where $\nu(\sharp)$ is a necessity form and $\atomP$ is a fresh atom.

\begin{proposition}
The axiomatisation \axiomApalS{} substituting the rule ${\bf R+^\omega}$ with the rule ${\bf R+^1}$ is sound and {\em weakly} complete with respect to the semantics of the logic \logicApalS{}.
\end{proposition}

\begin{proposition}
The logic \logicApalS{} is strictly more expressive than the logic \logicPalS{}.
\end{proposition}

\begin{proposition}
The logic \logicApalS{} is not compact.
\end{proposition}

\section{Action model logic}\label{aml}

We recall definitions and results from the action model logic of Baltag, Moss and Solecki~\cite{baltag:1998,baltag:2004}.

\begin{definition}[Action models]
Let \lang{} be a logical language.
An {\em action model with preconditions defined on \lang{}}, $\aModelAndTuple$ consists of an underlying Kripke frame $\aFrameAndTuple$ along with a {\em precondition function} $\aPrecondition : \aStates \to \lang$, which is a function from actions to formulas.

A {\em pointed action model} $\aPModelAndTuple{\aStateS}$ consists of an action model $\aModelAndTuple$ along with a designated action $\aStateS \in \aStates$.
A {\em multi-pointed action model} $\aPModelAndTuple{\aStatesT}$ consists of an action model $\aModelAndTuple$ along with a non-empty set of designated action $\aStatesT \subseteq \aStates$.
\end{definition}

We use similar notation and terminology to Kripke models when discussing action models.
Similar to Kripke models, when we ascribe relational properties or frame properties to an action model we actually ascribe those properties to its underlying Kripke frame.
When the language that an action model is defined on is clear from context we will simply refer to an {\em action model}, without explicit reference to the language.

\begin{definition}[Action signature]
An {\em action signature}, $\aSignatureAndTuple$ consists of an underlying Kripke frame $\aFrameAndTuple$ along with a non-repeating list of {\em non-trivial actions}, $\aStateS_1, \dots, \aStateS_n \in \aStates$.
Let $\lang$ be a logical language and let $\phi_1, \dots, \phi_n \in \lang$ be a list of formulas.
Then we obtain an action model $\aSignature(\phi_1, \dots, \phi_n) = \aModelTuple$ where $\aPrecondition(\aStateS_i) = \phi_i$ for $i = 1, \dots, n$ and $\aPrecondition(\aStateS) = \top$ otherwise.
The {\em trivial actions} are so named because their preconditions are always set to $\top$.
\end{definition}

When we ascribe relational or frame properties to an action model or signature we actually ascribe those properties to its underlying Kripke frame.
As we will often work with action models and signatures rather than Kripke frames we overload the notation for classes of Kripke frames to also refer to classes of action models or signatures.

\begin{definition}[Language of action model logic]
Let \aSignatureFamily{} be a non-empty, countable set of action signatures.
The {\em language of action model logic} with action signatures \aSignatureFamily{}, $\langAml(\aSignatureFamily)$, is inductively defined as:
$$
\phi ::=
    \atomP \mid
    \lnot \phi \mid
    \phi \land \phi \mid
    \necessaryA \phi \mid
    \actionA{\aSignature \aStatesT, \phi, \dots, \phi} \phi\\
$$
where $\atomP \in \atoms$, $\agentA \in \agents$, $\aSignatureAndTuple \in \aSignatureFamily$, $\aStatesT \subseteq \aStates$, and the number of parameters to a given action signature $\aSignature$ is determined by the number of designated actions in the action signature.
\end{definition}

We use all of the standard abbreviations from modal logic, in addition to the abbreviations 
$\actionA{\aPModel{\aStatesT}} \phi ::= \actionA{\aSignature \aStatesT, \phi_1, \dots, \phi_n} \phi$ where $\aModel = \aSignature(\phi_1, \dots, \phi_n)$ and 
$\actionE{\aPModel{\aStatesT}} \phi ::= \lnot \actionA{\aPModel{\aStatesT}} \lnot \phi$.

\begin{definition}[Semantics of action model logic]
Let \classC{} be a class of Kripke models and let \aSignatureFamily{} be a non-empty, countable set of action signatures.
We define the semantics of action model logic and the notion of action model execution simultaneously.

Let $\kModelAndTuple \in \classC$ be a Kripke model and $\aModelAndTuple \in \classK$ be an action model with preconditions defined on $\langAml(\aSignatureFamily)$.
We denote the result of executing the action model $\aModel$ on the Kripke model $\kModel$ as $\kModel \exec \aModel$ and define it as $\kModel \exec \aModel = \kModelTupleP$ where:
\begin{eqnarray*}
    \kStatesP &=& \{(\kStateS, \aStateS) \in \kStates \times \aStates \mid \kPModel{\kStateS} \entails \aPrecondition(\aStateS)\}\\
    (\kStateS, \aStateS) \kAccessibilityPA (\kStateT, \aStateT) &\text{ iff }& \kStateS \kAccessibilityA \kStateT \text{ and } \aStateS \aAccessibilityA \aStateT\\
    \kValuationP(\atomP) &=& \{(\kStateS, \aStateS) \in \kStatesP \mid \kStateS \in \kValuation(\atomP)\}
\end{eqnarray*}
We denote the result of executing the pointed action model $\aPModel{\aStateS}$ on the pointed Kripke model $\kPModel{\kStateS}$ as $\kPModel{\kStateS} \exec \aPModel{\aStateS}$ and define it as $\kPModel{\kStateS} \exec \aPModel{\aStateS} = (\kModel \exec \aModel, (\kStateS, \aStateS))$. Note that $\kPModel{\kStateS} \exec \aPModel{\aStateS}$ is undefined if $\kPModel{\kStateS} \nentails \aPrecondition(\aStateS)$ as then $(\kStateS, \aStateS) \notin \kStatesP$.

Let $\phi \in \langAml(\aSignatureFamily)$ and let $\kPModelAndTuple{\kStateS} \in \classC$ be a pointed Kripke model.
The interpretation of the formula $\phi$ in the logic \logicAmlC{} on the pointed Kripke model $\kPModel{\kStateS}$ is the same as its interpretation in modal logic, defined in Definition~\ref{ml-semantics}, with the additional inductive cases:
$$
\begin{array}{lcl}
    \kPModel{\kStateS} \entails \actionA{\aPModel{\aStateS}} \phi & \text { iff } & \kPModel{\kStateS} \entails \aPrecondition(\aStateS) \text{ implies } \kPModel{\kStateS} \exec \aPModel{\aStateS} \entails \phi\\
    \kPModel{\kStateS} \entails \actionA{\aPModel{\aStatesT}} \phi & \text { iff } & \text{for every } \aStateS \in \aStatesT: \kPModel{\kStateS} \entails \actionA{\aPModel{\aStateS}}
\end{array}
$$
\end{definition}

We are interested in the following variants of action model:
\begin{itemize}
    \item \logicAmlK{} interpreted over the class of \classK{} Kripke frames and the language of action model logic $\langAml(\classK)$ with action signatures defined on the class of finite \classK{} Kripke frames.
    \item \logicAmlKFF{} interpreted over the class of \classKFF{} Kripke frames and the language of action model logic $\langAml(\classKFF)$ with action signatures defined on the class of finite \classKFF{} Kripke frames.
    \item \logicAmlS{} interpreted over the class of \classS{} Kripke frames and the language of action model logic $\langAml(\classS)$ with action signatures defined on the class of finite \classS{} Kripke frames.
\end{itemize}

\begin{definition}[Skip and crash]
    We define the action models \aSkip{} and \aCrash{} as follows:
    \begin{eqnarray*}
        \aSkip &=& ((\{\aStateS\}, \{(\aStateS, \aStateS)\}, \{(\aStateS, \top)\}), \aStateS)\\
        \aCrash &=& ((\{\aStateS\}, \{(\aStateS, \aStateS)\}, \{(\aStateS, \bot)\}), \aStateS)
    \end{eqnarray*}
\end{definition}

The action model \aSkip{} is intended to represent an epistemic update that always succeeds and has no effect,
whereas the action model \aCrash{} is intended to represent an epistemic update that never succeeds.
Indeed we note that $\entails \actionE{\aSkip} \top$, $\entails \actionA{\aSkip} \phi \iff \phi$ and $\entails \lnot \actionE{\aCrash} \top$.

We note that as $\top$ and $\bot$ are in the language $\langAml(\aSignatureFamily)$ for any set of action signatures $\aSignatureFamily$, and so \aSkip{} and \aCrash{} are action models with preconditions defined on $\langAml(\aSignatureFamily)$.
However a given $\aSignatureFamily$ may not contain any action signature that would allow one to construct \aSkip{} or \aCrash{}, so statements about \aSkip{} and \aCrash{} may not be allowed by the language $\langAml(\aSignatureFamily)$.

\begin{definition}[Disjoint union]
    Let $\aPModelAndTuple{\aStatesT}$ and $\aPModelAndTupleP{\aStatesTP}$ be action models.
    We denote the {\em disjoint union of $\aPModel{\aStatesT}$ and $\aPModelP{\aStatesTP}$} as $\aPModel{\aStatesT} \choice \aPModelP{\aStatesTP}$ and define it as $\aPModel{\aStatesT} \choice \aPModelP{\aStatesTP} = \aPModelAndTuplePP{\aStatesTPP}$ where:
    \begin{eqnarray*}
        \aStatesPP &=& \aStates \cup \aStatesP\\
        \aAccessibilityPPA &=& \aAccessibilityA \cup \aAccessibilityPA\\
        \aPreconditionPP &=& \aPrecondition \cup \aPreconditionP\\
        \aStatesTPP &=& \aStatesT \cup \aStatesTP
    \end{eqnarray*}
\end{definition}

The operation of disjoint union of action models is intended to represent the epistemic update that is formed by the non-deterministic choice between two epistemic updates.
Indeed we note that $\entails \actionA{\aPModel{\aStatesT} \choice \aPModelP{\aStatesTP}} \phi \iff (\actionA{\aPModel{\aStatesT}} \phi \land \actionA{\aPModelP{\aStatesTP}} \phi)$.

We will sometimes take the `disjoint' union of two action models that are not actually disjoint and we assume in this case that we implicitly rename the actions in each action model so that the domains become disjoint before taking the disjoint union.

\begin{definition}[Sequential composition]
    Let $\aPModelAndTuple{\aStatesT}$ and $\aPModelAndTupleP{\aStatesTP}$ be action models.
    We denote the {\em sequential composition of $\aPModel{\aStatesT}$ and $\aPModelP{\aStatesTP}$} as $\aPModel{\aStatesT} \compose \aPModelP{\aStatesTP}$ and define it as $\aPModel{\aStatesT} \compose \aPModelP{\aStatesTP} = \aPModelAndTuplePP{\aStatesTPP}$ where:
    \begin{eqnarray*}
        \aStatesPP &=& \aStates \times \aStatesP\\
        (\aStateS, \aStateSP) \aAccessibilityPPA (\aStateT, \aStateTP) &\text{ iff }& \aStateS \aAccessibilityA \aStateT \text{ and } \aStateSP \aAccessibilityPA \aStateTP\\
        \aPreconditionPP((\aStateS, \aStateSP)) &=& \aPrecondition(\aStateS) \land \actionA{\aPModel{\aStateS}} \aPreconditionP(\aStateSP)\\
        \aStatesTPP &=& \aStatesT \times \aStatesTP
    \end{eqnarray*}
\end{definition}

The operation of sequential composition of action models is intended to represent the epistemic update that is formed by sequentially performing two epistemic updates.
Indeed we note that $\entails \actionA{\aPModel{\aStatesT} \compose \aPModelP{\aStatesTP}} \phi \iff \actionA{\aPModel{\aStatesT}} \actionA{\aPModelP{\aStatesTP}} \phi$.

Using the \aSkip{} and \aCrash{} action models, along with the operations of disjoint union and sequential composition we may define an extended language of action model logic.

\begin{definition}[Language of action model logic (extended)]
Let \aSignatureFamily{} be a non-empty, countable set of action signatures.
The {\em language of action model logic} with action signatures \aSignatureFamily{}, $\langAml(\aSignatureFamily)$, is inductively defined as:
$$
\phi ::=
    \atomP \mid
    \lnot \phi \mid
    \phi \land \phi \mid
    \necessaryA \phi \mid
    \actionA{\alpha} \phi
$$
where $\atomP \in \atoms$, $\agentA \in \agents$, and the {\em language of action model logic actions} with action signatures \aSignatureFamily{}, $\langAmlAct(\aSignatureFamily)$, is inductively defined as:
$$
\alpha ::=
    \aSkip \mid
    \aCrash \mid
    \aSignature \aStatesT, \phi, \dots, \phi \mid
    \alpha \choice \alpha \mid
    \alpha \compose \alpha
$$
where , $\aSignatureAndTuple \in \aSignatureFamily$, $\aStatesT \subseteq \aStates$, and the number of parameters to a given action signature $\aSignature$ is determined by the number of designated actions in the action signature.
\end{definition}

We use all of the standard abbreviations from action model logic.
The semantics of formulas of this extended language should be obvious.
We note that formulas of the extended language can be translated back into the basic language using the equivalences listed above.

We note the following algebraic properties of action model logic actions:

\begin{proposition}
Let $\alpha, \beta, \gamma \in \langAmlAct$ and let $\phi \in \langAml$. Then:
$$
\begin{array}{l}
    \entails \actionA{\alpha \choice \aCrash} \phi \iff \actionA{\alpha} \phi\\
    \entails \actionA{\alpha \choice \beta} \phi \iff \actionA{\beta \choice \alpha} \phi\\
    \entails \actionA{(\alpha \choice \beta) \choice \gamma} \phi \iff \actionA{\alpha \choice (\beta \choice \gamma)} \phi\\
    \entails \actionA{\alpha \compose \aSkip} \phi \iff \actionA{\alpha} \phi\\
    \entails \actionA{\aSkip \compose \alpha} \phi \iff \actionA{\alpha} \phi\\
    \entails \actionA{(\alpha \compose \beta) \compose \gamma} \phi \iff \actionA{\alpha \compose (\beta \compose \gamma)} \phi\\
    \entails \actionA{(\alpha \choice \beta) \compose \gamma} \phi \iff \actionA{(\alpha \compose \gamma) \choice (\beta \compose \gamma)} \phi
\end{array}
$$
\end{proposition}

Similar to Kripke models there is a notion of bisimilarity of action models.

\begin{definition}[Bisimulation of action models]
Let $\aModelAndTuple$ and $\aModelAndTupleP$ be action models.
A non-empty relation $\bisimulation \subseteq \aStates \times \aStatesP$ is a {\em bisimulation} if and only if for every $\agentA \in \agents$ and $(\aStateS, \aStateSP) \in \bisimulation$ the following conditions, {\bf preconditions}, {\bf forth-$\agentA$} and {\bf back-$\agentB$} holds:

\paragraph{preconditions}
$\entails \aPrecondition(\aStateS) \iff \aPrecondition(\aStateSP)$.

\paragraph{forth-$\agentA$}
For every $\aStateT \in \aSuccessorsA{\aStateS}$ there exists $\aStateTP \in \aSuccessorsPA{\aStateSP}$ such that $\aStateT \bisimulation \aStateTP$.

\paragraph{back-$\agentA$}
For every $\aStateTP \in \aSuccessorsPA{\aStateSP}$ there exists $\aStateT \in \aSuccessorsA{\aStateS}$ such that $\aStateT \bisimulation \aStateTP$.

If there exists a bisimulation $\bisimulation$ such that $\aStateS \bisimulation \aStateSP$ then we say that $\aPModel{\aStateS}$ and $\aPModelP{\aStateSP}$ are {\em bisimilar} and we denote this by $\aPModel{\aStateS} \bisimilar \aPModelP{\aStateSP}$.
\end{definition}

\begin{proposition}
The relation $\bisimilar$ is an equivalence relation on action models.
\end{proposition}

Bisimilar action models have bisimilar results on bisimilar Kripke models.

\begin{proposition}\label{action-bisimulation-results}
Let $\kPModel{\kStateS}$ and $\kPModelP{\kStateSP}$ be pointed Kripke models such that $\kPModel{\kStateS} \bisimilar \kPModelP{\kStateSP}$ and
let $\aPModel{\aStateS}$ and $\aPModelP{\aStateSP}$ be pointed action models such that $\aPModel{\aStateS} \bisimilar \aPModelP{\aStateSP}$.
Then $\kPModel{\kStateS} \exec \aPModel{\aStateS} \bisimilar \kPModelP{\kStateSP} \exec \aPModelP{\aStateSP}$.
\end{proposition}

In particular, due to Proposition~\ref{modal-bisimulation-invariance} and Proposition~\ref{action-bisimulation-results} we have:

\begin{proposition}
Let $\kPModel{\kStateS}$ and $\kPModelP{\kStateSP}$ be pointed Kripke models such that $\kPModel{\kStateS} \bisimilar \kPModelP{\kStateSP}$ and
let $\aPModel{\aStateS}$ be a pointed action model.
Then for every $\phi \in \langAml$: $\kPModel{\kStateS} \entails \phi$ if and only if $\kPModelP{\kStateSP} \entails \phi$.
\end{proposition}

\begin{proposition}
Let $\kPModel{\kStateS}$ be a pointed Kripke model and
let $\aPModel{\aStateS}, \aPModelP{\aStateSP}$ be pointed action models such that $\aPModel{\aStateS} \bisimilar \aPModelP{\aStateSP}$.
Then for every $\phi \in \langAml$: $\kPModel{\kStateS} \entails \actionA{\aPModel{\aStateS}} \phi$ if and only if $\kPModel{\kStateS} \entails \actionA{\aPModelP{\aStateSP}} \phi$.
\end{proposition}

We also have a notion of depth-limited bisimilarity of action models.

\begin{definition}[$n$-bisimulation]
Let $\aModelAndTuple$ and $\aModelAndTupleP$ be Kripke models and let $n \in \naturals$.
A list of non-empty relations $\bisimulation_0, \dots, \bisimulation_n$, where for $i = 0, \dots, n$ $\bisimulation_i \subseteq \aStates \times \aStatesP$, is an {\em $n$-bisimulation} if and only if for every $i = 0, \dots, n$, $\atomP \in \atoms$, $\agentA \in \agents$ and $(\aStateS, \aStateSP) \in \bisimulation_i$ the following conditions, {\bf atoms-$i$-$\atomP$}, {\bf forth-$i$-$\agentA$} and {\bf back-$i$-$\agentB$} holds:

\paragraph{preconditions-$i$}
If $i = 0$ then $\entails \aPrecondition(\aStateS) \iff \aPreconditionP(\aStateSP)$.
If $i > 0$ then $\aPModel{\aStateS} \bisimulation_{i-1} \aPModelP{\aStateSP}$.

\paragraph{forth-$i$-$\agentA$}
For every $\aStateT \in \aSuccessorsA{\aStateS}$ there exists $\aStateTP \in \aSuccessorsPA{\aStateSP}$ such that $\aStateT \bisimulation_i \aStateTP$.

\paragraph{back-$i$-$\agentA$}
For every $\aStateTP \in \aSuccessorsPA{\aStateSP}$ there exists $\aStateT \in \aSuccessorsA{\aStateS}$ such that $\aStateT \bisimulation_i \aStateTP$.

If there exists an $n$-bisimulation $\bisimulation_0, \dots, \bisimulation_n$ such that $\aStateS \bisimulation_n \aStateSP$ then we say that $\aPModel{\aStateS}$ and $\aPModelP{\aStateSP}$ are {\em $n$-bisimilar} and we denote this by $\aPModel{\aStateS} \bisimilar[n] \aPModelP{\aStateSP}$.
\end{definition}

\begin{definition}[Modal depth]
Let $\phi \in \langAml$.
We denote the {\em modal depth of $\phi$} by $d(\phi)$ and define it inductively as:
\begin{eqnarray*}
    d(\atomP) &=& 0\\
    d(\lnot \phi) &=& d(\phi)\\
    d(\phi \land \psi) &=& max(d(\phi), d(\psi))\\
    d(\necessaryA \phi) &=& d(\phi) + 1\\
    d(\actionA{\aPModel{\aStateS}} \phi) &=& d(\phi)
\end{eqnarray*}
\end{definition}

\begin{proposition}
Let $n \in \naturals$,
let $\kPModel{\kStateS}$ and $\kPModelP{\kStateSP}$ be pointed Kripke models such that $\kPModel{\kStateS} \bisimilar[n] \kPModelP{\kStateSP}$ and
let $\aPModel{\aStateS}$ and $\aPModelP{\aStateSP}$ be pointed action models such that $\aPModel{\aStateS} \bisimilar[n] \aPModelP{\aStateSP}$.
Then $\kPModel{\kStateS} \exec \aPModel{\aStateS} \bisimilar[n] \kPModelP{\kStateSP} \exec \aPModelP{\aStateSP}$.
\end{proposition}

\begin{proposition}
Let $n \in \naturals$,
let $\kPModel{\kStateS}$ and $\kPModelP{\kStateSP}$ be pointed Kripke models such that $\kPModel{\kStateS} \bisimilar[n] \kPModelP{\kStateSP}$ and
let $\aPModel{\aStateS}$ be a pointed action model.
Then for every $\phi \in \langAml$ such that $d(\phi) \leq n$: $\kPModel{\kStateS} \entails \phi$ if and only if $\kPModelP{\kStateSP} \entails \phi$.
\end{proposition}

\begin{proposition}
Let $n \in \naturals$,
let $\kPModel{\kStateS}$ be a pointed Kripke model and
let $\aPModel{\aStateS}, \aPModelP{\aStateSP}$ be pointed action models such that $\aPModel{\aStateS} \bisimilar[n] \aPModelP{\aStateSP}$.
Then for every $\phi \in \langAml$ such that $d(\phi) \leq n$: $\kPModel{\kStateS} \entails \actionA{\aPModel{\aStateS}} \phi$ if and only if $\kPModel{\kStateS} \entails \actionA{\aPModelP{\aStateSP}} \phi$.
\end{proposition}

\begin{definition}[Axiomatisations \axiomAmlK{}, \axiomAmlKFF{}, and \axiomAmlS{}]
The axiomatisations \axiomAmlK{}, \axiomAmlKFF{}, and \axiomAmlS{} are substitution schemas consisting of the respective axioms and rules of \axiomK{}, \axiomKFF{}, and \axiomS{} along with the following additional axioms and rules:
$$
\begin{array}{rl}
    {\bf AP} & \proves \actionA{\aPModel{\aStateS}} \atomP \iff (\aPrecondition(\aStateS) \implies \atomP)\\
    {\bf AN} & \proves \actionA{\aPModel{\aStateS}} \lnot \phi \iff (\aPrecondition(\aStateS) \implies \lnot \actionA{\aPModel{\aStateS}} \phi)\\
    {\bf AC} & \proves \actionA{\aPModel{\aStateS}} (\phi \land \psi) \iff (\actionA{\aPModel{\aStateS}} \phi \land \actionA{\aPModel{\aStateS}} \psi)\\
    {\bf AK} & \proves \actionA{\aPModel{\aStateS}} \necessaryA \phi \iff (\aPrecondition(\aStateS) \implies \necessaryA \bigwedge_{\aStateT \in \aSuccessorsA{\aStateS}} \actionA{\aPModel{\aStateT}} \phi)\\
    {\bf AU} & \proves \actionA{\aPModel{\aStatesT}} \phi \iff \bigwedge_{\aStateT \in \aStatesT} \actionA{\aPModel{\aStateT}} \phi\\
    {\bf NecA} & \text{From } \proves \phi \text{ infer } \proves \actionA{\aPModel{\aStatesT}} \phi
\end{array}
$$
\end{definition}

\begin{proposition}
The axiomatisations \axiomAmlK{}, \axiomAmlKFF{}, and \axiomAmlS{} are sound and strongly complete with respect to the semantics of the respective logics \logicAmlK{}, \logicAmlKFF{}, and \logicAmlS{}.
\end{proposition}

\begin{proposition}
The logics \logicAmlK{}, \logicAmlKFF{}, and \logicAmlS{} are expressively equivalent to the respective logics \logicK{}, \logicKFF{}, and \logicS{}.
\end{proposition}

\begin{proposition}
The logics \logicAmlK{}, \logicAmlKFF{}, and \logicAmlS{} are compact.
\end{proposition}

\begin{proposition}
The satisfiability problems for the logics \logicAmlK{}, \logicAmlKFF{}, and \logicAmlS{} are decidable.
\end{proposition}

\section{Modal $\mu$-calculus}\label{mu}

Let $\variables$ be a non-empty, countable set of variables.

\begin{definition}[Language of modal $\mu$-calculus]
The {\em language of modal $\mu$-calculus}, \langMu{}, is inductively defined as:
$$
\phi ::= 
    \atomP \mid
    \varX \mid
    \lnot \phi \mid
    \phi \land \phi \mid
    \necessaryA \phi \mid
    \lfpX \phi
$$
where $\atomP \in \atoms$, $\agentA \in \agents$ and $\varX \in \variables$, and in $\lfpX \phi$ every free occurrence of $\varX$ in $\phi$ occurs positively (i.e. within the scope of an even number of negations).
\end{definition}

We use all of the standard abbreviations from modal logic, in addition to the abbreviation $\gfpX \phi ::= \lnot \lfpX \lnot \phi$.

\begin{definition}[Semantics of modal $\mu$-calculus]\label{mu-semantics}
Let $\classC$ be a class of Kripke frames, let $\phi \in \langMu$, let $\kPModelAndTuple{\kStateS} \in \classC$ be a pointed Kripke model and let $\kAssignment : \varX \to \powerset(\kStates)$ be a function from variables to sets of states.
The set of states $\interpretation[\kAssignment]{\phi} \subseteq \kStates$ where $\phi$ is satisfied with respect to an assignment $\kAssignment$ is defined inductively as follows:
\begin{eqnarray*}
    \interpretation[\kAssignment]{\atomP} &=& \kValuation(\atomP)\\
    \interpretation[\kAssignment]{\varX} &=& \kAssignment(\varX)\\
    \interpretation[\kAssignment]{\phi \land \psi} &=& \interpretation[\kAssignment]{\phi} \cap \interpretation[\kAssignment]{\psi}\\
    \interpretation[\kAssignment]{\necessaryA \phi} &=& \{ \kStateS \in \kStates \mid \kStateS \kAccessibility{\agentA} \subseteq \interpretation[\kAssignment]{\phi} \}\\
    \interpretation[\kAssignment]{\lfp{\varX} \phi} &=& \bigcap \{ \kStatesT \subseteq \kStates \mid \interpretation[\kAssignmentSubstitute{\kStatesT}{\varX}]{\phi} \subseteq \kStatesT \}
\end{eqnarray*}
where $\kAssignmentSubstitute{\kStatesT}{\varX}$ is the assignment such that $\kAssignmentSubstitute{\kStatesT}{\varX}(\varX) = \kStatesT$ and $\kAssignmentSubstitute{\kStatesT}{\varX}(\varY) = \kAssignment(\varY)$ for $\varY \neq \varX$. 
\end{definition}

\begin{proposition}
The logics \logicMuK{}, \logicMuKF{}, \logicMuKFF{}, \logicMuKD{}, \logicMuSF{} and \logicMuS{} are strictly more expressive than the respective logics \logicK{}, \logicKF{}, \logicKFF{}, \logicKD{}, \logicSF{} and \logicS{}.
\end{proposition}
